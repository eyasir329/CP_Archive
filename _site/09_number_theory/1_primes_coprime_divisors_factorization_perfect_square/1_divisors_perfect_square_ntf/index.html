<pre>
- odd number of divisors are perfect square (i==n/i we eliminate one divisors because of unique divisors.) (ex. cf2020B)
- otherwise all other number has even number of divisors
</pre>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//finding divisors using sqrt method O(sqrt(n))</span>
<span class="c1">//used to find single number</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="n">divisors_of_n</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="n">divisors</span><span class="p">;</span>
    <span class="c1">//we have to maintain (i*i) not go to overflow</span>
    <span class="c1">//if(overflow) then it go to infinite loop</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">*</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span><span class="c1">//because of sqrt()-&gt; may cause precision error</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">%</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">divisors</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">n</span> <span class="o">/</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span><span class="c1">//because of unique divisors</span>
                <span class="n">divisors</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">n</span> <span class="o">/</span> <span class="n">i</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">sort</span><span class="p">(</span><span class="n">divisors</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">divisors</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">x</span> <span class="o">:</span> <span class="n">divisors</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">divisors</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>Number of Divisors from 1 to N (Each Number)</li>
</ul>

<pre>
  normal way O(nsqrt(n) causes TLE) (n upto 1e5)-&gt; O(nlogn)
</pre>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//complexity O(nlogn)</span>
<span class="c1">//used to find multiple number</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">N</span> <span class="o">=</span> <span class="mf">1e7</span><span class="o">+</span><span class="mi">9</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">d</span><span class="p">[</span><span class="n">N</span><span class="p">];</span>
<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">N</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
  <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="n">i</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">N</span><span class="p">;</span><span class="n">j</span><span class="o">+=</span><span class="n">i</span><span class="p">){</span><span class="c1">//harmonic series</span>
    <span class="n">d</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="c1">// if(d[i]==2) -&gt; they are prime</span>
</code></pre></div></div>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
  <span class="k">if</span><span class="p">(</span><span class="n">n</span><span class="o">%</span><span class="n">i</span><span class="o">==</span><span class="mi">0</span><span class="p">){</span>
    <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">i</span><span class="o">&lt;&lt;</span><span class="s">" "</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>
    <table>
      <tbody>
        <tr>
          <td>(b</td>
          <td>a) -&gt; b divide a</td>
        </tr>
      </tbody>
    </table>
  </li>
</ul>

<p>example:</p>

<ul>
  <li>
    <p>atcoder C - Cream puff</p>
  </li>
  <li><a href="https://codeforces.com/problemset/problem/1485/A">1485A_Add and Divide</a>
    <pre>
You can perform two kinds of operations:
  
    a=⌊a/b⌋ (replace a with the integer part of the division between a and b)
    b=b+1 (increase b by 1) 
  
Find the minimum number of operations required to make a=0
</pre>

    <pre>
we can try to increase b to a certain value and then divide a by b until it is 0. Being careful as not to do this with b&lt;2, the number of times we divide is going to be O(loga). In particular, if you reach b≥2 (this requires at most 1 move), you need at most ⌊log2(10^9)⌋=29 moves to finish.
  
Let y be the number of moves of type 2; we can try all values of y (0≤y≤30) and, for each y, check how many moves of type 1 are necessary.
  
Complexity: O(log^2 a)
</pre>
  </li>
  <li><a href="">2029A_Set</a></li>
  <li>
    <p>One of the first 1234567 positive integers is chosen at random. Compute the
probability that it is divisible by 3?</p>

    <pre>
-&gt; Pattern Identification:
  Every third number in the sequence of positive integers is divisible by 3:
  - Example: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, ...
  - From this pattern, it's clear that every package of three numbers contains exactly **one** divisible by 3.
  
-&gt; Count Numbers Divisible by 3:
    To find how many numbers in the first 1234567 are divisible by 3: floor(1234567/3)
  
-&gt; Calculate Probability:
    The probability of selecting a number divisible by 3 is:
    P = Numbers Divisible by 3 / Total Numbers = 411522 / 1234567 ≈ 0.33333306
  
-&gt; Result:
    This matches the expected approximation of 1/3, derived from the pattern of divisibility.
  
- The probability `P ≈ 1/3` arises naturally from the definition of divisibility.
- The slight deviation from `1/3` comes from the truncation during integer division.
  
This method demonstrates how understanding divisibility patterns simplifies complex calculations.
</pre>
  </li>
  <li>
    <p>Find all integers x for which it can be said that the positive integer 2x + 9 divides the positive integer 3x + 4?</p>

    <pre>
From the problem statement, we can extract the following requirements:
x ∈ Z
2x + 9 ∈ Z+ =⇒ x ∈ Z≥−4
3x + 4 ∈ Z+ =⇒ x ∈ Z≥−1
3x + 4 ≥ 2x + 9 =⇒ x ∈ Z≥5
Additionally, we require
(3x + 4)/(2x + 9) = 1 + (x − 5)/(2x + 9) =⇒ (x − 5)/(2x + 9) ∈ Z≥0.
This secondary requirement means that either x = 5 or
x − 5 ≥ 2x + 9 =⇒ x ∈ Z≤−14.
The second case is clearly impossible due to the strict x ∈ Z≥5 requirement from earlier, so the only valid integer x is 5 .
</pre>
  </li>
</ul>

<hr />

<h3 id="number-theoretic-function">Number Theoretic Function</h3>

<pre>
Two important number theoretic functions in mathematics are:

- τ(n) (Tau function): Counts the number of positive divisors of n
- σ(n) (Sigma function): Calculates the sum of all positive divisors of n

other two are eulers and mobius function

n -&gt; 1e16 =&gt; sqrt(n) -&gt; 1e8 : it can pass
</pre>

<ul>
  <li><u>τ(n) (Tau function)</u></li>
</ul>

<pre>τ(12) =&gt;
- Step 1: Prime Factorization 12 = 2<sup>2</sup> × 3<sup>1</sup>
- Step 2: Use the divisor-counting formula 
If n = p<sub>1</sub><sup>a</sup> × p<sub>2</sub><sup>b</sup> × ... × p<sub>k</sub><sup>z</sup>, 
then <b>τ(n) = (a + 1)(b + 1)...(z + 1)</b> -&gt; (+1 because of 0)

So, τ(12) = (2 + 1)(1 + 1) = 3 × 2 = 6 
- Step 3: List all divisors of 12 All numbers of the form 2<sup>i</sup> × 3<sup>j</sup> where 0 ≤ i ≤ 2, 0 ≤ j ≤ 1 

→ Possible combinations: 
i = 0, j = 0 → 1 
i = 0, j = 1 → 3 
i = 1, j = 0 → 2 
i = 1, j = 1 → 6 
i = 2, j = 0 → 4 
i = 2, j = 1 → 12 
→ Divisors of 12: 1, 2, 3, 4, 6, 12 Hence, τ(12) = 6 
✔ Confirmed: The number of positive divisors of 12 is 6. 
</pre>

<pre>
-&gt; odd divisors not count for 2
-&gt; square divisors : a^x . b^y . c^z =&gt; (no.(o,2,4..x)).(no.(o,2,4..y)).(no.(o,2,4..z))
-&gt; non square
-&gt; squarefree (not divide by any square)
</pre>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//number of disisors</span>
<span class="k">using</span> <span class="n">ll</span> <span class="o">=</span> <span class="kt">long</span> <span class="kt">long</span>
<span class="kt">int</span> <span class="nf">tau</span><span class="p">(</span><span class="n">ll</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">ll</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">*</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">%</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">cnt</span><span class="o">++</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">n</span> <span class="o">/</span> <span class="n">i</span><span class="p">)</span><span class="n">cnt</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">cnt</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li><u>Sieve-Based Implementation of τ(n)</u></li>
</ul>

<pre>
1 2 3 4 5 6 7 8 9 10 ... n
|-||-||-|||-||-||||-||-||||-|||-|||| (for 1 to n go all divisor of i and add 1)
1 2 2 3 2 4 2 4 3 4
</pre>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">const</span> <span class="kt">int</span> <span class="n">nmax</span> <span class="o">=</span> <span class="mf">1e5</span> <span class="o">+</span> <span class="mi">10</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">tau</span><span class="p">[</span><span class="n">nmax</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">sigma</span><span class="p">[</span><span class="n">nmax</span><span class="p">];</span>
<span class="c1">//can go easily 1e6</span>
<span class="kt">void</span> <span class="nf">seive</span><span class="p">()</span> <span class="p">{</span> <span class="c1">//O(nlog(n)) //can't go upto 9e7 but original can go</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nmax</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span> <span class="n">m</span> <span class="o">&lt;</span> <span class="n">nmax</span><span class="p">;</span> <span class="n">m</span> <span class="o">+=</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">tau</span><span class="p">[</span><span class="n">m</span><span class="p">]</span><span class="o">++</span>
            <span class="n">sigma</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">+=</span> <span class="n">i</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="cm">/* original seive-&gt; O(nloglogn) -&gt; only find prime record ...
then apply math formula of tau and sigma...
try to use this all the time*/</span>
</code></pre></div></div>

<pre><code class="language-math">\log n \approx 1 + \frac{1}{2} + \frac{1}{3} + \cdots + \frac{1}{n}
</code></pre>

<ul>
  <li><u>Sieve-Based Implementation (Optimised)</u></li>
</ul>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
SPF sieve: O(n log log n)
Main loop: O(n) amortized
Total: O(n log log n) + O(n) = O(n log log n)*/</span>

<span class="k">const</span> <span class="kt">int</span> <span class="n">nmax</span> <span class="o">=</span> <span class="mf">1e5</span> <span class="o">+</span> <span class="mi">10</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">spf</span><span class="p">[</span><span class="n">nmax</span><span class="p">];</span> <span class="c1">// smallest prime factor</span>
<span class="kt">int</span> <span class="n">tau</span><span class="p">[</span><span class="n">nmax</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">sigma</span><span class="p">[</span><span class="n">nmax</span><span class="p">];</span>

<span class="kt">void</span> <span class="nf">optimized_sieve</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// Initialize smallest prime factors</span>
    <span class="n">iota</span><span class="p">(</span><span class="n">spf</span><span class="p">,</span> <span class="n">spf</span> <span class="o">+</span> <span class="n">nmax</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> <span class="c1">// spf[i] = i</span>

    <span class="c1">// Sieve of Eratosthenes to find smallest prime factors</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">*</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nmax</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">spf</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// i is prime</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">nmax</span><span class="p">;</span> <span class="n">j</span> <span class="o">+=</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">spf</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="n">j</span><span class="p">)</span> <span class="n">spf</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// Initialize tau and sigma for n = 1</span>
    <span class="n">tau</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">sigma</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">nmax</span><span class="p">;</span> <span class="n">n</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">spf</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">==</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// n is prime</span>
            <span class="n">tau</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
            <span class="n">sigma</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="c1">// Factorize n using spf</span>
            <span class="kt">int</span> <span class="n">p</span> <span class="o">=</span> <span class="n">spf</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
            <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
            <span class="kt">int</span> <span class="n">exponent</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="k">while</span> <span class="p">(</span><span class="n">m</span> <span class="o">%</span> <span class="n">p</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">m</span> <span class="o">/=</span> <span class="n">p</span><span class="p">;</span>
                <span class="n">exponent</span><span class="o">++</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="c1">// Using multiplicative properties:</span>
            <span class="c1">// τ(n) = τ(m) * (exponent + 1)</span>
            <span class="c1">// σ(n) = σ(m) * (p^(exponent+1) - 1)/(p - 1)</span>
            <span class="n">tau</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">tau</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">exponent</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

            <span class="kt">int</span> <span class="n">power</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">exponent</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">power</span> <span class="o">*=</span> <span class="n">p</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">sigma</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">sigma</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">power</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">p</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li><u>σ(n) (Sigma function)</u></li>
</ul>

<pre>σ(12) =&gt; 
- Step 1: Prime Factorization 
12 = 2<sup>2</sup> × 3<sup>1</sup> 

- Step 2: Formula for sum of divisors 
If n = p<sub>1</sub><sup>a</sup> × p<sub>2</sub><sup>b</sup> × ... × p<sub>k</sub><sup>z</sup>, then 
σ(n) = [(p<sub>1</sub><sup>0</sup> + p<sub>1</sub><sup>1</sup> + ... + p<sub>1</sub><sup>a</sup>) × (p<sub>2</sub><sup>0</sup> + p<sub>2</sub><sup>1</sup> + ... + p<sub>2</sub><sup>b</sup>) × ... ] 

((p<sub>1</sub><sup>a<sub>1</sub>+1</sup>-1)/(p<sub>1</sub>-1)).((p<sub>2</sub><sup>a<sub>2</sub>+1</sup>-1)/(p<sub>2</sub>-1))...

So, σ(12) = (2<sup>0</sup> + 2<sup>1</sup> + 2<sup>2</sup>) × (3<sup>0</sup> + 3<sup>1</sup>) 
= (1 + 2 + 4) × (1 + 3) = 7 × 4 = 28 

=&gt; 12 = 2<sup>2</sup> × 3<sup>1</sup> 
Apply the formula: 
σ(12) = ((2<sup>2+1</sup> - 1) / (2 - 1)) × ((3<sup>1+1</sup> - 1) / (3 - 1)) 
= ((2<sup>3</sup> - 1) / 1) × ((3<sup>2</sup> - 1) / 2) 
= (8 - 1) × (9 - 1) / 2 = 7 × 8 / 2 = 7 × 4 = 28 

- Step 3: List all divisors and sum them directly Divisors of 12: 1, 2, 3, 4, 6, 12 Sum = 1 + 2 + 3 + 4 + 6 + 12 = 28 
✔ Confirmed: σ(12) = 28 </pre>

<pre><code class="language-math">\sigma(n) =
\left( \frac{p_1^{a_1+1} - 1}{p_1 - 1} \right)
\cdot
\left( \frac{p_2^{a_2+1} - 1}{p_2 - 1} \right)
\cdot \dots \cdot
\left( \frac{p_k^{a_k+1} - 1}{p_k - 1} \right)
</code></pre>

<p>❗ So, even though the individual terms look like fractions, they always simplify to integers because they represent the sum of a geometric series of powers of integers.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//sum of all disisors</span>
<span class="k">using</span> <span class="n">ll</span> <span class="o">=</span> <span class="kt">long</span> <span class="kt">long</span>
<span class="kt">int</span> <span class="nf">sigma</span><span class="p">(</span><span class="n">ll</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">ll</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">*</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">%</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">sum</span> <span class="o">+=</span> <span class="n">i</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">n</span> <span class="o">/</span> <span class="n">i</span><span class="p">)</span> <span class="n">sum</span> <span class="o">+=</span> <span class="n">n</span><span class="o">/</span><span class="n">i</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">sum</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li><u>Sieve-Based Implementation of σ(n)</u></li>
</ul>

<pre>
1 2 3 4 5 6 7 8 9 10 ... n
(for 1 to n go all divisor of i and add i everytime)
</pre>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">const</span> <span class="kt">int</span> <span class="n">nmax</span> <span class="o">=</span> <span class="mf">1e5</span> <span class="o">+</span> <span class="mi">10</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">tau</span><span class="p">[</span><span class="n">nmax</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">sigma</span><span class="p">[</span><span class="n">nmax</span><span class="p">];</span>

<span class="kt">void</span> <span class="nf">seive</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nmax</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span> <span class="n">m</span> <span class="o">&lt;</span> <span class="n">nmax</span><span class="p">;</span> <span class="n">m</span> <span class="o">+=</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">tau</span><span class="p">[</span><span class="n">m</span><span class="p">]</span><span class="o">++</span>
            <span class="n">sigma</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">+=</span> <span class="n">i</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>example:</p>

<ul>
  <li><a href="spojABA12D_Sum_of_divisors.cpp">spojABA12D - Sum of divisors!</a></li>
</ul>

<pre>
he decided to look out for numbers whose sum of divisors is a prime number and he was the inventor of these special numbers he gave them the name K-numbers.

Given a range [A, B] you are expected to find the number of K-numbers in this range.

1 &lt;= T &lt;= 10000, 1&lt;=A&lt;=B&lt;=10^6
</pre>

<hr />

<h3 id="perfect-square">Perfect Square</h3>

<pre>
- odd number of divisors are perfect square (i==n/i we eliminate one divisors because of unique divisors.)
- otherwise all other number has even number of divisors
</pre>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">bool</span> <span class="nf">isSquare</span><span class="p">(</span><span class="n">i64</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">sqrt</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">1LL</span> <span class="o">*</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span> <span class="o">==</span> <span class="n">n</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>example:</p>

<ul>
  <li>https://codeforces.com/contest/2071/problem/B</li>
  <li>https://codeforces.com/contest/2020/problem/B</li>
  <li>https://codeforces.com/contest/2031/problem/C</li>
</ul>

<hr />
