<p>https://cp-algorithms.com/algebra/module-inverse.html<br />
https://forthright48.com/modular-multiplicative-inverse/</p>

<pre>
First we have to determine whether Modular Inverse even exists for given A and M before we jump to finding the solution.
- <b>Modular Inverse of A with respect to M, that is, X=A<sup>−1</sup>(mod M) exists, if and only if A and M are coprime.</b>

- Division and fractions(more complicated) are different in modular arithmetic than other operator. It's requires a concept called "modular multiplicative inverse". 
- The modular multiplicative inverse of a number a is the number a<sup>−1</sup> such that a⋅a<sup>−1</sup> mod m = 1.

Bruteforcing all numbers to a prime number close to a billion will usually cause you to exceed the time limit. There are two faster ways to calculate the inverse: the extended GCD algorithm, and Fermat's little theorem. Though the extended GCD algorithm is more versatile and sometimes slightly faster, the Fermat's little theorem method is more popular, 

a.a<sup>m−1</sup> mod m = 1 = a⋅a<sup>m−2</sup>  mod m, therefore the number we need is a<sup>-1</sup> = a<sup>m−2</sup>  mod m (m!=0)

This also extends the  mod  operator to rational numbers (i.e. fractions), as long as the denominator is coprime to m. (Thus the reason for choosing a fairly large prime; that way puzzle writers can avoid denominators with m as a factor).

If a and m aren't coprime, there is no multiplicative inverse of a modulo m, i.e., there is no integer x where a⋅x  mod m=1. This is because all a⋅x  mod m is divisible by gcd(a,m)≠1.

- Z/pZ is just a fancy term meaning the set of integers from 0 to p−1 treated as residues modulo p.
</pre>

<pre>
# Something to know

- divisions through modular multiplicative inverse would be slower than the other operations (O(logm) instead of O(1)), so you may want to cache/memoize the inverses you use frequently in your program.
- comparisons are generally meaningless.
- exponentiation (when evaluating x<sup>n</sup> mod m, you can't store n as n mod m. If n turns out to be really huge, you need to calculate it modulo φ(m) instead, where φ stands for Euler's totient function. If m is prime, φ(m) = m−1. 

Do be careful about the special case 0<sup>0</sup>, which should typically be defined as 1, while 0<sup>φ(m)</sup> would still be 0.

- A modular multiplicative inverse a<sup>−1</sup> mod m is always unique within the range 0≤a<sup>−1</sup> mod m &lt;=m if it exists (and it exists as long as gcd(a,m)=1, a and m are coprime)
</pre>

<p>Properties:</p>

<h6 id="1-existence">1. <strong>Existence</strong></h6>

<ul>
  <li>Not all numbers have a modular multiplicative inverse.</li>
  <li>The modular inverse of <code class="language-plaintext highlighter-rouge">a mod m</code> exists <strong>if and only if</strong> <code class="language-plaintext highlighter-rouge">a</code> and <code class="language-plaintext highlighter-rouge">m</code> are <strong>coprime</strong>, i.e., <code class="language-plaintext highlighter-rouge">gcd(a, m) = 1</code>.</li>
  <li>If <code class="language-plaintext highlighter-rouge">gcd(a, m) ≠ 1</code>, <code class="language-plaintext highlighter-rouge">a</code> has no inverse modulo <code class="language-plaintext highlighter-rouge">m</code>.</li>
</ul>

<h6 id="2-uniqueness">2. <strong>Uniqueness</strong></h6>

<ul>
  <li>If <code class="language-plaintext highlighter-rouge">a</code> has an inverse modulo <code class="language-plaintext highlighter-rouge">m</code>, it is <strong>unique modulo <code class="language-plaintext highlighter-rouge">m</code></strong>.</li>
  <li>There is only one <code class="language-plaintext highlighter-rouge">x</code> in the range <code class="language-plaintext highlighter-rouge">0 ≤ x &lt; m</code>
such that: a * x ≡ 1 (mod m)</li>
  <li>if a has a modular multiplicative inverse modulo m, then all a*i mod m are distinct for i [1,m]</li>
</ul>

<h6 id="3-multiplicative-property">3. <strong>Multiplicative Property</strong></h6>

<ul>
  <li>If <code class="language-plaintext highlighter-rouge">a</code> and <code class="language-plaintext highlighter-rouge">b</code> both have inverses modulo <code class="language-plaintext highlighter-rouge">m</code>,
then: (a * b)<sup>-1</sup> ≡ a<sup>-1</sup> * b<sup>-1</sup> (mod m)</li>
</ul>

<h6 id="4-inverse-of-1">4. <strong>Inverse of 1</strong></h6>

<ul>
  <li>The modular inverse of <code class="language-plaintext highlighter-rouge">1</code> is always <code class="language-plaintext highlighter-rouge">1</code>:
1 * 1 ≡ 1 (mod m)</li>
</ul>

<h6 id="5-inverse-of--a">5. <strong>Inverse of -a</strong></h6>

<ul>
  <li>The modular inverse of <code class="language-plaintext highlighter-rouge">-a</code> is <code class="language-plaintext highlighter-rouge">-a&lt;sup&gt;-1&lt;/sup&gt;</code> modulo <code class="language-plaintext highlighter-rouge">m</code>:
(-a) * (-a<sup>-1</sup>) ≡ 1 (mod m)</li>
</ul>

<h6 id="6-relation-with-modular-exponentiation">6. <strong>Relation with Modular Exponentiation</strong></h6>

<ul>
  <li>For prime <code class="language-plaintext highlighter-rouge">m</code>, the modular inverse of <code class="language-plaintext highlighter-rouge">a</code> can be computed using <strong>Fermat’s Little Theorem</strong>:
a<sup>-1</sup> ≡ a<sup>(m-2)</sup> (mod m)</li>
</ul>

<hr />

<ul>
  <li><u>**_Naive Method (modular inverse)_**</u></li>
</ul>

<pre> - A number a has a modular multiplicative inverse modulo m if there exists a number b such that <b>a*b ≡ 1 (mod m)</b>...(b is a modular inverse of a) -&gt; xx<sup>−1</sup> mod m = 1.
- If a has a modular multiplicative inverse modulo m, then we can write a<sup>-1</sup> for the modular multiplicative inverse of a modulo m.

<b>a modular inverse does not always exist, x<sup>−1</sup> mod m can be calculated
exactly when x and m are coprime.</b>
</pre>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//naive O(mod)</span>
<span class="kt">int</span> <span class="nf">inverse</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">m</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="mi">1LL</span> <span class="o">*</span> <span class="n">a</span> <span class="o">*</span> <span class="n">i</span> <span class="o">%</span> <span class="n">m</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">i</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span><span class="c1">//inverse doesn't exist</span>
<span class="p">}</span>
</code></pre></div></div>

<hr />

<p><u>**_M is Prime_** -&gt; 1e9+7 or 998244353</u><br /></p>

<ul>
  <li><u>**_Fermat’s Little Theorem (fast exponentiation)_**</u></li>
</ul>

<pre>
Fermat’s Little Theorem says-&gt; if gcd(a,m)=1 then a<sup>p−1</sup>≡1 (mod p)

If a modular inverse exists, it can be calculated using the formula 
x<sup>−1</sup> = x<sup>ϕ(m)−1</sup>. If m is prime, the formula becomes x<sup>−1</sup> = x<sup>m−2</sup>.

Optimize Approach
  -&gt; a<sup>p-1</sup> ≡ 1 (mod p). (from little fermat's theorem)
  -&gt; a.y ≡ 1 (mod p)
  -&gt; a.a<sup>p-2</sup> = a<sup>p-1</sup> ≡ 1 (mod p)
  -&gt; a<sup>-1</sup> = a<sup>p-2</sup> (mod p)

- Except for 0<sup>-1</sup> -&gt;valid range: (0 &lt; a &lt; mod) -&gt; mod must be prime
</pre>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//faster O(logm)</span>
<span class="kt">int</span> <span class="nf">power</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mod</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">%</span> <span class="n">mod</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">ans</span> <span class="o">=</span> <span class="mi">1LL</span> <span class="o">*</span> <span class="n">ans</span> <span class="o">*</span> <span class="n">x</span> <span class="o">%</span> <span class="n">mod</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">x</span> <span class="o">=</span> <span class="mi">1LL</span> <span class="o">*</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span> <span class="o">%</span> <span class="n">mod</span><span class="p">;</span>
        <span class="n">n</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// mod must be prime</span>
<span class="kt">int</span> <span class="nf">inverse</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mod</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">%</span> <span class="n">mod</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Inverse doesn't exist (a is divisible by m)."</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nf">power</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">mod</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="n">mod</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<hr />

<p><u>**_M is not Prime_**</u> (in general)</p>

<p>inverse(a)%mod only have, as long long as gcd(a,mod)=1(co-prime)</p>

<ul>
  <li><u>Using Euler’s Theorem</u> (general method)</li>
</ul>

<pre>
It is possible to use Euler’s Theorem to find the modular inverse. We know that:

      A<sup>ϕ(M)</sup> ≡ 1(mod M)
      A<sup>ϕ(M)−1</sup> ≡ A<sup>−1</sup>(mod M)

This process works for <b>any M as long as it’s coprime to A</b>, but it is rarely used since we have to calculate Euler Phi value of M which requires more processing.

Euler's theorem provides a general method to compute modular inverses, but for prime modulus, Fermat's Little Theorem (or the Extended Euclidean Algorithm) is usually faster.
</pre>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// complexity -&gt; O(sqrt(mod))</span>

<span class="c1">// Function to compute gcd (needed to check if inverse exists)</span>
<span class="kt">int</span> <span class="nf">gcd</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">b</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">a</span> <span class="o">:</span> <span class="n">gcd</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">%</span> <span class="n">b</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Function to compute Euler's totient function φ(m)</span>
<span class="kt">int</span> <span class="nf">euler_phi</span><span class="p">(</span><span class="kt">int</span> <span class="n">m</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">m</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">p</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">p</span> <span class="o">*</span> <span class="n">p</span> <span class="o">&lt;=</span> <span class="n">m</span><span class="p">;</span> <span class="n">p</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">m</span> <span class="o">%</span> <span class="n">p</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">while</span> <span class="p">(</span><span class="n">m</span> <span class="o">%</span> <span class="n">p</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="n">m</span> <span class="o">/=</span> <span class="n">p</span><span class="p">;</span>
            <span class="n">result</span> <span class="o">-=</span> <span class="n">result</span> <span class="o">/</span> <span class="n">p</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">m</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="n">result</span> <span class="o">-=</span> <span class="n">result</span> <span class="o">/</span> <span class="n">m</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Function to compute a^b mod m using fast exponentiation</span>
<span class="kt">int</span> <span class="nf">power</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mod</span><span class="p">)</span> <span class="p">{</span> <span class="c1">//O(logn)</span>
    <span class="kt">int</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">ans</span> <span class="o">=</span> <span class="mi">1LL</span> <span class="o">*</span> <span class="n">ans</span> <span class="o">*</span> <span class="n">x</span> <span class="o">%</span> <span class="n">mod</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">x</span> <span class="o">=</span> <span class="mi">1LL</span> <span class="o">*</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span> <span class="o">%</span> <span class="n">mod</span><span class="p">;</span>
        <span class="n">n</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Function to compute modular inverse using Euler's theorem</span>
<span class="kt">long</span> <span class="kt">long</span> <span class="nf">inverse_using_euler</span><span class="p">(</span><span class="kt">long</span> <span class="kt">long</span> <span class="n">a</span><span class="p">,</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">m</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">gcd</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Inverse doesn't exist (a and m are not coprime)."</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">long</span> <span class="kt">long</span> <span class="n">phi_m</span> <span class="o">=</span> <span class="n">euler_phi</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>
    <span class="k">return</span> <span class="nf">power</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">phi_m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">m</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="n">m</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
    <span class="kt">long</span> <span class="kt">long</span> <span class="n">inv</span> <span class="o">=</span> <span class="n">inverse_using_euler</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">m</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">inv</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"The modular inverse of "</span> <span class="o">&lt;&lt;</span> <span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="s">" mod "</span> <span class="o">&lt;&lt;</span> <span class="n">m</span> <span class="o">&lt;&lt;</span> <span class="s">" is "</span> <span class="o">&lt;&lt;</span> <span class="n">inv</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<hr />

<ul>
  <li><u>**_Using Bezout's Lemma (Extended Euclidean Algorithm)_**</u> (most efficient)</li>
</ul>
<pre>
Bézout's Lemma states that for any integers a and b and gcd(a,b) = g, there exist integers x and y such that: ax + by = g

We are trying to solve the congruence, AX ≡ 1(mod M). We can convert this to an equation.
AX ≡ 1(mod M)
AX + MY = 1 (mod M) =&gt; AX + (M%M)Y = AX + (0)Y = 1 (mod M)
Here, both X and Y are unknown. This is a linear equation and we want to find integer solution for it. Which means, this is a Linear Diophantine Equation.

</pre>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Returns gcd(a, b) and sets x and y such that a*x + b*y = gcd(a, b)</span>
<span class="c1">// int extended_gcd(int a, int b, int &amp;x, int &amp;y) {</span>
<span class="c1">//     if (b == 0) {</span>
<span class="c1">//         x = 1;</span>
<span class="c1">//         y = 0;</span>
<span class="c1">//         return a;</span>
<span class="c1">//     }</span>
<span class="c1">//     int x1, y1;</span>
<span class="c1">//     int gcd = extended_gcd(b, a % b, x1, y1);</span>
<span class="c1">//     x = y1;</span>
<span class="c1">//     y = x1 - (a / b) * y1;</span>
<span class="c1">//     return gcd;</span>
<span class="c1">// }</span>

<span class="kt">int</span> <span class="nf">ext_gcd</span><span class="p">(</span><span class="kt">int</span> <span class="n">A</span><span class="p">,</span> <span class="kt">int</span> <span class="n">B</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">X</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">Y</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">x2</span><span class="p">,</span> <span class="n">y2</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">r2</span><span class="p">,</span> <span class="n">r1</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">r</span><span class="p">;</span>
    <span class="n">x2</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">y2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">x1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">y1</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">r2</span> <span class="o">=</span> <span class="n">A</span><span class="p">,</span> <span class="n">r1</span> <span class="o">=</span> <span class="n">B</span><span class="p">;</span> <span class="n">r1</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">r2</span> <span class="o">=</span> <span class="n">r1</span><span class="p">,</span> <span class="n">r1</span> <span class="o">=</span> <span class="n">r</span><span class="p">,</span> <span class="n">x2</span> <span class="o">=</span> <span class="n">x1</span><span class="p">,</span> <span class="n">y2</span> <span class="o">=</span> <span class="n">y1</span><span class="p">,</span> <span class="n">x1</span> <span class="o">=</span> <span class="n">x</span><span class="p">,</span> <span class="n">y1</span> <span class="o">=</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">q</span> <span class="o">=</span> <span class="n">r2</span> <span class="o">/</span> <span class="n">r1</span><span class="p">;</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">r2</span> <span class="o">%</span> <span class="n">r1</span><span class="p">;</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x2</span> <span class="o">-</span> <span class="p">(</span><span class="n">q</span> <span class="o">*</span> <span class="n">x1</span><span class="p">);</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">y2</span> <span class="o">-</span> <span class="p">(</span><span class="n">q</span> <span class="o">*</span> <span class="n">y1</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="o">*</span><span class="n">X</span> <span class="o">=</span> <span class="n">x2</span><span class="p">;</span>
    <span class="o">*</span><span class="n">Y</span> <span class="o">=</span> <span class="n">y2</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">r2</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">modInv</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">m</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span>
    <span class="n">ext_gcd</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">y</span><span class="p">);</span>

    <span class="c1">// Process x so that it is between 0 and m-1</span>
    <span class="c1">//x can be large, can be (-ve)</span>
    <span class="n">x</span> <span class="o">%=</span> <span class="n">m</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="n">x</span> <span class="o">+=</span> <span class="n">m</span><span class="p">;</span>
    <span class="c1">//a*x % m = 1 confirmed</span>
    <span class="k">return</span> <span class="n">x</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<hr />

<ul>
  <li><u>**_Dynamic Programming Approach_**</u> (when need many inverses)</li>
</ul>

<h3 id="efficient-computation-of-modular-inverses">Efficient Computation of Modular Inverses</h3>

<p>This is an efficient method to compute modular inverses for integers from <strong>1 to N-1</strong> using an <strong>iterative approach</strong> based on the <strong>Extended Euclidean Algorithm</strong>.</p>

<h4 id="modular-inverse-basics">Modular Inverse Basics</h4>

<p>The modular inverse of an integer <code class="language-plaintext highlighter-rouge">a</code> modulo <code class="language-plaintext highlighter-rouge">m</code> is an integer <code class="language-plaintext highlighter-rouge">x</code> such that:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>a * x ≡ 1 (mod m)
</code></pre></div></div>

<p>For a prime modulus <code class="language-plaintext highlighter-rouge">mod</code>, every integer <code class="language-plaintext highlighter-rouge">a</code> not divisible by <code class="language-plaintext highlighter-rouge">mod</code> has a unique inverse.</p>

<h4 id="fermats-little-theorem">Fermat’s Little Theorem</h4>

<p>For a prime <code class="language-plaintext highlighter-rouge">mod</code> and <code class="language-plaintext highlighter-rouge">a</code> not divisible by <code class="language-plaintext highlighter-rouge">mod</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>a^(mod-1) ≡ 1 (mod mod)
=&gt; a * a^(mod-2) ≡ 1 (mod mod)
</code></pre></div></div>

<p>Thus, <code class="language-plaintext highlighter-rouge">a^(mod-2)</code> is the inverse of <code class="language-plaintext highlighter-rouge">a</code>. However, computing this for each number up to N using exponentiation would be O(N log mod), which is less efficient than the dynamic programming approach shown.</p>

<h4 id="dynamic-programming-approach">Dynamic Programming Approach</h4>

<p>The given code uses a recurrence relation based on the following mathematical insight:</p>

<p>For a prime <code class="language-plaintext highlighter-rouge">mod</code> and <code class="language-plaintext highlighter-rouge">i &lt; mod</code>, we can express the inverse of <code class="language-plaintext highlighter-rouge">i</code> as:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>inv[i] ≡ - (mod / i) * inv[mod % i] (mod mod)
</code></pre></div></div>

<p>Here’s why this works:</p>

<ol>
  <li>Let <code class="language-plaintext highlighter-rouge">mod = q*i + r</code>, where <code class="language-plaintext highlighter-rouge">q = mod // i</code> and <code class="language-plaintext highlighter-rouge">r = mod % i</code> (so <code class="language-plaintext highlighter-rouge">0 &lt; r &lt; i</code>).</li>
  <li>Then, modulo <code class="language-plaintext highlighter-rouge">mod</code>:
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>q*i + r ≡ 0 (mod mod)
=&gt; r ≡ -q*i (mod mod)
</code></pre></div>    </div>
  </li>
  <li>Multiply both sides by <code class="language-plaintext highlighter-rouge">inv[i] * inv[r]</code>:
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>r * inv[i] * inv[r] ≡ -q * i * inv[i] * inv[r] (mod mod)
</code></pre></div>    </div>
  </li>
  <li>Since <code class="language-plaintext highlighter-rouge">i * inv[i] ≡ 1 (mod mod)</code> and <code class="language-plaintext highlighter-rouge">r * inv[r] ≡ 1 (mod mod)</code>, this simplifies to:
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>inv[i] ≡ -q * inv[r] (mod mod)
</code></pre></div>    </div>
  </li>
  <li>Substituting back <code class="language-plaintext highlighter-rouge">q = mod // i</code> and <code class="language-plaintext highlighter-rouge">r = mod % i</code>:
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>inv[i] ≡ (mod - (mod // i)) * inv[mod % i] % mod
</code></pre></div>    </div>
  </li>
</ol>

<h4 id="code-explanation">Code Explanation</h4>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">inv</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>  <span class="c1">// Base case: 1*1 ≡ 1 mod any number</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">inv</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1LL</span> <span class="o">*</span> <span class="p">(</span><span class="n">mod</span> <span class="o">-</span> <span class="n">mod</span> <span class="o">/</span> <span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="n">inv</span><span class="p">[</span><span class="n">mod</span> <span class="o">%</span> <span class="n">i</span><span class="p">]</span> <span class="o">%</span> <span class="n">mod</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">inv[1] = 1</code>: The inverse of 1 is always 1.</li>
  <li>For each <code class="language-plaintext highlighter-rouge">i &gt; 1</code>, the inverse is computed as <code class="language-plaintext highlighter-rouge">(mod - mod/i) * inv[mod % i] % mod</code>.
    <ul>
      <li><code class="language-plaintext highlighter-rouge">mod - mod/i</code> is equivalent to <code class="language-plaintext highlighter-rouge">-mod/i</code> modulo <code class="language-plaintext highlighter-rouge">mod</code> (but ensures positivity).</li>
      <li><code class="language-plaintext highlighter-rouge">inv[mod % i]</code> is already computed because <code class="language-plaintext highlighter-rouge">mod % i &lt; i</code>.</li>
    </ul>
  </li>
</ul>

<h4 id="complexity-analysis">Complexity Analysis</h4>

<ul>
  <li><strong>Iterative approach:</strong> O(N) time complexity.</li>
  <li><strong>Fermat’s theorem (for prime mod):</strong> O(N log N) if computed separately.</li>
  <li><strong>Advantage:</strong> This method is significantly faster for large <strong>N</strong>.</li>
</ul>

<h4 id="example-computation-mod--7">Example Computation (mod = 7)</h4>

<p>For N = 7, the computed modular inverses are:</p>

<table>
  <thead>
    <tr>
      <th>i</th>
      <th>inv[i]</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td>1</td>
    </tr>
    <tr>
      <td>2</td>
      <td>4</td>
    </tr>
    <tr>
      <td>3</td>
      <td>5</td>
    </tr>
    <tr>
      <td>4</td>
      <td>2</td>
    </tr>
    <tr>
      <td>5</td>
      <td>3</td>
    </tr>
    <tr>
      <td>6</td>
      <td>6</td>
    </tr>
  </tbody>
</table>

<p>Each satisfies the modular inverse property:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1 * 1 ≡ 1,  2 * 4 ≡ 1,  3 * 5 ≡ 1,
4 * 2 ≡ 1,  5 * 3 ≡ 1,  6 * 6 ≡ 1 (mod 7)
</code></pre></div></div>

<p>This method is possible because:</p>

<ol>
  <li>The recurrence relation correctly expresses the inverse of <code class="language-plaintext highlighter-rouge">i</code> in terms of the inverse of <code class="language-plaintext highlighter-rouge">mod % i</code>.</li>
  <li>The dynamic programming approach ensures we compute inverses in the correct order (smallest to largest).</li>
  <li>The prime modulus guarantees the existence of inverses for all <code class="language-plaintext highlighter-rouge">i &lt; mod</code>.</li>
</ol>

<p>This is one of the most efficient ways to precompute modular inverses for a range of numbers when the modulus is prime. This approach is widely used in <strong>competitive programming</strong> and <strong>number theory problems</strong> to efficiently precompute modular inverses for multiple values.</p>

<hr />

<pre>
Best Choice?

- If is prime → Fermat’s Little Theorem (fast exponentiation).
- If is not prime → Extended Euclidean Algorithm (Bézout’s Lemma) (most efficient).
- If you need many inverses → Dynamic Programming approach.

Fermat’s Little Theorem is fine but not better than Bézout.
</pre>

<hr />

<p>example:</p>

<ul>
  <li><a href="https://www.hackerearth.com/problem/algorithm/modulo-inverse-problem/">hackerearth_modular inverse</a>
    <pre>
You have been a number A. You need to output the inverse of number A modulo 1e9+7
</pre>
  </li>
  <li><a href="./4_modular_arithmetic/3_fermats_little_theorem_and_modular_inverse/eolymp9606_modular_division.cpp">eolymp9606_modular division</a>
    <pre>
Three positive integers a,b, and n are given. Compute the value of a / b mod n. In other words, find a value x such that b⋅x = a mod n.
  
n&lt;=2e9, 1 &lt; a,b &lt; n
-&gt; (a*inverse(b))%n
</pre>
  </li>
</ul>

<hr />
