<p>example:</p>

<ul>
  <li><a href="">1860A_Not a Substring</a></li>
</ul>

<hr />

<h3 id="some-technique">Some Technique</h3>

<p>#</p>

<ul>
  <li>
    <p>Sort the Distance from Origin</p>
  </li>
  <li>Sort 5D Points</li>
  <li>String Sort</li>
  <li>Balanced Bracket</li>
  <li>Sliding Window Technique</li>
  <li>Kth Smallest in Each Prefix</li>
  <li>Unique Elements</li>
  <li>Remove B from A</li>
  <li>Word Frequency</li>
  <li>Occurrences</li>
  <li>Update and Remove Query</li>
  <li>Number of Pair of Strings such that d(a,b)&lt;=k in Binary String</li>
</ul>

<p>#</p>

<h5 id="basic-contribution-technique">Basic Contribution Technique</h5>

<p>https://medium.com/spidernitt/contribution-technique-i-c1730f195b41</p>

<pre>
The basic idea behind this technique is to identify the entities (basic elements) that constitute the final answer. We need an answer to this question: “What is my final answer made up of?” Then, we would iterate on each entity and find its own contribution to the final answer.

FOR(1,N) ans += indivisual contribution of a[i] 
</pre>

<ul>
  <li>
    <p>Sum of Pair Sums (All Pair)</p>

    <pre>
Given an array a of size n, find sum(a[i]+a[j]) from (i,j)-&gt;1 to n 
  
Here, each element add 2*n times (n+n)
FOR(1,n)-&gt; ans += 2*n*a[i]
</pre>
  </li>
  <li>
    <p>Sum of Subarray Sums</p>

    <pre>
Given an array a of size n, find sum(i:1-&gt;n,j:1-&gt;n (a[i]+a[i+1]+...+a[j]))
(find all subarray sum of sum)
  
FOR(1,n)-&gt; ans += a[i]*i*(n-i+1);
</pre>
  </li>
  <li>
    <p>Sum of Subset Sums</p>

    <pre>
Given an array a of size n, find the sum of all subset sums of a (ans modulo 1e9+7)
  
FOR(1,n)-&gt; ans += a[i]*2<sup>n-1</sup>;
</pre>
  </li>
  <li>
    <p>Product of Pair Products</p>

    <pre>
Product of every pair and product of all this product, (ans modulo 1e9+7)
  
FOR(1,n)-&gt; ans *= a[i]<sup>2n</sup> 
</pre>
  </li>
  <li>
    <p>XOR of Subarray XORs</p>

    <pre>
- a[i] contribute to my ans if (i*(n-i+1))&amp;1
</pre>
  </li>
  <li>
    <p>Sum of (max-min) over all Subsets</p>

    <pre>
- sum of (max(subset) - min(subset)) from 1 to n
  
- sort the array, then
a(min) ..upto k in between.. b(max) -&gt; 2<sup>j-i+1</sup>; in between element, k = j-i+1
</pre>

    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">sort</span><span class="p">(</span><span class="n">a</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">a</span><span class="o">+</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span><span class="c1">//O(N*N)</span>
  <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">){</span>
    <span class="n">ans</span> <span class="o">+=</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">-</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">j</span><span class="o">-</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">));</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="c1">//can be done within O(N)</span>
<span class="c1">//by separating min max</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>Sum of Sum Length over all Subarrays</p>

    <pre>
Given an array a of size n, find the sum (the sum of the subarray multiplied by the length of the subarray) over all subarrays of a.
  
a[i]*len -&gt; a[i]*(k1+k2+...+kn)//whose subarray that contain a[i], sum of their length
-&gt; (sum(left(1-&gt;i)), sum(right(i-&gt;N))) (right - left + 1)
-&gt; sum(l-&gt;1,i)-&gt; S(i,n)-l(n-i+1)+(n-i+1)
-&gt; S(i,n)*i - (n-i+1)*S(1,i) + (n-i+1)*i
</pre>

    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//bruteforce O(N*N)</span>
<span class="kt">int</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
  <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="n">i</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">){</span>
    <span class="n">sum</span><span class="o">+=</span><span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
    <span class="n">ans</span><span class="o">+=</span><span class="n">sum</span><span class="o">*</span><span class="p">(</span><span class="n">j</span><span class="o">-</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span><span class="c1">//subarray sum*length</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="c1">//o(N) approach</span>
<span class="kt">int</span> <span class="nf">F</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">){</span>
  <span class="k">return</span> <span class="n">n</span><span class="o">*</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">S</span><span class="p">(</span><span class="kt">int</span> <span class="n">l</span><span class="p">,</span><span class="kt">int</span> <span class="n">r</span><span class="p">){</span>
  <span class="k">return</span> <span class="n">F</span><span class="p">(</span><span class="n">r</span><span class="p">)</span><span class="o">-</span><span class="n">F</span><span class="p">(</span><span class="n">l</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span><span class="c1">//l to r sum</span>
<span class="p">}</span>
<span class="p">...</span>
<span class="kt">int</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
  <span class="kt">int</span> <span class="n">contribution</span> <span class="o">=</span> <span class="n">S</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">n</span><span class="p">)</span><span class="o">*</span><span class="n">i</span><span class="o">-</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">S</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">i</span><span class="p">)</span><span class="o">+</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">i</span><span class="p">;</span>
  <span class="n">ans</span> <span class="o">+=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">contribution</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>Sum of Number of Vowels in Substrings</p>

    <pre>
Given a string s of size n, find the sum of number of vowels in all substrings of s.
</pre>

    <p><a href="">leetcode2063_Vowels of All Substrings</a></p>

    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">long</span> <span class="kt">long</span> <span class="nf">countVowels</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="n">vowels</span> <span class="o">=</span> <span class="p">{</span><span class="sc">'a'</span><span class="p">,</span> <span class="sc">'e'</span><span class="p">,</span> <span class="sc">'i'</span><span class="p">,</span> <span class="sc">'o'</span><span class="p">,</span> <span class="sc">'u'</span><span class="p">,</span> <span class="sc">'A'</span><span class="p">,</span> <span class="sc">'E'</span><span class="p">,</span> <span class="sc">'I'</span><span class="p">,</span> <span class="sc">'O'</span><span class="p">,</span> <span class="sc">'U'</span><span class="p">};</span>
  <span class="kt">long</span> <span class="kt">long</span> <span class="n">total_sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">vowels</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span> <span class="p">{</span>
      <span class="n">total_sum</span> <span class="o">+=</span> <span class="p">(</span><span class="kt">long</span> <span class="kt">long</span><span class="p">)(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">i</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">total_sum</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>Sum of Number of Inversions in Permutations</p>

    <pre>
Given an int n, find the sum of the number of inversions in all permutations (1,2...n)
  
number of inversion -&gt; how much such that (i &lt; j and a[i] &gt; a[j])
  
around half permutation i is behind j and vice-versa (where a[i]&gt;a[j])
n!/2 and there are n*(n-1)/2 total pair
</pre>
  </li>
  <li>
    <p>Sum of Number of Inversions in Subarrray</p>
  </li>
</ul>

<hr />
