<h3 id="basics">Basics</h3>

<ul>
  <li>
    <p>pointers</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  - memory address of variable x -&gt; &amp;x

  - pointer variable-&gt; int* ptr(used to store memory address) like, ptr = &amp;n;
  (dereference operator *) used to access a value that stored at the memory location pointed by a pointer.
  - *ptr -&gt; value(value of stored address)
  - update that value -&gt; *ptr = num
  - null pointers -&gt; int *ptr = nullptr..or..NULL -&gt;ptr = 0

  - ith element in array -&gt; x+4*(i-1) ...(x initial address),
  accessing any element in O(1)-&gt; ptr+(i-1)
                                  a+(i-1) //in array
  - *ptr = *ptr+2 //value of ptr+2 replace in that original ptr value
</code></pre></div>    </div>
  </li>
  <li>
    <p>references (call by value &amp; call by reference)</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  - int x=5; int y = x; (x and y have differenct address)
  - int x=5; int &amp;y = x; (x and y have same address and value)
  (int &amp;y; y = x;-&gt;wrong approach)
  y+=5 -&gt; x=10
  - call by reference is most faster than call by value
  - in cpp array is pass by reference by default (array always work in pointer), we can't pass array by value.
  - container copy time O(n)
</code></pre></div>    </div>
  </li>
  <li>
    <p>iterators</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  - iterators are used to access and traverse the elements of a container (act like a pointer)
  - vector&lt;int&gt;::iterator it = v.begin();// auto it = v.begin();//(it - container specific)
  - *it (output value shown)
  - it++;(it = next(it)) it--;(it = prev(it)) it+=x;(it = next(it,x)) it-=x;(it = prev(it,x))
  - begin()-&gt; pointing to first element, end()-&gt; pointing to last+1 element
  - it = v.end(); it--; (*it)-&gt;last element

  - r.begin()-&gt;last element , r.end()-&gt;first - 1
  - vector&lt;int&gt;::reverse_iterator it = v.rbegin();
  - normal - , reverse +

  - v.end()-v.begin() -&gt; n//index
  - range = distance(v.begin()+2,v.begin()+5);//(2,3,5)//end-of-range iterator q points one behind
  - after changing in container - previous all declare iterator is invalid//we have to declare new

  - random iterator(vector, deque, array, string)//it+=x; it-=x;
  - bidirectional iterator(list, set, map)//it+=1; it-=1;
  - forward iterator(forward_list, unordered_set, unordered_map)//it+=1

  - accesing vector of pair-&gt; (*it).first
</code></pre></div>    </div>
  </li>
  <li>
    <p>struct vs class</p>
  </li>
</ul>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="c1">// Using struct</span>
<span class="k">struct</span> <span class="nc">Point</span> <span class="p">{</span>
    <span class="kt">double</span> <span class="n">x</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">y</span><span class="p">;</span>

    <span class="kt">void</span> <span class="n">display</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Point("</span> <span class="o">&lt;&lt;</span> <span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="s">", "</span> <span class="o">&lt;&lt;</span> <span class="n">y</span> <span class="o">&lt;&lt;</span> <span class="s">")</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="c1">// Using class</span>
<span class="k">class</span> <span class="nc">Circle</span> <span class="p">{</span>
<span class="nl">private:</span>
    <span class="kt">double</span> <span class="n">radius</span><span class="p">;</span>
    <span class="n">Point</span> <span class="n">center</span><span class="p">;</span>

<span class="nl">public:</span>
    <span class="n">Circle</span><span class="p">(</span><span class="kt">double</span> <span class="n">r</span><span class="p">,</span> <span class="kt">double</span> <span class="n">cx</span><span class="p">,</span> <span class="kt">double</span> <span class="n">cy</span><span class="p">)</span> <span class="o">:</span> <span class="n">radius</span><span class="p">(</span><span class="n">r</span><span class="p">),</span> <span class="n">center</span><span class="p">{</span><span class="n">cx</span><span class="p">,</span> <span class="n">cy</span><span class="p">}</span> <span class="p">{}</span>

    <span class="kt">void</span> <span class="n">display</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Circle with radius "</span> <span class="o">&lt;&lt;</span> <span class="n">radius</span> <span class="o">&lt;&lt;</span> <span class="s">" at "</span><span class="p">;</span>
        <span class="n">center</span><span class="p">.</span><span class="n">display</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">Point</span> <span class="n">p1</span><span class="p">{</span><span class="mf">3.5</span><span class="p">,</span> <span class="mf">4.5</span><span class="p">};</span>
    <span class="n">p1</span><span class="p">.</span><span class="n">display</span><span class="p">();</span> <span class="c1">// Access is public by default in struct</span>

    <span class="n">Circle</span> <span class="nf">c1</span><span class="p">(</span><span class="mf">5.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">);</span>
    <span class="n">c1</span><span class="p">.</span><span class="n">display</span><span class="p">();</span> <span class="c1">// Access is controlled by public methods in class</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</code></pre></div></div>

<ul>
  <li>operator overloading</li>
</ul>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="o">&gt;</span> <span class="k">operator</span> <span class="o">+</span> <span class="p">(</span><span class="k">const</span> <span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="o">&gt;</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="o">&gt;</span><span class="n">b</span><span class="p">){</span>
        <span class="k">return</span> <span class="n">make_pair</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">first</span><span class="o">+</span><span class="n">b</span><span class="p">.</span><span class="n">first</span><span class="p">,</span><span class="n">a</span><span class="p">.</span><span class="n">second</span><span class="o">+</span><span class="n">b</span><span class="p">.</span><span class="n">second</span><span class="p">);</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
        <span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="p">{</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">};</span>
        <span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="p">{</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">};</span>
        <span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">c</span> <span class="o">=</span> <span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">;</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>
    <p>others</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  - boolalpha
          cout&lt;&lt;boolalpha&lt;&lt;a&lt;&lt;" "&lt;&lt;b&lt;&lt;endl;(a,b condidion)

  - sizeof
          cout&lt;&lt;sizeof(int)&lt;&lt;endl;(4 bytes)//special type size_t(64bit uint)
          n = sizeof(a)/sizeof(a[0]);//sizeof(a)/size_of(int)

  - size()-1
          //infinite loop(not actually)//segmentation fault
          size_t n = v.size();//every container size has type size_t
          // if don't exist any size()
          unsigned int -&gt; 0-1 -&gt; 2^64-1 (circular)(-1 don't exist in unsigned int range)
          solution -&gt; (int)v.size()-1; (convert to int)
</code></pre></div>    </div>
  </li>
</ul>

<hr />

<h3 id="autopairtuple">Auto/Pair/Tuple</h3>

<ul>
  <li>auto is used for type interface, must be initialize with value.</li>
</ul>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="kt">double</span><span class="o">&gt;</span><span class="n">p</span><span class="p">;</span>
    <span class="n">tie</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">make_pair</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">a</span><span class="o">/</span><span class="mi">5</span><span class="p">);</span><span class="c1">//{a.a/5}</span>
    <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">p</span><span class="p">.</span><span class="n">first</span><span class="o">&lt;&lt;</span><span class="s">" "</span><span class="n">p</span><span class="p">.</span><span class="n">second</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>

    <span class="n">tuple</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span><span class="n">t</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">};</span><span class="c1">//tuple can have more than 2 elements</span>
    <span class="k">auto</span> <span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span><span class="c1">//c++17* //structured binding</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span> <span class="o">&lt;&lt;</span> <span class="n">b</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span> <span class="o">&lt;&lt;</span> <span class="n">c</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">make_tuple</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">);</span>
    <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="n">t</span><span class="o">&lt;&lt;</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="n">t</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="n">t</span><span class="p">)</span><span class="c1">// last to first</span>
    <span class="kt">int</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">;</span>
    <span class="n">tie</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">)</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span><span class="c1">// if already declare x,y,z</span>

    <span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="o">&gt;</span><span class="n">points</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span><span class="c1">//array of points</span>
    <span class="n">pair</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span><span class="n">p</span><span class="p">;</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">make_pair</span><span class="p">(</span><span class="n">make_pair</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="mi">3</span><span class="p">);</span>
    <span class="c1">//p = {4, 5}, 6};</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">p</span><span class="p">.</span><span class="n">first</span><span class="p">.</span><span class="n">first</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span> <span class="o">&lt;&lt;</span> <span class="n">p</span><span class="p">.</span><span class="n">first</span><span class="p">.</span><span class="n">second</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span> <span class="o">&lt;&lt;</span> <span class="n">p</span><span class="p">.</span><span class="n">second</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</code></pre></div></div>

<hr />

<h3 id="vector">Vector</h3>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//some functions in vector</span>
<span class="n">v</span><span class="p">.</span><span class="n">clear</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">O</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
<span class="n">v</span><span class="p">.</span><span class="n">assign</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="c1">//upto 10th element assign by 1</span>
<span class="n">v</span><span class="p">.</span><span class="n">sort</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="c1">//{8, 1, 2, 3, 1}//right exclusive</span>
<span class="n">v</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span><span class="o">+</span><span class="n">i</span><span class="p">,</span><span class="n">x</span><span class="p">);</span><span class="c1">//immediade pos go to next</span>
<span class="n">v</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span><span class="o">+</span><span class="n">i</span><span class="p">);</span><span class="c1">//next go this pos</span>
<span class="c1">// range always right exclusive</span>
<span class="n">reverse</span><span class="p">(</span><span class="n">range</span><span class="p">)</span> <span class="n">or</span> <span class="nf">sort</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">rbegin</span><span class="p">(),</span><span class="n">v</span><span class="p">.</span><span class="n">rend</span><span class="p">());</span>

<span class="n">swap</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">)</span> <span class="n">or</span> <span class="n">u</span><span class="p">.</span><span class="n">swap</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="c1">//swap two vectors element</span>
<span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="n">x</span><span class="p">);</span><span class="c1">//first occurance</span>
<span class="k">if</span><span class="p">(</span><span class="n">it</span><span class="o">==</span><span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">())</span><span class="c1">//not occur x</span>
<span class="n">index</span> <span class="o">=</span> <span class="n">it</span> <span class="o">-</span> <span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
<span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">rbegin</span><span class="p">(),</span><span class="n">v</span><span class="p">.</span><span class="n">rend</span><span class="p">(),</span><span class="n">x</span><span class="p">);</span><span class="c1">//last occurance</span>
<span class="k">if</span><span class="p">(</span><span class="n">it</span><span class="o">==</span><span class="n">v</span><span class="p">.</span><span class="n">rend</span><span class="p">())</span><span class="c1">//not occur x</span>

<span class="n">count</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="n">x</span><span class="p">);</span>
<span class="n">accumulate</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="mi">0LL</span><span class="p">);</span><span class="c1">//0LL initial sum</span>
<span class="o">*</span><span class="n">min_element</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
<span class="o">*</span><span class="n">max_element</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>

<span class="n">partial_sum</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="n">pre</span><span class="p">.</span><span class="n">begin</span><span class="p">());</span>

</code></pre></div></div>

<p><code>right exclusive -&gt; (v.begin(),v.end())</code>
<br /></p>

<ul>
  <li>std::vector&lt; ValueType &gt;</li>
</ul>

<h2><img src="https://hackingcpp.com/cpp/std/vector_crop.png" alt="vector_cheetsheet" /></h2>

<h3 id="string">String</h3>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="c1">// index 2 to upto 2 char</span>
 <span class="n">string</span> <span class="n">sub</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span><span class="c1">//char of index 2-3 [cautions its not range like]</span>

 <span class="kt">int</span> <span class="n">pos</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="s">"kk"</span><span class="p">);</span><span class="c1">//first occurance -&gt; O(N*N)</span>
 <span class="kt">int</span> <span class="n">pos</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">rfind</span><span class="p">(</span><span class="sc">'1'</span><span class="p">);</span><span class="c1">//last occurance -&gt; O(N)</span>
 <span class="k">if</span><span class="p">(</span><span class="n">pos</span><span class="o">==</span><span class="n">string</span><span class="o">::</span><span class="n">npos</span><span class="p">)</span><span class="c1">//not found (-1)</span>
 <span class="k">else</span> <span class="c1">//found at pos (starting index)</span>
 <span class="n">s</span><span class="p">.</span><span class="n">replace</span><span class="p">(</span><span class="mi">11</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="s">"abcde"</span><span class="p">);</span>
 <span class="n">s</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="s">"abc"</span><span class="p">);</span>
 <span class="n">s</span><span class="p">.</span><span class="n">compare</span><span class="p">(</span><span class="s">"abc"</span><span class="p">);</span>
 <span class="n">std</span><span class="o">::</span><span class="n">getline</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">cin</span><span class="p">,</span> <span class="n">str</span><span class="p">);</span><span class="c1">//line input</span>

 <span class="n">s</span><span class="o">+=</span><span class="sc">'a'</span><span class="p">;</span><span class="c1">//O(1)</span>
 <span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="o">+</span><span class="sc">'a'</span><span class="p">;</span><span class="c1">//O(N)</span>
 <span class="c1">//works in both index based and iterator based</span>
 <span class="n">s</span><span class="p">.</span><span class="n">insert</span><span class="p">();</span>
 <span class="n">s</span><span class="p">.</span><span class="n">erase</span><span class="p">();</span>

 <span class="n">string</span> <span class="n">s</span> <span class="o">=</span> <span class="n">string</span><span class="p">(</span><span class="n">c_string</span><span class="p">);</span>
 <span class="kt">char</span> <span class="n">c_string</span><span class="p">[]</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">c_str</span><span class="p">();</span>
</code></pre></div></div>

<ul>
  <li>std::string Interface &amp; Utilities Overview</li>
</ul>

<h2 id="-1"><img src="https://hackingcpp.com/cpp/std/string_crop.png" alt="string cheatsheet" /></h2>

<h3 id="multidimentional-arrays-and-strings">Multidimentional Arrays and Strings</h3>

<p>example:</p>

<ul>
  <li>2033B_Sakurako and Water
https://www.spoj.com/problems/MAX_NUM/en/</li>
</ul>

<hr />

<h3 id="stack-lifo">Stack (LIFO)</h3>

<pre>
- empty() -&gt; Test whether container is empty (public member function)
- size() -&gt; Return size (public member function)
- top() -&gt; Access next element (public member function)
- push() -&gt; Insert element (public member function)
- emplace() -&gt; Construct and insert element (public member function)
- pop() -&gt; Remove top element (public member function)
- swap() -&gt; Swap contents (public member function)
</pre>

<hr />

<h3 id="queue-fifo">Queue (FIFO)</h3>

<pre>
- empty(): Checks if the queue is empty.
- size(): Returns the number of elements in the queue.
- push(): Adds an element to the back of the queue.
- front(): Accesses the front element.
- **back(): Accesses the back element.
- pop(): Removes the front element.
- swap(): Exchanges the contents of two queues.
</pre>

<hr />

<h3 id="deque">Deque</h3>

<pre>
empty(): Checks if the deque is empty.
push_back(): Adds an element to the end.

**push_front(): Adds an element to the front.

size(): Returns the number of elements.
front(): Accesses the front element.
back(): Accesses the back element.
pop_back(): Removes the back element.

**pop_front(): Removes the front element.

emplace_back(): Constructs and inserts an element at the back.
emplace_front(): Constructs and inserts an element at the front.
insert(): Inserts an element at a specific position.
erase(): Removes an element at a specific position.
swap(): Exchanges the contents with another deque.
clear(): Removes all elements.

- access any index[]
- vector is more memory efficient than deque
</pre>

<ul>
  <li>std::deque&lt; ValueType &gt;</li>
</ul>

<p><img src="https://hackingcpp.com/cpp/std/deque_crop.png" alt="deque cheatsheet" /></p>

<hr />

<h3 id="priority-queueheap">Priority Queue/Heap</h3>

<pre>
- priority_queue&lt; int&gt; pq; //default maxHeap//max at top//pop that max
- no way to access random or bottom element
- priority_queue&lt; int, vector&lt; int&gt;, greater<int>&gt; minHeap;//min at top

push(): Inserts an element. In a max-heap (default), the largest element has the highest priority; in a min-heap, the smallest element has the highest priority.
size(): Returns the number of elements in the priority queue.
top(): Accesses the top element, which is the largest (or smallest, if a min-heap) based on the heap type.
pop(): Removes the top element.
empty(): Checks if the priority queue is empty.
swap()
&lt;/pre&gt;

```cpp
class Compare {
public:
    bool operator()(pair&lt;int, int&gt; below, pair&lt;int, int&gt; above)
    {
        auto [l1, r1] = below;
        auto [l2, r2] = above;
        return abs(l1 - r1) &lt; abs(l2 - r2);
    }
};
priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, Compare&gt; pq;
```

---

### Set

<pre>
bool cmp(int x,int y){
        return x&gt;y;
}
- set&lt; int,decltype(&amp;cmp)&gt;s(cmp);//reversee order

- unique and sorted
all operation in logn
- s.insert(x);
- s.erase(s.find(x));  // s.erase(velue);//both valid
- int cnt = s.count(x);
- can't find index like vector because it's use bidirectional iterator

- auto it = s.lower_bound(x);(*it&gt;=x)(first encounder which value at least x)
- auto it = s.upper_bound(x);(*it&gt;x)(which value strictly &gt; x)
- if not exist then (lower_bound==upper_bound)
- only increase or decrease by one (except next(),prev()) 

- lower_bound(s.begin(),s.end()) -&gt; work but O(N), s.lower_bound(x) -&gt; O(logN), same as upper_bound 

- set &lt; int&gt;se(v.begin(),v.end())//vector input in set
</pre>

- std::set&lt;KeyType,Compare&gt;

![set cheatmap](https://hackingcpp.com/cpp/std/set_crop.png)
https://www.spoj.com/problems/ADAFIELD/en/

---

### Unordered Set

<pre>
- don't care order but unique
</pre>

- std::unordered_set&lt;KeyType,Hash,KeyEqual&gt;

![unordered set](https://hackingcpp.com/cpp/std/unordered_set_crop.png)

---

### Ordered Set / PBDS

<pre>
- order_of_key (k) : Number of items strictly smaller than k .
- find_by_order(k) : K-th element in a set (counting from zero).
</pre>

```cpp
#include &lt;ext/pb_ds/assoc_container.hpp&gt;
#include &lt;ext/pb_ds/tree_policy.hpp&gt;
using namespace __gnu_pbds;

#define ordered_set tree&lt;int, null_type,less<int>, rb_tree_tag,tree_order_statistics_node_update&gt;

//or
typedef tree&lt;pair&lt;int, int&gt;, null_type, less&lt;pair&lt;int, int&gt;&gt;, rb_tree_tag, tree_order_statistics_node_update&gt; PBDS;

//for multiset
#define ordered_multiset tree&lt;int, null_type,less_equal<int>, rb_tree_tag,tree_order_statistics_node_update&gt;
```

### Multiset

<pre>
- sorted but not unique
- m.erase(m.find(a));//remove first occurrance -&gt; O(logN)
- m.erase(a);//remove all occurrences of a -&gt; O(logN+K)
- can't be m.erase(m.end()) in any container
- int cnt = m.count(x)//O(logN+K)
- if not find() any then return m.end() -&gt; so check every time//but don't matter in value
</pre>

---

### Map

<pre>
- key, value pair (key must be unique)
- map always sorted by key
- access random using key (O(logN))-&gt;m[key]-&gt;value;
- auto it = m.find(key); (have if it!=m.end())
- m.erase(it);//m.erase(key);
</pre>

- std::map&lt;KeyType,MappedType,KeyCompare&gt;

## ![map](https://hackingcpp.com/cpp/std/map_crop.png)

https://codeforces.com/problemset/problem/920/B

### Unordered Map/HashTable/HashMap

<pre>
- isn't sort using key. 
- accessing in average case O(1) worst case O(N) -&gt; but in map always O(logN) 
</pre>

```cpp
//if key is int or ll //otherwise not work custom hash
//https://codeforces.com/blog/entry/62393
struct custom_hash {
    static uint64_t splitmix64(uint64_t x) {
        // http://xorshift.di.unimi.it/splitmix64.c
        x += 0x9e3779b97f4a7c15;
        x = (x ^ (x &gt;&gt; 30)) * 0xbf58476d1ce4e5b9;
        x = (x ^ (x &gt;&gt; 27)) * 0x94d049bb133111eb;
        return x ^ (x &gt;&gt; 31);
    }

    size_t operator()(uint64_t x) const {
        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();
        return splitmix64(x + FIXED_RANDOM);
    }
};
```

- std::unordered_map&lt;KeyType,MappedType,Hash,KeyEqual&gt;

![unordered map](https://hackingcpp.com/cpp/std/unordered_map_crop.png)

---

### Multimap

---

### Policy Based Data Structure

## https://codeforces.com/contest/2051/problem/D

### List/Linked List

<pre>
- default list is doubly linked list
</pre>

---

### STL Array

- c_type array(not stl array) pass by referrence by default.
- pass by value need more time than pass by reference

---

### Bitset

<pre>
- bitset fixed at compile time
- must have constant size, complexity O(N/64)
- bitset&lt;8&gt;bs(88);//also convert binary string -&gt; bs("0010101")
- i can randomly choose bit left to right LSB-&gt;MSB(bs[0-7]-&gt;O(1)) like array
- bs.set() -&gt; all value 1//bs.set(index)
- bs.reset() -&gt; all value 0//bs.reset(index);
- bs.flip()-&gt; 0-1, 1-0//bs.flip(index)
- bs.count()-&gt; number of 1
- bs.size();
- bs.to_ullong();//with in range of ull
- bs.to_string();
- bs.any()-&gt; check at least one
- bs.none()-&gt; all bit 0 or not
- bs.all()-&gt; all bit 1 or not

binary operation on bitset 
- (bs1 | bs2) //and &amp; ^ all operation
</pre>

---

### Others

- Standard Algorithms

![algo](https://hackingcpp.com/cpp/std/algorithms_crop.png)

- Lambda Expressions
<pre>
- [&amp;] capture all variable by refference
- [=] capture all variable by value
- [a,&amp;b] capture a by value, b byb refference
</pre>

![Lambda Expressions](https://hackingcpp.com/cpp/lang/lambdas_crop.png)

- Custom Comparator
<pre>
- weak ordering (a&gt;=b) (in C++ '=' always return false)
- so don't use it('=') in comparator function
</pre>

```cpp
sort(v.begin(),v.end(),[](pair&lt;int,int&gt;a,pair&lt;int,int&gt;b){
    if(a.first!=b.first){
        return a.first&gt;b.first;
    }
    return a.second&gt;b.second;
});
```

example:

- [632C_The Smallest String Concatenation](./2_string/632C_The%20Smallest%20String%20Concatenation.cpp)

    <pre>We have to sort all string by lexicographical order.
  
    (a &lt; b), (b &lt; c) -&gt; (a &lt; c)</pre>
</int></int></int></pre>
