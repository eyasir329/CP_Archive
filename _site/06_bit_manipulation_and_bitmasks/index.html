<h3 id="basic-technique">Basic Technique</h3>

<p>https://codeforces.com/blog/entry/73490</p>

<ul>
  <li>
    <p>In bitwise operation, we have to think it <strong><em>bit by bit</em></strong>. It’s nothing means in decimal number systems.</p>
  </li>
  <li>We have to use <strong>bracket()</strong> when we use bitwise operation.</li>
  <li><strong>LEFT SHIFT</strong>: (x«1) == x*2 , (x«2)==x*2*2 … go on … (x«k) == x*2<sup>k</sup>.</li>
  <li>(1«n) == 2<sup>n</sup></li>
  <li><strong>RIGNT SHIFT</strong>: (x»1) == x/2, (x»k) == x/(2<sup>k</sup>)</li>
</ul>

<pre>
    LEFT SHIFT                             RIGHT SHIFT
       13 =     1101                          13 =   1101
(13 &lt;&lt; 2) =   110100                   (13 &gt;&gt; 2) =     11  
</pre>

<ul>
  <li>by default (1) is int. If we need more than 2^31-1, then use (1LL) and store it in long long</li>
  <li>(~a)==(~-a)</li>
  <li>xor -&gt; (a^b) -&gt; single 1 then 1 otherwise 0.</li>
  <li><strong>ODD</strong> number check (x&amp;1)==1 // last bit is 1 in all odd number//0 for even</li>
  <li>something&amp;1 = something /// something&amp;0=0</li>
</ul>

<pre>
NOTE: 
- for any int n, (bitwise and) always give a num(x&amp;n)&lt;=n
      - subarray have min and value - whole array
      - subarray have max and value - in length 1

- for any int n, (bitwise or) always give a num(x|n)&gt;=n
      - subarray have max or value - whole array
      - subarray have min and value - in length 1

- xor gives same number of digits(both have).
      - can't say anything 
</pre>

<p>https://codeforces.com/blog/entry/123404 (max xor subarray)</p>

<h4 id="check-a-bit-on-or-off">Check a Bit ON or OFF</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  Last bit-&gt; (x &amp; 1)
  ith bit-&gt; ((x &gt;&gt; i) &amp; 1)
</code></pre></div></div>

<h4 id="index-of-all-on-bit-count-all-on-bit">Index of all on bit //Count all on bit</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  int cnt = 0;
  for(int i=0;i&lt;32;i++) //31(0-30) is also good//because last bit is sign bit
  {
    if(((x&gt;&gt; i)&amp;1)){//on ith bit
      cout&lt;&lt;i&lt;&lt;" ";
      cnt++;
    }
  }
</code></pre></div></div>

<h4 id="set-kth-bit-on">SET kth bit ON</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  (x |= (1 &lt;&lt; k)) // x or 2^k
</code></pre></div></div>

<h4 id="set-kth-bit-off">SET kth bit OFF</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  (x &amp;= ~(1 &lt;&lt; k)) // x and ~2^k
</code></pre></div></div>

<h4 id="toggle-kth-bit">Toggle kth bit</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  0^1=1  1^1=0 - using xor
  (x ^= (1 &lt;&lt; k))
</code></pre></div></div>

<h4 id="number-is-power-of-2-or-not">Number is power of 2 or not</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  if(num_of_set_bit==1)
</code></pre></div></div>

<p>#</p>

<p>https://www.programiz.com/cpp-programming/bitwise-operators</p>

<p>#</p>

<h4 id="builtin-functions">Builtin Functions</h4>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>               <span class="c1">// x in binary: 00000000 00000000 00000000 00010100</span>
<span class="kt">long</span> <span class="kt">long</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">30</span><span class="p">;</span>  <span class="c1">// y = 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00011110</span>

<span class="c1">// 1. Counting Set Bits</span>
<span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">__builtin_popcount</span><span class="p">(</span><span class="n">x</span><span class="p">);</span><span class="c1">//2</span>
<span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">__builtin_popcountll</span><span class="p">(</span><span class="n">y</span><span class="p">);</span><span class="c1">//4</span>

<span class="c1">// 2. Counting Leading Zeros</span>
<span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">__builtin_clz</span><span class="p">(</span><span class="n">x</span><span class="p">);</span><span class="c1">//27</span>
<span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">__builtin_clzll</span><span class="p">(</span><span class="n">y</span><span class="p">);</span><span class="c1">//59</span>

<span class="c1">// 3. Counting Trailing Zeros</span>
<span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">__builtin_ctz</span><span class="p">(</span><span class="n">x</span><span class="p">);</span><span class="c1">//2</span>
<span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">__builtin_ctzll</span><span class="p">(</span><span class="n">y</span><span class="p">);</span><span class="c1">//1</span>

<span class="c1">// 4. Finding the Position of the First Set Bit</span>
<span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">__builtin_ffs</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
<span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">__builtin_ffsll</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>

<span class="c1">// 5. Parity of the Number of Set Bits</span>
<span class="kt">int</span> <span class="n">parity</span> <span class="o">=</span> <span class="n">__builtin_parity</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">parity_ll</span> <span class="o">=</span> <span class="n">__builtin_parityll</span><span class="p">(</span><span class="n">y</span><span class="p">);</span>

<span class="c1">//6. Index of the highest set bit (MSB)</span>
<span class="n">cout</span><span class="o">&lt;&lt;</span><span class="mi">31</span> <span class="o">-</span> <span class="n">__builtin_clz</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span><span class="c1">//4</span>
<span class="n">cout</span><span class="o">&lt;&lt;</span><span class="mi">63</span> <span class="o">-</span> <span class="n">__builtin_clzll</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span><span class="c1">//4</span>
<span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">__lg</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span><span class="c1">//4</span>
<span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">__lg</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span><span class="c1">//4</span>

<span class="c1">//7. Index of the lowest set bit (LSB)</span>
<span class="n">cout</span><span class="o">&lt;</span><span class="n">__builtin_ffs</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span><span class="c1">//2</span>
<span class="n">cout</span><span class="o">&lt;</span><span class="n">__builtin_ffsll</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span><span class="c1">//1</span>
<span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">__builtin_ctz</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span><span class="c1">//2</span>
</code></pre></div></div>

<hr />

<h3 id="bitwise-or">Bitwise OR</h3>

<hr />

<h3 id="bitwise-and">Bitwise AND</h3>

<hr />

<h3 id="xor-tricks">XOR Tricks</h3>

<p>https://codeforces.com/contest/2048/problem/C</p>

<p>https://florian.github.io//xor-trick/</p>

<ul>
  <li>a^a = 0</li>
</ul>

<p>(xor of even number of same type = 0, otherwise(odd) only one have that type)</p>

<ul>
  <li>a^0 = a</li>
  <li>a^b = 0 (a==b)</li>
</ul>

<p>Don’t matter order of operations.</p>

<ul>
  <li>a^b^a = 0^b = b</li>
  <li>a^b = c =&gt; a = b^c (vise-versa)</li>
</ul>

<pre>
if we have a sequence of xor operations... we can remove pair of douplicate value.
</pre>

<h4 id="duplicate-number-finding">Duplicate number finding</h4>

<pre>
we have 1 to n all numbers and a extra one number&lt;=n, we have to find that extra number.
</pre>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(1^2^3^....^n)^(xor of given all numbers) = extra one
</code></pre></div></div>

<h4 id="missing-number-finding">Missing number finding</h4>

<pre>
we have 1 to n-1, we have to find missing number.
</pre>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(1^2^3^....^n)^(xor of given all numbers) = missing one
</code></pre></div></div>

<h4 id="prefix-xor-subarray-xor">Prefix XOR (Subarray XOR)</h4>

<p><a href="./3_xor_tricks/cses1650_Range%20Xor%20Queries.cpp">cses1650_Range Xor Queries</a></p>

<pre>
Given an array of n integers, your task is to process q queries of the form: what is the xor sum of values in range [a,b]?

hint: same as prefix sum
</pre>

<ul>
  <li>https://codeforces.com/problemset/problem/2039/C1</li>
</ul>

<hr />

<h3 id="bitmasks">BitMasks</h3>

<h4 id="total-combination--total-subset">Total Combination + Total Subset</h4>

<pre>
  vector<int> arr = {1, 6, 8, 9};
  // total n! combination// 4! =24 //pick all but different time
  do {
    int num = arr[0] * 1000 + arr[1] * 100 + arr[2] * 10 + arr[3];
    cout &lt;&lt; num &lt;&lt; endl;
  } while (next_permutation(arr.begin(), arr.end()));

  // total subset 2^n -- pick or not pick
  for (int mask = 0; mask &lt; (1 &lt;&lt; arr.size()); mask++) {
    for (int i = 0; i &lt; arr.size(); i++) {
      if ((mask &gt;&gt; i) &amp; 1) {
        cout &lt;&lt; arr[i];
      }
    }
    cout &lt;&lt; endl;
  }

Output:-
1689 1698 1869 1896 1968 1986 6189 6198 6819 6891 6918 6981 8169 8196 8619 8691 8916 8961 9168 9186 9618 9681 9816 9861 - total combination
{} 1 6 16 8 18 68 168 9 19 69 169 89 189 689 1689 - total subset
&lt;/pre&gt;

- <code>You are given N≤20 numbers, each up to 10<sup>9</sup>. Is there a subset with sum equal to given goal S?</code>

      for(int mask = 0; mask &lt; (1 &lt;&lt; n); mask++) { //O(2<sup>n</sup>*n)
            long long sum_of_this_subset = 0;
            for(int i = 0; i &lt; n; i++) {
                  if(mask &amp; (1 &lt;&lt; i)) {
                        sum_of_this_subset += a[i];
                  }
            }
            if(sum_of_this_subset == S) {
                  puts("YES");
                  return 0;
            }
      }
      puts("NO");

#### Checking Set Bit

https://codeforces.com/contest/2020/problem/C

        int a = 0;
        for (int i = 60; i &gt;= 0; i--)
        {
          int x = ((1LL &lt;&lt; i) &amp; b) != 0;
          int y = ((1LL &lt;&lt; i) &amp; c) != 0;
          int z = ((1LL &lt;&lt; i) &amp; d) != 0;
          int canBe = m[ {x, y, z}];//pre-calculating truth table
          if (canBe == -1)//something that cannot possible
            {
              a = -1;
              break;
            }
            else
            {
              a += canBe * (1LL &lt;&lt; i);//answer calculation
            }
        }

---

### Bit Manipulation

- The Bit Law
<pre>
Always think bit by bit. If the solution is independent of the other bits, then we can solve the problem for each bit separately. 
</pre>

[1601A_Array Elimination](./1_bit_manipulation/1601A_Array%20Elimination.cpp)

<pre>
Everytime select k element, do "bitwise and" for all of that element, 
Calculate x=ai1 &amp; ai2 &amp; … &amp; aik,
Subtract x from each of ai1,ai2,…,aik; all other elements remain untouched.

print all values k, such that it's possible to make all elements of a equal to 0 in a finite number of elimination operations with the given parameter k

- firstly think to solve of zero/one array
- then solve independent bit (if possible) 
- if all a[i] = 1, then select k such that our "and" outcome would be 1, then 1-1 = 0
- count of 1 is a multiple of k

- every bit is independent 
</pre>

#### Some Technique

- [Sum of all Numbers in an array using the Bit Law](./1_bit_manipulation/sum_of_all_bitlaw.cpp)

<pre>
- any number &lt;=1e9 can be represented as sum of(i=0-&gt;30) 2<sup>i</sup>*b<sub>i</sub>
- For each bit k, we can calculate the number of numbers that have 1 in the k-th bit. if there are cnt<sub>k</sub>[1] numbers with 1. then the sum of all numbers with 1 in the k-th bit is cnt<sub>k</sub>[1]*2<sup>i</sup>*b<sub>i</sub>
</pre>

```cpp
int n; cin &gt;&gt; n;
vector<int> cnt(30, 0);
for (int i = 1; i &lt;= n; i++) {
    int x; cin &gt;&gt; x;
    for (int k = 0; k &lt; 30; k++) {
        if (x &gt;&gt; k &amp; 1) {
            cnt[k]++;
        }
    }
}
int ans = 0;
for (int k = 0; k &lt; 30; k++) {
    ans += cnt[k] * (1 &lt;&lt; k);
}
cout &lt;&lt; ans &lt;&lt; endl;
```

- [Sum of Pair XORs](./1_bit_manipulation/sum_of_pair_xor.cpp)

<pre>
- find how much pair possible where first 0 and second 1 -&gt;cnt[0]*cnt[1]*2 (01/10)
</pre>

```cpp
//bruteforce
for (int i = 1; i &lt;= n; i++) {
    for (int j = 1; j &lt;= n; j++) {
        ans += a[i] ^ a[j];
    }
}
//optimise solution
int cnt[30][2];
memset(cnt, 0, sizeof(cnt));
for (int i = 1; i &lt;= n; i++) {
    for (int k = 0; k &lt; 30; k++) {
        if (a[i] &gt;&gt; k &amp; 1) {
            cnt[k][1]++;
        } else {
            cnt[k][0]++;
        }
    }
}
ll ans = 0;
for (int k = 0; k &lt; 30; k++) {
    ll contrib = 1LL * cnt[k][0] * cnt[k][1] * 2;
    ans += contrib * (1 &lt;&lt; k);
}
```

- [Sum of Pair ANDs](./1_bit_manipulation/sum_of_pair_ands.cpp)
<pre>
- cnt[1]\*cnt[1]
</pre>

```cpp
//bruteforce
for (int i = 1; i &lt;= n; i++) {
    for (int j = 1; j &lt;= n; j++) {
        ans += a[i] &amp; a[j];
    }
}
//optimise
ll ans = 0;
for (int k = 0; k &lt; 30; k++) {
    ll contrib = 1LL * cnt[k][1] * cnt[k][1];
    ans += contrib * (1 &lt;&lt; k);
}
```

- Sum of Pair ORs

- Sum of Subset XORs
<pre>
- half of subset has odd number of count
- 2<sup>cnt[1]-1</sup>
</pre>

```cpp
ll ans = 0;
for (int k = 0; k &lt; 30; k++) {
    if(!cnt[k][1])continue;  //edge case
    ll contrib = (1&lt;&lt;(cnt[k][0]+cnt[k][1]-1));//2^n-1
    ans += contrib * (1 &lt;&lt; k);
}
```

- Sum of Subset ANDs

- Sum of Subset ORs

- Number of Subarrays with XOR 0

<pre>
- convert to prefix xor
- p(l,r)-&gt; p[r]^p[l-1]
</pre>

---
</int></int></pre>
