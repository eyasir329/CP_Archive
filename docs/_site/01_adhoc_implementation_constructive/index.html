<h3 id="adhoc-problems">Adhoc Problems</h3>

<p>Adhoc problems <strong>don’t rely on specific algorithms or data structures</strong>. They require creative, case-by-case solutions based on the problem description.</p>

<p><strong>Example</strong>: Finding the second-largest number in a list.</p>

<p>example:</p>

<ul>
  <li><a href="">miaki-presents-kuet-iupc-onsite-2025_K-Beast</a></li>
</ul>

<hr />

<h3 id="implementation-problems">Implementation Problems</h3>

<p>These problems focus on <strong>correctly implementing a sequence of steps or rules</strong>, often based on real-world processes or detailed problem instructions.</p>

<p><strong>Example</strong>: Simulating a traffic light system based on a set of predefined rules.</p>

<h4 id="implementation-tricks--suggestion">Implementation Tricks / Suggestion</h4>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">-</span> <span class="n">use</span> <span class="err">#</span><span class="n">define</span><span class="p">,</span> <span class="k">auto</span>  <span class="c1">//to make code shorter and easier to read</span>
<span class="o">-</span> <span class="p">(</span><span class="kt">long</span> <span class="kt">long</span><span class="p">)</span> <span class="n">a</span><span class="o">*</span><span class="n">b</span> <span class="o">&lt;-&gt;</span> <span class="mi">1LL</span><span class="o">*</span><span class="n">a</span><span class="o">*</span><span class="n">b</span><span class="p">;</span>
<span class="o">-</span> <span class="n">use</span> <span class="n">of</span> <span class="n">function</span><span class="p">,</span> <span class="n">to</span> <span class="n">modularize</span> <span class="n">code</span>

<span class="o">-</span> <span class="n">array</span><span class="o">&lt;</span><span class="n">type</span><span class="p">,</span><span class="n">size</span><span class="o">&gt;</span> <span class="n">can</span> <span class="n">be</span> <span class="n">useful</span> <span class="n">stl</span> <span class="n">array</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="n">tuple</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="o">&lt;-&gt;</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="mi">5</span><span class="o">&gt;&gt;</span><span class="n">v</span><span class="p">;</span>

<span class="o">-</span> <span class="n">use</span> <span class="n">lamda</span> <span class="n">function</span><span class="c1">//helpful in comparator and predicate function</span>
<span class="o">-</span> <span class="n">memset</span><span class="p">(),</span> <span class="n">fill</span><span class="p">()</span> <span class="o">&lt;-&gt;</span> <span class="n">to</span> <span class="n">initialize</span> <span class="n">array</span>

<span class="o">-</span> <span class="n">unique</span> <span class="n">element</span> <span class="n">in</span> <span class="n">vector</span>
  <span class="nf">sort</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
  <span class="n">v</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">unique</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">())</span><span class="cm">/*first iterator that is not unique*/</span><span class="p">,</span><span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>

<span class="o">-</span> <span class="n">sort</span> <span class="n">in</span> <span class="n">decending</span> <span class="n">order</span>
  <span class="nf">sort</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="n">greater</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">)</span><span class="c1">//easier</span>
  <span class="n">sort</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">rbegin</span><span class="p">(),</span><span class="n">v</span><span class="p">.</span><span class="n">rend</span><span class="p">());</span><span class="c1">//easiest</span>

<span class="o">-</span> <span class="n">max</span><span class="o">/</span><span class="n">min</span> <span class="n">of</span> <span class="n">multiple</span> <span class="n">value</span>
  <span class="nf">max</span><span class="p">({</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="n">d</span><span class="p">,</span><span class="n">e</span><span class="p">});</span>
<span class="o">-</span> <span class="n">max</span><span class="o">/</span><span class="n">min</span> <span class="n">in</span> <span class="n">vector</span>
  <span class="o">*</span><span class="n">max_element</span><span class="p">(),</span> <span class="o">*</span><span class="n">min_element</span><span class="p">()</span>
</code></pre></div></div>

<hr />

<h3 id="constructive-problems">Constructive Problems</h3>

<p>Constructive problems require building a solution that satisfies a set of constraints. You develop the answer step by step rather than just determining if something is possible.</p>

<p><strong>Example</strong>: Constructing a valid sequence of parentheses.</p>

<pre>
- check careful about the constraints.
- mostly constructive problems have <b>multiple solutions</b>.
</pre>

<ul>
  <li><b>Always Check for [first + last + in between] &lt;- very important</b></li>
</ul>

<p>example:</p>

<ul>
  <li><a href="./3_constructive/1559C_Mocha%20and%20Hiking.cpp">1559C_Mocha and Hiking</a>
    <pre>
The city where Mocha lives in is called Zhijiang. There are n+1 villages and 2n−1 directed roads in this city.
There are two kinds of roads:
  
    - n−1 roads are from village i to village i+1, for all 1≤i≤n−1
    - n roads can be described by a sequence a1,…,an. If ai=0, the i-th of these roads goes from village i to village n+1, otherwise it goes from village n+1 to village i, for all 1≤i≤n
  
Mocha plans to go hiking with Taki this weekend. To avoid the trip being boring, they plan to go through every village exactly once. They can start and finish at any villages. Can you help them to draw up a plan?
  
-&gt; If a1=1, then the path [(n+1)→1→2→⋯→n] is valid.
If an=0, then the path [1→2→⋯→n→(n+1)] is valid.
Otherwise, since a1=0∧an=1, there must exists an integer i (1≤i&lt; n) where ai=0∧ai+1=1, then the path [1→2→⋯→i→(n+1)→(i+1)→(i+2)→⋯n] is valid.
  
This is a step to prove that there always exists an <b>Hamiltonian path</b> in a tournament graph.
</pre>
  </li>
</ul>

<hr />
