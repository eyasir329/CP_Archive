<h3 id="factorial"><u>Factorial</u></h3>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>n! is the number of ways to arrange n distinct objects in a line.
</code></pre></div></div>

<p><img src="https://i.ibb.co.com/K6QRB35/IMG-0232.jpg" alt="fact" /><br />
<img src="https://i.ibb.co.com/Jk35g1g/IMG-0233.jpg" alt="fact2" /></p>

<pre>
- The difference between combinations and permutations is whether or not the order you are choosing the objects matters.
</pre>

<h4 id="finding-power-of-factorial-divisor">Finding Power of Factorial Divisor</h4>

<p>You are given two numbers (n) and (k). Find the largest power of (k^x) such that (n!) is divisible by (k^x).</p>

<p><strong>Factorial Divisors:</strong> <a href="https://cp-algorithms.com/algebra/factorial-divisors.html">cp-algorithms</a>, <a href="https://artofproblemsolving.com/wiki/index.php/Factorial">AoPS</a></p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Prime k — uses Legendre’s formula</span>
<span class="kt">int</span> <span class="nf">fact_pow</span> <span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">n</span> <span class="o">/=</span> <span class="n">k</span><span class="p">;</span>
        <span class="n">res</span> <span class="o">+=</span> <span class="n">n</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>Example Problems</strong>:</p>
<ul>
  <li><a href="https://artofproblemsolving.com/wiki/index.php/2007_iTest_Problems/Problem_6">2007 iTest Problem 6</a></li>
  <li><a href="https://artofproblemsolving.com/wiki/index.php/2003_AIME_I_Problems/Problem_1">2003 AIME I Problem 1</a></li>
  <li><a href="https://artofproblemsolving.com/wiki/index.php/2006_AIME_II_Problems/Problem_3">2006 AIME II Problem 3</a></li>
</ul>

<blockquote>
  <p>Let (P) be the product of the first 100 positive odd integers. Find the largest integer (k) such that (P) is divisible by (3^k).</p>
</blockquote>

<ul>
  <li>
    <p><a href="https://artofproblemsolving.com/wiki/index.php/1987_IMO_Problems/Problem_1">1987 IMO Problem 1</a></p>
  </li>
  <li>
    <p>Factorial Under Modulo <a href="https://vjudge.net/problem/Gym-248968S">Gym Problem Link</a></p>
  </li>
</ul>

<blockquote>
  <p>Given a large number n, determine efficiently the factorial of n. Since the answer might be very large, you should output the answer modulo 998244353.</p>
</blockquote>

<hr />

<h3 id="-permutations"><u> Permutations</u></h3>

<p>(arrange)</p>

<pre>
- <b>order matter</b>
- nPr is the number of ways to choose r objects from n distinct objects and arrange them in line.
- one elements appear exactly one time in each permutation
- nPr = n!/(n-r)!
- It's a arrangement of elements in specific order
- Total number of permutation of sequence with distinct elements of lengths n is n!

- all combinatorics problem -&gt; combinatorial explosion (easily grow)
</pre>

<p><img src="https://i.ibb.co.com/MsQSS3f/IMG-0234.jpg" alt="perm1" /></p>

<p><img src="https://i.ibb.co.com/d20XP5f/IMG-0235.jpg" alt="perm2" /></p>

<p><img src="https://i.ibb.co.com/njVNnGK/IMG-0237.jpg" alt="perm3" /></p>

<p><img src="https://i.ibb.co.com/kcMdRjn/IMG-0236.jpg" alt="perm4" /></p>

<p><img src="https://i.ibb.co.com/ggwvmYV/IMG-0238.jpg" alt="perm5" /></p>

<pre>
- 4 letters word with unique letters -&gt; C(26,4)

</pre>

<pre>
- next_permutation -&gt; gives immediate next permutation(lexicographical order)
- prev_permutation -&gt; gives immediate previous permutation(lexicographical order)

# also return boolean(have or not)
</pre>

<ul>
  <li><u>Generate all possible permutations</u></li>
</ul>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">a</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">};</span>
    <span class="c1">// if we need all permutation, then we have to sort it</span>
    <span class="n">sort</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">a</span> <span class="o">+</span> <span class="n">n</span><span class="p">);</span>
    <span class="k">do</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">a</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">next_permutation</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">a</span> <span class="o">+</span> <span class="n">n</span><span class="p">));</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>example:</p>

<ul>
  <li>
    <p><a href="./300C_Beautiful_Numbers.cpp">300C_Beautiful_Numbers</a></p>

    <pre>Vitaly is a very weird man. He's got two favorite digits a and b. Vitaly calls a positive integer good, if the decimal representation of this integer only contains digits a and b. Vitaly calls a good number excellent, if the sum of its digits is a good number.
  
  Now Vitaly is wondering, how many excellent numbers of length exactly n are there. As this number can be rather large, he asks you to count the remainder after dividing it by 1000000007 (1^9 + 7).
  
  sum_of_digits = i * a + (n - i) * b;</pre>
  </li>
  <li>
    <p>https://www.codechef.com/problems/NWAYS</p>
  </li>
</ul>

<hr />

<h3 id="-combinations"><u> Combinations</u></h3>

<pre>
- <b>order don't matter</b>
nCr is the number of ways to choose r objects from n distinct objects.
nCr = n!/(r!(n-r)!)
</pre>

<ul>
  <li>Given and find out how many different ways are there to represent N as sum of K non-zero integers.</li>
</ul>

<pre>
In general, for N there will be N-1 dashes, and out of those we want to choose K-1 and place comma in place of those and in place of rest of the dashes place plus sign. So ways of choosing K-1 objects out of N-1 is C(N-1,K-1)
</pre>

<p><img src="https://i.ibb.co.com/LQt1X96/IMG-0239.jpg" alt="comp1" /></p>

<p><img src="https://i.ibb.co.com/CJDPQ0h/IMG-0240.jpg" alt="comp2" /></p>

<p><img src="https://i.ibb.co.com/QrbWYQx/IMG-0241.jpg" alt="comp3" /></p>

<p><img src="https://i.ibb.co.com/3Tgc1ZS/IMG-0242.jpg" alt="comp4" /></p>

<p><img src="https://i.ibb.co.com/yNfDYRL/IMG-0243.jpg" alt="comp5" /></p>

<h3 id="more-combinations-and-combinatorial-proof"><u>More Combinations and Combinatorial Proof</u></h3>

<p><img src="https://i.ibb.co.com/zb2Z1gT/IMG-0244.jpg" alt="p1" />
<img src="https://i.ibb.co.com/860gfhc/IMG-0245.jpg" alt="p3" />
(n,k) = (n,n-k)</p>

<p><img src="https://i.ibb.co.com/n7Jy3Jh/IMG-0246.jpg" alt="p2" />
<img src="https://i.ibb.co.com/WzGpWP1/IMG-0247.jpg" alt="p4" /></p>

<p>example:</p>

<ul>
  <li>
    <p><a href="./cses1716_Distributing%20Apples.cpp">cses1716_Distributing Apples</a></p>

    <pre>There are n children and m apples that will be distributed to them. Your task is to count the number of ways this can be done.</pre>
  </li>
  <li>
    <p><a href="./spoj_ADATEAMS%20_Ada_and_Teams.cpp">spoj_ADATEAMS</a></p>

    <pre>There are N schools from which exactly A will participate. Moreover there are B students in each school and exactly D of them will participate in the Olympiad.
  
  Step 1: Choose A schools from N.
      Number of ways = C(N, A)
  Step 2: For each of those A schools, choose D students from B.
      Number of ways per school = C(B, D)
  For A schools, it becomes (C(B, D))^A</pre>
  </li>
</ul>

<hr />

<h4 id="summary">Summary</h4>

<p><img src="https://gre.myprepclub.com/forum/download/file.php?mode=view&amp;id=14915&amp;sid=8edb21de77d3cc7076c632167e1125f1" alt="key_dif" /></p>

<p><code> Whenever you do a counting problem, the 1st thing you should decide is whether the problem is a Fundamental Counting Principle problem, a permutation problem, or a combination problem.</code></p>

<pre>
- The Fundamental Counting Principle states that if one event has m possible outcomes and a 2nd event has n possible outcomes, then there are m⋅n total possible outcomes for the two events together.

- A combination is the number of ways of choosing k objects from a total of n objects (order does not matter).

- A permutation is the number of ways of choosing and arranging k objects from a total of n objects (order does matter).
</pre>

<p><a href="https://flexbooks.ck12.org/cbook/ck-12-college-precalculus/section/14.2/primary/lesson/counting-with-permutations-and-combinations-c-precalc/">Some Problems (Basic)</a></p>

<hr />

<h3 id="code">Code</h3>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//O(2^n)</span>
<span class="cm">/* nCk mod p using naive recursion */</span>
<span class="kt">int</span> <span class="nf">binomial</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">,</span> <span class="kt">int</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">k</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">k</span> <span class="o">==</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">binomial</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span> <span class="o">+</span> <span class="n">binomial</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">p</span><span class="p">))</span> <span class="o">%</span> <span class="n">p</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li><u>Given q queries. In each query, you are given two integers n and r, you will have to find nPr and nCr modulo 1e9+7 (1&lt;=n,q&lt;=1e6, 0&lt;=r&lt;=n)</u></li>
</ul>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// mod must be prime number -&gt; O(n + log MOD)</span>
<span class="cp">#include</span> <span class="cpf">&lt;bits/stdc++.h&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">const</span> <span class="kt">int</span> <span class="n">N</span> <span class="o">=</span> <span class="mf">1e6</span> <span class="o">+</span> <span class="mi">7</span><span class="p">,</span> <span class="n">mod</span> <span class="o">=</span> <span class="mf">1e9</span> <span class="o">+</span> <span class="mi">7</span><span class="p">;</span><span class="c1">//N must be less than mod</span>

<span class="kt">int</span> <span class="n">fact</span><span class="p">[</span><span class="n">N</span><span class="p">],</span> <span class="n">ifact</span><span class="p">[</span><span class="n">N</span><span class="p">];</span>

<span class="kt">int</span> <span class="nf">power</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span> <span class="c1">//O(logn)</span>
    <span class="kt">int</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">ans</span> <span class="o">=</span> <span class="mi">1LL</span> <span class="o">*</span> <span class="n">ans</span> <span class="o">*</span> <span class="n">x</span> <span class="o">%</span> <span class="n">mod</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">x</span> <span class="o">=</span> <span class="mi">1LL</span> <span class="o">*</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span> <span class="o">%</span> <span class="n">mod</span><span class="p">;</span>
        <span class="n">n</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">inverse</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span> <span class="c1">//O(logmod)</span>
    <span class="k">return</span> <span class="n">power</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">mod</span> <span class="o">-</span> <span class="mi">2</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">prec</span><span class="p">()</span> <span class="p">{</span> <span class="c1">//O(n)</span>
    <span class="n">fact</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fact</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1LL</span> <span class="o">*</span> <span class="n">fact</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">i</span> <span class="o">%</span> <span class="n">mod</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// for(int i=0;i&lt;N;i++){</span>
    <span class="c1">//     ifact[i] = power(fact[i],mod-2);</span>
    <span class="c1">// }</span>
    <span class="n">ifact</span><span class="p">[</span><span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">inverse</span><span class="p">(</span><span class="n">fact</span><span class="p">[</span><span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">N</span> <span class="o">-</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">ifact</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1LL</span> <span class="o">*</span> <span class="n">ifact</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">mod</span><span class="p">;</span><span class="c1">//1/i! = (1/(i+1)!)*(i+1)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">nPr</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span> <span class="c1">//O(1)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="n">r</span><span class="p">)</span><span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">1LL</span> <span class="o">*</span> <span class="n">fact</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">*</span> <span class="n">ifact</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="n">r</span><span class="p">]</span> <span class="o">%</span> <span class="n">mod</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// int nCr(int n, int r) { //O(logn)</span>
<span class="c1">//     ll ans = fact[n];</span>
<span class="c1">//     ans = ans*power(fact[r],mod-2)%mod;</span>
<span class="c1">//     ans = ans*power(fact[n-r],mod-2)%mod;</span>
<span class="c1">//     return ans;</span>
<span class="c1">// }</span>

<span class="kt">int</span> <span class="nf">nCr</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span> <span class="c1">//O(1)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="n">r</span><span class="p">)</span><span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">1LL</span> <span class="o">*</span> <span class="n">fact</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">*</span> <span class="n">ifact</span><span class="p">[</span><span class="n">r</span><span class="p">]</span> <span class="o">%</span> <span class="n">mod</span> <span class="o">*</span> <span class="n">ifact</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="n">r</span><span class="p">]</span> <span class="o">%</span> <span class="n">mod</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int32_t</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span><span class="c1">//O(N + q)</span>
    <span class="n">ios_base</span><span class="o">::</span><span class="n">sync_with_stdio</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>
    <span class="n">cin</span><span class="p">.</span><span class="n">tie</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
    <span class="n">prec</span><span class="p">();</span>
    <span class="kt">int</span> <span class="n">q</span><span class="p">;</span> <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">q</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">q</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">r</span><span class="p">;</span> <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span> <span class="o">&gt;&gt;</span> <span class="n">r</span><span class="p">;</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">nPr</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span> <span class="o">&lt;&lt;</span> <span class="n">nCr</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">prec</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// Factorials and inverses</span>
    <span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1LL</span> <span class="o">*</span> <span class="n">i</span> <span class="o">*</span> <span class="n">f</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">%</span> <span class="n">mod</span><span class="p">;</span>
    <span class="c1">//The code computes inverses for all numbers from 1 to N-1 using this recursive formula:</span>
    <span class="n">inv</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="n">inv</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1LL</span> <span class="o">*</span> <span class="p">(</span><span class="n">mod</span> <span class="o">-</span> <span class="n">mod</span> <span class="o">/</span> <span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="n">inv</span><span class="p">[</span><span class="n">mod</span> <span class="o">%</span> <span class="n">i</span><span class="p">]</span> <span class="o">%</span> <span class="n">mod</span><span class="p">;</span>
    <span class="n">finv</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="n">finv</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1LL</span> <span class="o">*</span> <span class="n">inv</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">finv</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">%</span> <span class="n">mod</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>example:</p>

<ul>
  <li>
    <p>https://cses.fi/problemset/task/1079</p>
  </li>
  <li>
    <p><a href="./1_basic_counting/2_combination/loghtoj1067_Combinations.cpp">lightoj1067_Combinations</a></p>

    <pre>
Given n distinct objects, you want to take k of them. How many ways can you do it?
</pre>
  </li>
  <li>
    <p><a href="./LeetCode1922_Count%20Good%20Numbers.cpp">LeetCode1922. Count Good Numbers</a></p>

    <pre>
  A digit string is good if the digits (0-indexed) at even indices are even and the digits at odd indices are prime (2, 3, 5, or 7).
  
  Given an integer n(1&lt;=n&lt;=1e15), return the total number of good digit strings of length n. Since the answer may be large, return it modulo 10^9 + 7.
  
  A digit string is a string consisting of digits 0 through 9 that may contain leading zeros.
  </pre>
  </li>
  <li>
    <p><a href="./1178C_Tiles.cpp">1178C_Tiles</a></p>
    <pre>
  The dimension of this tile is perfect for this kitchen, as he will need exactly w×h tiles without any scraps. That is, the width of the kitchen is w tiles, and the height is h tiles. he still needs to decide on how exactly he will tile the floor. 
  
  There is a single aesthetic criterion that he wants to fulfil: two adjacent tiles must not share a colour on the edge — i.e. one of the tiles must have a white colour on the shared border, and the second one must be black.
  
  Find the number of possible tilings. As this number may be large, output its remainder when divided by 998244353 (a prime number).
  
  -&gt; when all tiles (1,i) and (j,1) are placed, the rest is determined uniquely. We only need to count the number of ways to tile the first row and first column
  
  -&gt; 1 box can be 4 way to order
  </pre>
  </li>
</ul>

<hr />
