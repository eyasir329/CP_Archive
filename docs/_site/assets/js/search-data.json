{"0": {
    "doc": "18 miscellaneous",
    "title": "18 miscellaneous",
    "content": "Technique . Contribution Technique . Permutation . A permutation of length n is an array consisting of n distinct integers from 1 to n in arbitrary order. For example, [2,3,1,5,4] is a permutation, but [1,2,2] is not a permutation (2 appears twice in the array), and [1,3,4] is also not a permutation (n=3 but there is 4 in the array). example: . | https://codeforces.com/contest/2071/problem/B | . ",
    "url": "/18_miscellaneous/",
    
    "relUrl": "/18_miscellaneous/"
  },"1": {
    "doc": "2 probabilities and expected values",
    "title": "2 probabilities and expected values",
    "content": "- Expected value = (total sum of all possible outcomes)/(number of all possible outcome) . example: . ",
    "url": "/12_math_advanced/2_probabilities_and_expected_values/",
    
    "relUrl": "/12_math_advanced/2_probabilities_and_expected_values/"
  },"2": {
    "doc": "1 sorting",
    "title": "1 sorting",
    "content": "https://visualgo.net/en/sorting . Bubble Sort -&gt;O(n*n) . //each operation bigger go to last index //compare adjacent two by two //iteration go upto n-1 for(int step = 1;step&lt;n;step++){ for(int i=1;i&lt;n;i++){ if(a[i]&gt;a[i+1]){//1 based indexing swap(a[i],a[i+1]); } } } . Selection Sort -&gt; 0(n*n) . //select smaller and swap that to first index for(int i=1;i&lt;n;i++){ int min_index = i; for(int j=i+1;j&lt;=n;j++){ if(a[j]&lt;a[min_index]){ min_index = j; } } swap(a[i],a[min_index]); } . example: . | https://vjudge.net/problem/Gym-103860C | . Insertion Sort -&gt; 0(n*n) . //each element(select) and move to the right positions //insert new element to the right position for(int i=2;i&lt;=n;i++){ int key = a[i]; int j = i-1; while(j&gt;=1 and a[j]&gt;key){ a[j+1] = a[j]; j--; } a[j+1]=key; } . Counting Sort -&gt; O(n+max) . Extra Space -&gt; O(MAX) . //store each in frequency array //1 to max print i cnt[i] times const int MAX = 1e6; int cnt[MAX+1]; { for(int i=1;i&lt;=n;i++){ cnt[a[i]]++; } for(int i=1;i&lt;=MAX;i++){ for(int j=1;j&lt;=cnt[i];j++){ cout&lt;&lt;i&lt;&lt;\" \"; } } } . Merge Sort -&gt; O(nlogn) . Divide &amp; Conquer . //more important than other sorting algorithm //divide it (half by half) untill size is 1 //then merge two sorted array using two pointer (within O(N)) #include &lt;bits/stdc++.h&gt; using namespace std; vector&lt;int&gt;a; vector&lt;int&gt; merge(vector&lt;int&gt;&amp;l, vector&lt;int&gt;&amp;r) { int n = l.size(), m = r.size(); vector&lt;int&gt;ans; int i = 0, j = 0; while (i &lt; n and j &lt; m) { if (l[i] &lt; r[j]) { ans.push_back(l[i++]); } else { ans.push_back(r[j++]); } } while (i &lt; n) ans.push_back(l[i++]); while (j &lt; m) ans.push_back(r[j++]); return ans; } vector&lt;int&gt; merge_sort(int l, int r) { if (l == r)return {a[l]}; int mid = (l + r) / 2; vector&lt;int&gt;left = merge_sort(l, mid); vector&lt;int&gt;right = merge_sort(mid + 1, r); return merge(left, right); } int32_t main() { ios_base::sync_with_stdio(false); cin.tie(NULL); int n; cin &gt;&gt; n; a.resize(n); for (int i = 0; i &lt; n; i++) { cin &gt;&gt; a[i]; } a = merge_sort(0, n - 1); for (int i = 0; i &lt; n; i++) { cout &lt;&lt; a[i] &lt;&lt; \" \"; } cout &lt;&lt; endl; return 0; } . example: . | 2027B_Stalin Sort . starting from the second element in the array, if it is strictly smaller than the previous element (ignoring those which have already been deleted), then delete it. Continue iterating through the array until it is sorted in non-decreasing order. We define an array as vulnerable if you can sort it in non-increasing order by repeatedly applying a Stalin Sort to any of its subarrays, as many times as is needed. Given an array a of n integers, determine the minimum number of integers which must be removed from the array to make it vulnerable? Therefore, we just need to find the longest subsequence in which the first element is the largest. This can be done easily in O(n2) — consider each index being the first item in the subsequence, and count all items to the right of it which are smaller or equal to it. Find the maximum over all of these, then subtract this from n. | https://codeforces.com/contest/1741/problem/D . | . Greedy With Sorting . | cses1629_Movie Festival . In a movie festival n movies will be shown. You know the starting and ending time of each movie. What is the maximum number of movies you can watch entirely? - single time only watch single movie - sort ny ending time which is less comes first [Activity Selection Problem] . | cses1074_Stick Lengths . There are n sticks with some lengths. Your task is to modify the sticks so that each stick has the same length. You can either lengthen and shorten each stick. Both operations cost x where x is the difference between the new and original length. What is the minimum total cost? - make everything to became middle element . | cses1630_Tasks and Deadlines . You have to process n tasks. Each task has a duration and a deadline, and you will process the tasks in some order one after another. Your reward for a task is d-f where d is its deadline and f is your finishing time. (The starting time is 0, and you have to process all tasks even if a task would yield negative reward.) What is your maximum reward if you act optimally? - we have to maximize sum(d - f) and do all work. - start first which has minimum duration . | cses1073_Towers . You are given n cubes in a certain order, and your task is to build towers using them. Whenever two cubes are one on top of the other, the upper cube must be smaller than the lower cube. You must process the cubes in the given order. You can always either place the cube on top of an existing tower, or begin a new tower. What is the minimum possible number of towers? . | cses1161_Stick Divisions . You have a stick of length x and you want to divide it into n sticks, with given lengths, whose total length is x. On each move you can take any stick and divide it into two sticks. The cost of such an operation is the length of the original stick. What is the minimum cost needed to create the sticks? input has n integers d_1,d_2,\\ldots,d_n: the length of each stick in the division. - first merge two min size stick . | . ",
    "url": "/03_searching_and_sorting/1_sorting/",
    
    "relUrl": "/03_searching_and_sorting/1_sorting/"
  },"3": {
    "doc": "03 searching and sorting",
    "title": "Binary Search",
    "content": "- need to be sorted - worst case O(logN) . | bs using recursive and iterative way (GENERAL TYPE) | . //yusing recursive bool bs(int l, int r) { if (l &gt; r)return false; int mid = (l + r) / 2; if (v[mid] == x) { return true; } else if (x &gt; v[mid]) { return bs(mid + 1, r); } else { return bs(l, mid - 1); } } . //using iterative bool bs(int l, int r) { while (l &lt;= r) { int mid = (l + r) / 2; if (v[mid] == x) { return true; } else if (x &gt; v[mid]) { l = mid + 1; } else { r = mid - 1; } } return false; } . | bs for leftmost . | bs for right most . | bs generalize . | . int bs(vector&lt;int&gt; arr, int k){ int l = -1,/*min-1*/ r = arr.size() + 1; // max+1 auto pred = [&amp;](int m) -&gt; bool{ return m&lt;=k; //last occurence of k // ans = l // return m&lt;k; //first occurence of k // ans = r }; while (r - l &gt; 1){ int m = (l + r) / 2; if (pred(m)){ l = m; // l is always last true } else{ r = m; // r is always first false } } return l;//r } . # . Different Types . ITMO Academy: pilot course » Binary Search . LEVEL1 (Searching an item in an array, Find closest in array) . | Find something on array (general) | Given a sortest binary string, we have to find where first 1 occur | Find closest in array . | Find the maximum element not greater than x (closest to x on the left) | Find the minimum element not less than x (closest to x on the right) | . | STL (binary_search, lower_bound, upper_bound) | . LB, UB -&gt; returns iterator (it - v.begin() -&gt; index, *it -&gt; value) - lower_bound -&gt; (&gt;=x) (first value which is atleast &gt;=x) - upper_bound -&gt; (&gt;x) (first value which is strictly &gt;x) (UB-LB -&gt; number of same elements) - binary_search -&gt; (0/1) (find x or not) . LEVEL2 (Binary Search On Answer) . - Important to find worst case (search space) - Careful to calculate mid and monotonic function, it can occur overflow - int mid = (l+r)/2;(upto 2e9) =&gt; l+(r-l)/2;//if l+r occur overflow . Binary search on monotonic function (value is becoming greater or lesser but not both) . | First minimum x for f(x)&gt;=M, where f(x) is the monotonic function . convert to 000001111 or 111100000 like this and detect first one (01/10) . | rope problem | CSES1620_Factory Machines . a factory has n machines, each need ki time to produce one product, What is the shoetest time needed to produce t product. | 1201C_Maximum Median make median as large as possible within atmost k operations, each operation increase a[i] = a[i]+1 -&gt; answer&gt;=x? (minimum number of operations) worst case 1e9+1e9 -&gt; 2e9 - median (middle element in the sortest array, in even length (mid_left+mid_right)/2), odd -&gt; (n+1)/2 . | . LEVEL3 (Minimax Problems) . - minimize some maximum value - maximize some minimum value . | CSES1085_Array Division . Divide the array into k subarray(distinct and put all value in array), such that maximum sum in a subarray(all subarray sum) is as small as possible. we have to divide array, such that each sum&lt;=x (possible or not) and no. of divide&lt;=k . | . LEVEL4 (Maximum Average) . - . | maximum average | . LEVEL5 (Finding the K-th(smallest/largest) Element) . - kth smallest/largest (something) -&gt; try to consider binary search - check kth smallest num &lt;=x ? or not// greater &gt;=x . | 1352C_Kth Not Divisible by n . print kth int (which is not divisible by n -&gt; this series kth value) if(enough num within x) -&gt; x - floor(x/3);//total - no. divisors by 3(between x) . | K-th Sum . array a,b (n int in each), make sum of each pair(not to be distinct) of numbers and find kth sum in ascending order using bs -&gt; O(n*n)-&gt;0(nlogn) - cnt pair of sum &lt;=x and check it to k(at least k) cnt pair of sum &lt;=x in bruteforce O(n*n) O(nlogn)-&gt; using sorting (another binary search (b[i]&lt;=x-a[i])) 0(n)-&gt; using two pointer . | . LEVEL6 (BS ON Doubles) . - while(r-l&gt;= EPS){...}(1e-7) (because of double value) - this type of problem given something like that ... answer will be considered correct if the relative or absolute error is not more than 10−6 (maybe -1 extra) - for 1e-6 -&gt; 100 iterators are enough . | cfedu_Equation find number x such that x*x+sqrt(x) = c (1.0&lt;=c&lt;=1e10), absolute error not more than 1e-6 largest x for which f(x)&lt;=c or smallest x for which f(x)&gt;=c . | . # . example: . https://codeforces.com/contest/2020/problem/B . https://codeforces.com/contest/2031/problem/C . | Odd number of divisors are perfect square . k+(long long)(sqrtl(k)+0.5) //upto ... we find k perfect sqr . | . ",
    "url": "/03_searching_and_sorting/#binary-search",
    
    "relUrl": "/03_searching_and_sorting/#binary-search"
  },"4": {
    "doc": "03 searching and sorting",
    "title": "Interactive",
    "content": "- Interactive problems are problems where you have to interact with the judge to get the answer. - don't use fastio and '\\n' - if use '\\n' then cout.flush() - endl = '\\n' + flush() - main goal -&gt; we have to minimize the query number . example: . | cfgym101021_Guess the Number | . - Your program is allowed to make no more than 25 queries - so we have use BS (1 to 1 000 000 within 25 query) . | 679A_Bear and Prime 100 | . - query to all prime number upto 50,... 51\\*2 &gt;100 (so our number don't have bigger prime number than 50) - composite number always have move than one prime numbers . ",
    "url": "/03_searching_and_sorting/#interactive",
    
    "relUrl": "/03_searching_and_sorting/#interactive"
  },"5": {
    "doc": "03 searching and sorting",
    "title": "Ternary Search",
    "content": ". ",
    "url": "/03_searching_and_sorting/#ternary-search",
    
    "relUrl": "/03_searching_and_sorting/#ternary-search"
  },"6": {
    "doc": "03 searching and sorting",
    "title": "03 searching and sorting",
    "content": "- linear search -&gt; worst case O(N) . example; . | cses1640_Sum of Two Values . Given an array of n integers, and your task is to find two values (at distinct positions) whose sum is x. | cses1662_Subarray Divisibility . Given an array of n integers, your task is to count the number of subarrays where the sum of values is divisible by n. pref[j] - pref[i-1] % n = 0 . | . ",
    "url": "/03_searching_and_sorting/",
    
    "relUrl": "/03_searching_and_sorting/"
  },"7": {
    "doc": "miscellaneous",
    "title": "miscellaneous",
    "content": "example: . | 1860A_Not a Substring | . Some Technique . # . | Sort the Distance from Origin . | Sort 5D Points | String Sort | Balanced Bracket | Sliding Window Technique | Kth Smallest in Each Prefix | Unique Elements | Remove B from A | Word Frequency | Occurrences | Update and Remove Query | Number of Pair of Strings such that d(a,b)&lt;=k in Binary String | . # . Basic Contribution Technique . https://medium.com/spidernitt/contribution-technique-i-c1730f195b41 . The basic idea behind this technique is to identify the entities (basic elements) that constitute the final answer. We need an answer to this question: “What is my final answer made up of?” Then, we would iterate on each entity and find its own contribution to the final answer. FOR(1,N) ans += indivisual contribution of a[i] . | Sum of Pair Sums (All Pair) . Given an array a of size n, find sum(a[i]+a[j]) from (i,j)-&gt;1 to n Here, each element add 2*n times (n+n) FOR(1,n)-&gt; ans += 2*n*a[i] . | Sum of Subarray Sums . Given an array a of size n, find sum(i:1-&gt;n,j:1-&gt;n (a[i]+a[i+1]+...+a[j])) (find all subarray sum of sum) FOR(1,n)-&gt; ans += a[i]*i*(n-i+1); . | Sum of Subset Sums . Given an array a of size n, find the sum of all subset sums of a (ans modulo 1e9+7) FOR(1,n)-&gt; ans += a[i]*2n-1; . | Product of Pair Products . Product of every pair and product of all this product, (ans modulo 1e9+7) FOR(1,n)-&gt; ans *= a[i]2n . | XOR of Subarray XORs . - a[i] contribute to my ans if (i*(n-i+1))&amp;1 . | Sum of (max-min) over all Subsets . - sum of (max(subset) - min(subset)) from 1 to n - sort the array, then a(min) ..upto k in between.. b(max) -&gt; 2j-i+1; in between element, k = j-i+1 . sort(a+1,a+n+1); int ans = 0; for(int i=1;i&lt;=n;i++){//O(N*N) for(int j=i+1;j&lt;=n;j++){ ans += (a[j]-a[i])*(1&lt;&lt;(j-i-1)); } } //can be done within O(N) //by separating min max . | Sum of Sum Length over all Subarrays . Given an array a of size n, find the sum (the sum of the subarray multiplied by the length of the subarray) over all subarrays of a. a[i]*len -&gt; a[i]*(k1+k2+...+kn)//whose subarray that contain a[i], sum of their length -&gt; (sum(left(1-&gt;i)), sum(right(i-&gt;N))) (right - left + 1) -&gt; sum(l-&gt;1,i)-&gt; S(i,n)-l(n-i+1)+(n-i+1) -&gt; S(i,n)*i - (n-i+1)*S(1,i) + (n-i+1)*i . //bruteforce O(N*N) int ans = 0; for(int i=1;i&lt;=n;i++){ int sum = 0; for(int j=i;j&lt;=n;j++){ sum+=a[j]; ans+=sum*(j-i+1);//subarray sum*length } } //o(N) approach int F(int n){ return n*(n+1)/2; } int S(int l,int r){ return F(r)-F(l-1);//l to r sum } ... int ans = 0; for(int i=1;i&lt;=n;i++){ int contribution = S(i,n)*i-(n-i+1)*S(1,i)+(n-i+1)*i; ans += a[i]*contribution; } . | Sum of Number of Vowels in Substrings . Given a string s of size n, find the sum of number of vowels in all substrings of s. leetcode2063_Vowels of All Substrings . long long countVowels(const std::string&amp; s) { std::unordered_set&lt;char&gt; vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}; long long total_sum = 0; int n = s.size(); for (int i = 0; i &lt; n; ++i) { if (vowels.count(s[i])) { total_sum += (long long)(i + 1) * (n - i); } } return total_sum; } . | Sum of Number of Inversions in Permutations . Given an int n, find the sum of the number of inversions in all permutations (1,2...n) number of inversion -&gt; how much such that (i &lt; j and a[i] &gt; a[j]) around half permutation i is behind j and vice-versa (where a[i]&gt;a[j]) n!/2 and there are n*(n-1)/2 total pair . | Sum of Number of Inversions in Subarrray . | . ",
    "url": "/00_cp_math_basics/miscellaneous/",
    
    "relUrl": "/00_cp_math_basics/miscellaneous/"
  },"8": {
    "doc": "3 array",
    "title": "3 array",
    "content": "- each element takes 4 bytes (on most systems). - int a[n][n], memory required -&gt; Memory required (bytes) = n2×4 n = 512 (since 5122×4=1MB), n = 1000 (4MB), n = 10000 (400MB) General Guidelines - Use dynamic allocation for large arrays to avoid stack overflow. - Ensure you have enough physical memory (RAM) to support the desired size. - Avoid unnecessarily large arrays; consider using sparse matrix representations if the array contains many zeros. // stack allocation int n = 500; // Works fine on most systems int a[500][500]; // Requires 1 MB memory (approx.) int m = 1000; // May cause stack overflow int b[1000][1000]; // Requires 4 MB memory (approx.) . //heap allocation (dynamic memory) int main() { int n = 10000; // Larger sizes possible with heap int** a = new int*[n]; for (int i = 0; i &lt; n; i++) { a[i] = new int[n]; } // Use the array (example: initialize with 0) for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; n; j++) { a[i][j] = 0; } } // Free memory for (int i = 0; i &lt; n; i++) { delete[] a[i]; } delete[] a; return 0; } . //std::vector int main() { int n = 10000; // Works for large n if enough memory is available vector&lt;vector&lt;int&gt;&gt; a(n, vector&lt;int&gt;(n, 0)); // Initialize with 0 // Access elements a[0][0] = 1; a[n-1][n-1] = 2; cout &lt;&lt; a[0][0] &lt;&lt; \" \" &lt;&lt; a[n-1][n-1] &lt;&lt; endl; return 0; } . Something on Pair-Wise . - total number of pair (n*(n-1))/2 - we can fixed i or j(one), then calculate -&gt; in pair/triple type of problems - if all elements are distinct(pair-wise) -&gt; they do not have common subarray whose xor are same. example: . | find the total sum of ai*aj, where 1&lt;=i, j&lt;=n, n=1e5 . # we have to do it in one loop (fixing i) for 1 to n: sum += ai * total_sum . | find the total sum of ai*aj, where 1&lt;=i&lt;j&lt;=n, n=1e5 . # we have to do it in one loop (fixing j) for 1 to n: sum += aj * preSum[j-1] . | https://codeforces.com/problemset/problem/1771/A . If max(a) == min(a) (all numbers are the same), the difference is 0 → Every pair satisfies |ai - aj| = 0 → There are n * (n - 1) pairs (i ≠ j). | https://codeforces.com/contest/2078/problem/C . | . Subarray . - total number of subarray -&gt; n*(n+1)/2 . const int N = 1e6 + 9; int a[N]; void print(vector&lt;int&gt;&amp;v) { for (int i = 0; i &lt; v.size(); i++) { cout &lt;&lt; v[i] &lt;&lt; \" \"; } cout &lt;&lt; endl; } int32_t main() { int n; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) { cin &gt;&gt; a[i]; } for (int i = 1; i &lt;= n; i++) { vector&lt;int&gt;v; for (int j = i; j &lt;= n; j++) { v.push_back(a[j]); print(v); } cout &lt;&lt; endl; } return 0; } . example: . | num of subarray whose sum is divisible by k . in [l,r] subarray : (p[r]-p[l-1])%k=0 =&gt; p[r]%k-p[l-1]%k=0 =&gt; p[r]%k=p[l-1]%k . | num of subarray whose xor = 0 . in [l,r] subarray : (p[r]^p[l-1]) = 0 =&gt; p[r] = p[l-1] (using xor property) . | https://codeforces.com/problemset/problem/1438/B . | . Subsequence . Subset . | total number of subset -&gt; 2n-1 | . ",
    "url": "/00_cp_math_basics/3_array/",
    
    "relUrl": "/00_cp_math_basics/3_array/"
  },"9": {
    "doc": "4 string basics",
    "title": "4 string basics",
    "content": "s = s + 'a' -&gt; O(N) -&gt; access whole string s += 'a' -&gt; O(1) -&gt; not accesssing whole string . stringstream . - input from string . string s = \"12 13 24\"; stringstream ss(s); cout &lt;&lt; ss.str &lt;&lt; endl; int a, b, c; ss &gt;&gt; a &gt;&gt; b &gt;&gt; c; //alternate while (ss &gt;&gt; n) { cout &lt;&lt; n &lt;&lt; endl; } //separate words from string getline(cin, s); stringstream ss(s); while (ss &gt;&gt; n) { cout &lt;&lt; n &lt;&lt; endl; } . string(int, char) n=3, c=’a’ =&gt; “aaa” . char c = num + '0' int num = 'c' - '0' . https://www.geeksforgeeks.org/cpp-string-functions/ . Binary String . | 2029B_Replacement | 1971D_Binary Cut | 1913B_Swap and Delete | 1837C_Best Binary String | 2030C_A TRUE Battle | . ",
    "url": "/00_cp_math_basics/4_string_basics/",
    
    "relUrl": "/00_cp_math_basics/4_string_basics/"
  },"10": {
    "doc": "1 datatype conditions",
    "title": "1 datatype conditions",
    "content": "https://usaco.guide/general/data-types?lang=cpp . * floating point numbers are not exact. * so it's generally a bad idea to compare two floating-point numbers for exact equality (==). * Hence, we should always expect that floating point numbers are slightly o↵. if (abs(a-b) &lt; 1e-9) { // a and b are equal } . | The usual floating point types in competitive programming are the 64-bit double and, as an extension in the g++ compiler, the 80-bit long double. In most cases, double is enough, but long double is more accurate. | Some numbers cannot be represented accurately as floating point numbers, and there will be rounding errors. | Note that while floating point numbers are inaccurate, integers up to a certain limit can still be represented accurately. For example, using double, it is possible to accurately represent all integers whose absolute value is at most 253. | . Booleans require 1 byte (8 bits) of storage, not 1 bit, wasting the other 7 bits of storage. To use less memory, one can use bitsets (std::bitset in C++ / BitSet in Java). https://usaco.guide/CPH.pdf#page=16 . long long x = 123456789123456789LL; //subtle error: int a = 123456789; long long b = a*a; cout &lt;&lt; b &lt;&lt; \"\\n\"; // -1757895751 //solve it using (long long)a*a . Large Numbers . Usually contest problems are set so that the type long long is enough. Still, it is good to know that the g++ compiler also provides a 128-bit type __int128_t with a value range of −2127 . 2127 − 1 or about −1038 . 1038. However, this type is not available in all contest systems . | unsigned long long (range 0 -&gt; 2^64-1 (1.8*1019)), occupies 8 bytes of memory. | . //read, write function of 128 bit integer #include &lt;bits/stdc++.h&gt; using namespace std; __int128 read() { string s; cin &gt;&gt; s; __int128 ans = 0; for (int i = 0; i &lt; s.size(); i++) { ans = ans * 10 + (s[i] - '0'); } return ans; } string to_string(__int128 x) { string s; while (x &gt; 0) { s += (char)(x % 10 + '0'); x /= 10; } reverse(s.begin(), s.end()); return s; } void write(__int128 x) { cout &lt;&lt; to_string(x) &lt;&lt; endl; } int32_t main() { __int128 x = read(); write(x); return 0; } . In Python: - Arbitrary-Precision: int type can grow as large as memory allows. - Memory constraints: Size is limited by available system memory. In Java: - Arbitrary Precision: BigInteger handles integers limited by available memory. - Memory Limitation: Size is constrained by system memory, more memory needed for larger numbers. - Efficiency: Operations on large BigIntegers take more time and memory. - Practical Example: BigInteger with 100,000 digits works if system memory allows. | https://vjudge.net/problem/CodeForces-913A | . #using python n = int(input()) m = int(input()) twon = 1 &lt;&lt; n print(m % twon)` . //using java import java.math.BigInteger; import java.util.Scanner; public class ModuloPower { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); long n = scanner.nextLong(); BigInteger m = scanner.nextBigInteger(); BigInteger twon = BigInteger.valueOf(2).pow((int) n); System.out.println(m.mod(twon)); scanner.close(); } } . example: . | lightoj_equal ju ncpc 23 | . Some builtin function . | round, llround | log -&gt; natural log, log2, log10 | sqrt, cbrt -&gt; cube root | stoi, stoll, to_string | is_sorted, rand -&gt; random number (srand(time(0)) seed the random number generator-change everytime) | isalpa, isdigit, islower, isupper, tolower, toupper | . Other’s Things* . | better to use double instead of float to have more accuracy (not precious 100%) | it’s always better to use integer data type, use same type everywhere. | we have to be careful to use (NEVER EVER DO, UNTILL HAVE TO DO) | Cautions for use inbuild functions | . log2()-&gt;__lg()-&gt;give us floor (max set number), int ans = 0; while (n &gt; 1) { //0(logn) but accurate ans++; n /= 2; } pow()-&gt;round(pow()), int ans = 1; for (int i = 0; i &lt; b; i++) { //log(b) but accurate ans *= a; } sqrt()-&gt;//similar to cubic root long long ans = sqrt(n);//sqrtl() while (ans * ans &lt;= n)++ans; while (ans * ans &gt; n)--ans; cout &lt;&lt; ans &lt;&lt; endl; . because that are return double values. Dhaka ICPC 24 Preli Three Quick Brown Foxes Jump Over a Lazy Chicken . | long double is more precise that double//but not use float . | compare two double . | . if(a-b&lt;1e-9){ //they are equal } . | cout«setprecision(10)«num; //from starting//rounding last digit | cout«fixed«setprecision(10)«num; //from after dot . | program duration | . clock_t start,end; start = clock();//store clock tick (between 1e6) .... end = clock(); cerr&lt;&lt;1.0*(end-start)/CLOCKS_PER_SEC&lt;&lt;\" sec\"&lt;&lt;endl; . std::mt19937 rng(std::chrono::steady_clock::now().time_since_epoch().count()); . | assert(condition) -&gt; if true noting happened otherwise give runtime error. – using for debugging purpose. | Multiplying two different Data Types . -&gt; smaller type gets promoted to the larger type . | common mistakes . https://codeforces.com/blog/entry/111217 . | be careful in v.size()-1 -&gt; because of unsigned int doesn’t have negative number . | be careful in multiple test case (all variable need to be reinitialization) . | . ",
    "url": "/00_cp_math_basics/1_datatype_conditions/",
    
    "relUrl": "/00_cp_math_basics/1_datatype_conditions/"
  },"11": {
    "doc": "5 basic maths",
    "title": "5 basic maths",
    "content": ". | (num&gt;0) positive number | (num&gt;=0) non-negative number | . https://aryansh-s.github.io/assets/pdf/The_Art_of_Modular_Arithmetic.pdf . floor, ceil and round . floor-&gt; floor((double)a/b) ~ a/b... ex. floor(7.3)=7 ceil-&gt; ceil((double)a/b) ~ (a+b-1)/b... ex. ceil(7.3)=8 [(a-1)/b +1] round-&gt; round(double(a)/b)... ex. round(7.3)=7, round(7.5)=8 . | if num is divisible by 2, then ceil(num)==floor(num), because it has not any fraction. | . Series . https://www.cuemath.com/summation-formulas/ . | arithmetic progression - difference beteen adjacent two numbers are same. | . formula can generate by: n*(first+last)/2; . | geometric progression - ratio between two consecutive numbers is constant. | . r &gt; 1 =&gt; s = a(rn-1)/(r-1) r = 1 =&gt; s = na #arn-1 formula 0 &lt; r &lt; 1 =&gt; s = a(1-rn)/(1-r) . Notes : check overflow(if then apply as long long(1LL)), oterwise give wrong answer. Harmonic Series . https://scipp.ucsc.edu/~haber/archives/physics116A10/harmapa.pdf https://www.math.drexel.edu/~tolya/123_harmonic.pdf . sum &lt;= floor(log2(n)) + 1 . int n = 1e6; ll sum = 0; //O(N*N) not //O(NlogN) //because of j+=i for (int i = 1; i &lt;= n; i++) { for (int j = i; j &lt;= n; j += i) { //look like -&gt; n*harmonic sum += j; } } //also same for this for (int i = 1; i &lt;= n; i++) { for (int j = 1; i * j &lt;= n; j++) { // j = n/i sum += j; } } . https://codeforces.com/blog/entry/118001 . Some formulas . | Triangles | Median &amp; Centroid . sum of natural numbers = (n * (n + 1)) / 2; sum of square of natural numbers = (n * (n + 1) * ((2 * n) + 1)) / 6; sum of cubes of natural numbers = ((n * n) * (n + 1) * (n + 1)) / 4; nth term of an arithmetic sequence = a + ((n - 1) * d); sum of arithmetic series (number of terms * average of first and last item) = (n * ((2 * a) + ((n - 1) * d))) / 2; nth term of geometric sequence = a * pow(r, n - 1);[a = first_term, r = common ration]; sum of geometric sequence = (a * (pow(r, n) - 1)) / (r - 1);[r != 1]; sum of an infinite geometric sequence = a / (1 - r);[r &lt; 1]; area: semi perimeter (triangle)s = 1/2 * (a + b + c); area(triangle) = (1/2 * base * height) = (1/2*a*b*sin(C)) = sqrt(s * (s - a) * (s - b) * (s - c)); area(right triangle) = (1/2 * a * b); area(equilateral triangle) = (a^2 * sqrt(3)) / 4; [a = side_length] area(equilateral triangle) = (h^2 * sqrt(3)) / 3; [h = altitude, height] area(rectangle) = base * height; area(square) = base^2 = (1/2 * diagonal^2); area(parallelogram) = (base * height) = a*b*sin(C); area(rhombus) = (1/2 * d1 * d2); [d1 = diagonal1, d2 = diagonal2] area(trapezoid) = (1/2 * h * (b1 + b2)); [b1 and b2 are two parallel side, h = distance between d1 and d2] area(regular polygon) = (1/2 * a * p) [a (apothem)= the distance from the center to the midpoint of one of its side, p = perimeter] area(circle) = (pi * r^2) = (pi * d^2) / 4; [d = diameter = 2 * r]; area(sector of circle) = ((n/360) * pi * r^2);[n = measure of the central angle] circumference / perimeter circumference(circle) = (2 * pi * r); length of an arc of a circle = ((n/360) * 2 * pi * r); . | . ",
    "url": "/00_cp_math_basics/5_basic_maths/",
    
    "relUrl": "/00_cp_math_basics/5_basic_maths/"
  },"12": {
    "doc": "2 precedence loops and complexity",
    "title": "2 precedence loops and complexity",
    "content": ". Exponential and Logarithmic Functions . | ak = x -&gt; loga(x) = k; | . | x | 2x | log2(Y)&lt;/br&gt; (Where Y=2x) | . | 20 | 106 | 19.9 | . | 30 | 109 | 29.9 | . | 60 | 1018 | 59.8 | . | some number, everytime divide it by 2(k) until became 1, how much operation need? (floor(logkN)) | . 2020A_Find Minimum Operations . https://www.cuemath.com/log-formulas/ . | log3100 = log2(100)/log2(3) | number of digit in other number system :- floor(logkN))+1 (k base) | how much digit in n! (n&lt;=1e5) | . //using log product property double sum = 0; for (int i = 1; i &lt;= n; i++ &gt; { sum += log10(i); }) cout &lt;&lt; floor(sum) + 1 &lt;&lt; endl; . # . Time and Space Complexity . https://usaco.guide/bronze/time-comp?lang=cpp . | Big O notation, which expresses worst-case time complexity as a function of $n$ as $n$ gets arbitrarily large. | . | 1s &lt;–&gt; 108 Operations . - bool of array -&gt; n*1byte (1MB -&gt; byte/1e6)(8 time slower than bool of vector) - bool of vector/bitset -&gt; n*1bit - int of vector -&gt; n*4byte (1byte-&gt;8bit) - 256MB memory limit, maxsize of my array? 4x/1e6 = 256 -&gt; x = 6.4e7// bitset can be 1e9+ . | . Algorithm Complexity Table . https://usaco.guide/PAPS.pdf#page=99 . https://usaco.guide/bronze/time-comp?lang=cpp . Common Complexities and Constraints . | Mathematical formulas that just calculate an answer: O(1) | Binary search: O(log⁡n) | Sorted set/map or priority queue: O(log⁡n) per operation . | Prime factorization of an integer, or checking primality or compositeness of an integer naively: O(n) | Reading in n items of input: O(n) | Iterating through an array or a list of nn elements: O(n) | Sorting: usually O(nlog⁡n) for default sorting algorithms (mergesort, Collections.sort, Arrays.sort) | Java Quicksort Arrays.sort function on primitives: O(n2) . | Iterating through all subsets of size k of the input elements: O(nk). For example, iterating through all triplets is O(n3) | Iterating through all subsets: O(2n)~(1«n) | Iterating through all permutations: O(n!) | . Memory Initialization . memset . //work byte by byte char s[10]; memset(s, 'a', 5); //first five replace by 'a'//char need 1 byte s[5] = '\\0'; cout &lt;&lt; s &lt;&lt; endl; //int 4 byte, ll 8 byte //initialize by (0/-1) in (int/long long) //accidentaly currect int a[10]; memset(a, 0, 10 * 4); //a[0]=4byte -&gt;in long long memset(a, 0, 10 * 8); //a[0]=8byte memset(a, 0, a.sizeof(a)); //also work in multi-dimension . fill . //work for every number fill(a,a+n,x) . | memset is faster than fill, but both O(n) | by default global variables is initialize by zero but local variables not | declare large array globally//because it store in data segment, that are bigger in stack memory segment | . # . ",
    "url": "/00_cp_math_basics/2_precedence_loops_and_complexity/",
    
    "relUrl": "/00_cp_math_basics/2_precedence_loops_and_complexity/"
  },"13": {
    "doc": "00 cp math basics",
    "title": "Some Basics",
    "content": "https://codeforces.com/blog/entry/111099 . #to be good at competitive programming, you have to know “what to think” and “how to think” when you try a problem. “What to think”: . you have to know a decent amount of standard problems / techniques. Sometimes, a problem requires steps / observations that seem obvious if you've already seen them. Other times, you may solve a problem by reducing it to a well-known sub-problem. On the other hand, you may realize you've done something wrong if you \"reduce\" the problem to something that you know it's unsolvable under the given constraints. All this isn't possible if you don't know those standard problems. “How to think”: . it comes down to \"building\" a path to the solution. Sometimes, you need to find new insights / observations by analyzing the process in the statement, manipulating math equations, etc. Other times, you need to find a twist to a well-known technique. You can practice \"how to think\" by solving ad-hoc / non-standard problems. https://github.com/ShahjalalShohag/Competitive-Programming-A-Complete-Guideline?tab=readme-ov-file#problems-and-algorithms . How to Read Problem Statements? . | Read the problem statement thoroughly. Try to understand what the problem is asking you to do. | Identify the key information, constraints, and requirements. | Break the problem down into smaller parts or subproblems. | Pay attention to input-output limitations and samples provided in the statement. | Analyze the sample test cases and try to understand the problem better. | Check out the notes section of the problem statement. It may contain some useful information. | Use pen and paper to draw stuff to better understand the problem. | If you are still confused, try to read the problem statement again. | . How to Solve a Problem? . 1. Understand the problem statement This is crucial. Make sure you understand what the problem is asking for, the constraints you have to work with, and the input and output formats. Misunderstanding any part of the problem can lead to a solution that doesn't work. 2. Break It Down Most problems are easier to solve when broken down into smaller, manageable parts. Identify the different components of the problem and try to understand how they relate to each other. 3. Make a Plan/Algorithm Once you've broken down the problem, you should have a better idea of how to solve it. Formulate a strategy for solving the problem. Use pen and paper to write down the steps you need to take to solve the problem. You should have a clear idea of your solution before you start writing the code for it. 4. Write the Code Once you have a solid plan, you can start coding. Write your code carefully, keeping it as clean and clear as possible. This will make it easier to debug and improve later. 5. Test Your Solution Once you've written your code, you should test it against the sample test cases provided in the problem statement. If your solution passes all the sample test cases, you can submit it. You can also try to come up with your own test cases to check your solution. 6. Debug and Improve If your solution doesn't pass all the sample test cases, you should debug it. Go through your code line by line and check if it's doing what you expect it to do. If you find any bugs, fix them and test your solution again. Print and Check 7. Optimize Your Code Once your code is working correctly, see if there's any way to make it more efficient. Can you reduce its time complexity? Can you use less memory? Optimizing your code is good practice. 8. Submit Your Solution Once you're satisfied with your solution, you can submit it. Even if you're confident in your solution, be prepared for the possibility of it being rejected. If it is, use it as an opportunity to learn and improve. # Always try to solve the problem using bruteforce. # Then optimize it. while(fail){ - If previous approach fail then try another approaches. - Make algorithm first, code it later. } . Verdicts . Once you submit your code, you will get a verdict based on multiple criteria. The most common verdicts are:#### Basic Geometry . Wrong Answer (WA) Your program gave an incorrect output for a specific test case. As a result, it wasn't executed on the remaining test set. Note that the test cases are hidden, so you won't be able to see the test case on which your program failed. Compilation Error (CE) Your code failed to compile, likely due to a syntactic error. Solve the error by testing your code locally. Make sure you've selected the correct compiler upon submission. Runtime Error (RE) A fault occurred during the execution of your program. This could be due to issues like accessing an out-of-bound array index, dividing by zero, and so on. Time Limit Exceeded (TLE) Your program took more time to run than the specified limit. Note that, the execution time is the maximum time taken by your program to run on any test case. So, if your program is taking too much time on a specific test case, then it will get a TLE verdict. Memory Limit Exceeded (MLE) Similar to TLE, your program used more memory than the allowed limit. Presentation Error (PE) Your program ran successfully, and the output is correct, but the output format is incorrect. This is usually due to a missing space, newline, or an extra space or newline. Note that your code first gets compiled and then gets executed. That’s why you will get a CE verdict even before it gets executed. # . Useful Keyboard Shortcuts . Shortcuts for Windows / Mac are given side by side. General . 1. `Ctrl + S` / `Cmd + S`: Save - Saves the current file or document. 2. `Ctrl + Shift + S` / `Cmd + Shift + S`: Save As - Saves the current file with a different name or location. 3. `Ctrl + C` / `Cmd + C`: Copy - Copies the selected text or item. 4. `Ctrl + V` / `Cmd + V`: Paste - Pastes the copied or cut text or item. 5. `Ctrl + X` / `Cmd + X`: Cut - Cuts the selected text or item. 6. `Ctrl + Z` / `Cmd + Z`: Undo - Reverses the last action. 7. `Ctrl + Y` / `Cmd + Y`: Redo - Reverses the last undo action. 8. `Ctrl + F` / `Cmd + F`: Find - Opens a search bar to find text within the current document or page. 9. `Ctrl + A` / `Cmd + A`: Select All - Selects all text or items in the current document or window. 10. `Alt + Tab` / `Cmd + Tab`: Switch Application - Switches between open applications or windows. 11. `Ctrl + O` / `Cmd + O`: Open File - Opens a file for editing. 12. `Ctrl + N` / `Cmd + N`: New File - Creates a new file. Sublime Text Specific . 1. `Ctrl + P` / `Cmd + P`: Go to File - Allows you to search for a file in the current project. 2. `Ctrl + D` / `Cmd + D`: Multiple Selections - Selects the next occurrence of the current word or selection and allows you to edit them all at once! 3. `Ctrl + /` / `Cmd + /`: Toggle Comment - Comments out the selected code or text. 4. `Ctrl + F5` / `Cmd + B`: Build/Run - Builds or runs the current file. 5. `Ctrl + Shift + D` / `Cmd + Shift + D`: Duplicate - Duplicates the selected text or line. 6. `Ctrl + K + B` / `Cmd + K + B`: Toggle Sidebar - Shows or hides the sidebar. 7. `Ctrl + Shift + Up Arrow` / `Cmd + Shift + Up Arrow`: Move Line Up - Moves the current line or selection up by one line. 8. `Ctrl + Shift + Down Arrow` / `Cmd + Shift + Down Arrow`: Move Line Down - Moves the current line or selection down by one line. 9. `Ctrl + Shift + N` / `Cmd + Shift + N`: New file - Creates a new file. Note that you can change the shortcuts in sublime text by going to Preferences &gt; Key Bindings. | Self-deception: maybe why you’re still grey after practicing every day | The Forcing Fallacy | . | Constant Optimization . - constant factors are the hidden constants in the time or space complexity of an algorithm. some tricks to reduce the hidden constants - use '\\n' instead of endl - efficient i/o -&gt; fastio - efficient data structures -&gt; use arrays/vectors instead of deque -&gt; use something that has lower constant factors - bit manipulation is faster than arithmetic operations - modulo is slower than other arithmetic operations - recursion is slower than iteration - float/double are slower than integer - const is faster than normal variable - big data type is slower than small data type - accessing big array is slower than small array . | Necessity and Sufficiency . - a necessary condition is a condition that must be present for a event to occur (ex. prime number always odd) - a sufficient condition is a condition that, if present, guarantees that the event will occur (ex. all odd number can't be prime, it mustn't divide any number except(1,same number)) . https://codeforces.com/problemset/problem/1750/A . | . Fast Input &amp; Output . https://usaco.guide/general/fast-io?lang=cpp . | input/output is slow operation | . ios::sync_with_stdio(false) . This disables the synchronization between the C and C++ standard streams. By default, all standard streams are synchronized, which in practice allows you to mix C- and C++-style I/O and get sensible and expected results. If you disable the synchronization, then C++ streams are allowed to have their own independent buffers, which makes mixing C- and C++-style I/O an adventure. cin.tie(nullptr) . This unties cin from cout. Tied streams ensure that one stream is flushed automatically before each I/O operation on the other stream. By default cin is tied to cout to ensure a sensible user interaction. | we have to use ‘\\n’ instead of endl; . endl -&gt; '\\n'+flush(buffer clear) . | . Input with spaces . | cin.getline(s,n); | using getline() instead of get() | . char c[100]; int n; cin &gt;&gt; n; //cin.get(); //without these we find n-1 getline().. //because n '\\n'..counted as first line. upto '\\n' it count a line //char ch = getchar();//alternative cin.ignore(); while (n--) { cin.getline(c, 100); } . End Of File (EOF) . Input untill end of file . while(cin&gt;&gt;x){ ans+=x; } . ",
    "url": "/00_cp_math_basics/#some-basics",
    
    "relUrl": "/00_cp_math_basics/#some-basics"
  },"14": {
    "doc": "00 cp math basics",
    "title": "00 cp math basics",
    "content": " ",
    "url": "/00_cp_math_basics/",
    
    "relUrl": "/00_cp_math_basics/"
  },"15": {
    "doc": "2 factorial permutation combination",
    "title": "2 factorial permutation combination",
    "content": "Factorial . n! is the number of ways to arrange n distinct objects in a line. - The difference between combinations and permutations is whether or not the order you are choosing the objects matters. Finding Power of Factorial Divisor . You are given two numbers (n) and (k). Find the largest power of (k^x) such that (n!) is divisible by (k^x). Factorial Divisors: cp-algorithms, AoPS . // Prime k — uses Legendre’s formula int fact_pow (int n, int k) { int res = 0; while (n) { n /= k; res += n; } return res; } . Example Problems: . | 2007 iTest Problem 6 | 2003 AIME I Problem 1 | 2006 AIME II Problem 3 | . Let (P) be the product of the first 100 positive odd integers. Find the largest integer (k) such that (P) is divisible by (3^k). | 1987 IMO Problem 1 . | Factorial Under Modulo Gym Problem Link . | . Given a large number n, determine efficiently the factorial of n. Since the answer might be very large, you should output the answer modulo 998244353. Permutations . (arrange) . - order matter - nPr is the number of ways to choose r objects from n distinct objects and arrange them in line. - one elements appear exactly one time in each permutation - nPr = n!/(n-r)! - It's a arrangement of elements in specific order - Total number of permutation of sequence with distinct elements of lengths n is n! - all combinatorics problem -&gt; combinatorial explosion (easily grow) . - 4 letters word with unique letters -&gt; C(26,4) . - next_permutation -&gt; gives immediate next permutation(lexicographical order) - prev_permutation -&gt; gives immediate previous permutation(lexicographical order) # also return boolean(have or not) . | Generate all possible permutations | . int main() { int a[] = {1, 2, 3}; // if we need all permutation, then we have to sort it sort(a, a + n); do { for (int i = 0; i &lt; a.size(); i++) { cout &lt;&lt; a[i] &lt;&lt; \" \"; } cout &lt;&lt; endl; } while (next_permutation(a, a + n)); return 0; } . example: . | 300C_Beautiful_Numbers . Vitaly is a very weird man. He's got two favorite digits a and b. Vitaly calls a positive integer good, if the decimal representation of this integer only contains digits a and b. Vitaly calls a good number excellent, if the sum of its digits is a good number. Now Vitaly is wondering, how many excellent numbers of length exactly n are there. As this number can be rather large, he asks you to count the remainder after dividing it by 1000000007 (1^9 + 7). sum_of_digits = i * a + (n - i) * b; . | https://www.codechef.com/problems/NWAYS . | . Combinations . - order don't matter nCr is the number of ways to choose r objects from n distinct objects. nCr = n!/(r!(n-r)!) . | Given and find out how many different ways are there to represent N as sum of K non-zero integers. | . In general, for N there will be N-1 dashes, and out of those we want to choose K-1 and place comma in place of those and in place of rest of the dashes place plus sign. So ways of choosing K-1 objects out of N-1 is C(N-1,K-1) . More Combinations and Combinatorial Proof . (n,k) = (n,n-k) . example: . | cses1716_Distributing Apples . There are n children and m apples that will be distributed to them. Your task is to count the number of ways this can be done. | spoj_ADATEAMS . There are N schools from which exactly A will participate. Moreover there are B students in each school and exactly D of them will participate in the Olympiad. Step 1: Choose A schools from N. Number of ways = C(N, A) Step 2: For each of those A schools, choose D students from B. Number of ways per school = C(B, D) For A schools, it becomes (C(B, D))^A . | . Summary . Whenever you do a counting problem, the 1st thing you should decide is whether the problem is a Fundamental Counting Principle problem, a permutation problem, or a combination problem. - The Fundamental Counting Principle states that if one event has m possible outcomes and a 2nd event has n possible outcomes, then there are m⋅n total possible outcomes for the two events together. - A combination is the number of ways of choosing k objects from a total of n objects (order does not matter). - A permutation is the number of ways of choosing and arranging k objects from a total of n objects (order does matter). Some Problems (Basic) . Code . //O(2^n) /* nCk mod p using naive recursion */ int binomial(int n, int k, int p) { if (k == 0 || k == n) { return 1; } return (binomial(n - 1, k - 1, p) + binomial(n - 1, k, p)) % p; } . | Given q queries. In each query, you are given two integers n and r, you will have to find nPr and nCr modulo 1e9+7 (1&lt;=n,q&lt;=1e6, 0&lt;=r&lt;=n) | . // mod must be prime number -&gt; O(n + log MOD) #include &lt;bits/stdc++.h&gt; using namespace std; const int N = 1e6 + 7, mod = 1e9 + 7;//N must be less than mod int fact[N], ifact[N]; int power(int x, int n) { //O(logn) int ans = 1; while (n &gt; 0) { if (n &amp; 1) { ans = 1LL * ans * x % mod; } x = 1LL * x * x % mod; n &gt;&gt;= 1; } return ans; } int inverse(int a) { //O(logmod) return power(a, mod - 2); } void prec() { //O(n) fact[0] = 1; for (int i = 1; i &lt; N; i++) { fact[i] = 1LL * fact[i - 1] * i % mod; } // for(int i=0;i&lt;N;i++){ // ifact[i] = power(fact[i],mod-2); // } ifact[N - 1] = inverse(fact[N - 1]); for (int i = N - 2; i &gt;= 0; i--) { ifact[i] = 1LL * ifact[i + 1] * (i + 1) % mod;//1/i! = (1/(i+1)!)*(i+1) } } int nPr(int n, int r) { //O(1) if (n &lt; r)return 0; return 1LL * fact[n] * ifact[n - r] % mod; } // int nCr(int n, int r) { //O(logn) // ll ans = fact[n]; // ans = ans*power(fact[r],mod-2)%mod; // ans = ans*power(fact[n-r],mod-2)%mod; // return ans; // } int nCr(int n, int r) { //O(1) if (n &lt; r)return 0; return 1LL * fact[n] * ifact[r] % mod * ifact[n - r] % mod; } int32_t main() {//O(N + q) ios_base::sync_with_stdio(false); cin.tie(NULL); prec(); int q; cin &gt;&gt; q; while (q--) { int n, r; cin &gt;&gt; n &gt;&gt; r; cout &lt;&lt; nPr(n, r) &lt;&lt; \" \" &lt;&lt; nCr(n, r) &lt;&lt; endl; } return 0; } . void prec() { // Factorials and inverses f[0] = 1; for (int i = 1; i &lt; N; i++) f[i] = 1LL * i * f[i - 1] % mod; //The code computes inverses for all numbers from 1 to N-1 using this recursive formula: inv[1] = 1; for (int i = 2; i &lt; N; i++) inv[i] = 1LL * (mod - mod / i) * inv[mod % i] % mod; finv[0] = 1; for (int i = 1; i &lt; N; i++) finv[i] = 1LL * inv[i] * finv[i - 1] % mod; } . example: . | https://cses.fi/problemset/task/1079 . | lightoj1067_Combinations . Given n distinct objects, you want to take k of them. How many ways can you do it? . | LeetCode1922. Count Good Numbers . A digit string is good if the digits (0-indexed) at even indices are even and the digits at odd indices are prime (2, 3, 5, or 7). Given an integer n(1&lt;=n&lt;=1e15), return the total number of good digit strings of length n. Since the answer may be large, return it modulo 10^9 + 7. A digit string is a string consisting of digits 0 through 9 that may contain leading zeros. | 1178C_Tiles . The dimension of this tile is perfect for this kitchen, as he will need exactly w×h tiles without any scraps. That is, the width of the kitchen is w tiles, and the height is h tiles. he still needs to decide on how exactly he will tile the floor. There is a single aesthetic criterion that he wants to fulfil: two adjacent tiles must not share a colour on the edge — i.e. one of the tiles must have a white colour on the shared border, and the second one must be black. Find the number of possible tilings. As this number may be large, output its remainder when divided by 998244353 (a prime number). -&gt; when all tiles (1,i) and (j,1) are placed, the rest is determined uniquely. We only need to count the number of ways to tile the first row and first column -&gt; 1 box can be 4 way to order . | . ",
    "url": "/10_combinatorics/1_basic_counting/2_factorial_permutation_combination/",
    
    "relUrl": "/10_combinatorics/1_basic_counting/2_factorial_permutation_combination/"
  },"16": {
    "doc": "5 pigeonhole principle",
    "title": "5 pigeonhole principle",
    "content": "- Suppose a flock of pigeons fly into a set of pigeonholes to roost. If there are more pigeons than pigeonholes, then there must be at least 1 pigeonhole that has more than one pigeon in it. - If k+1 or more objects are placed into k boxes, then there is at least one box containing two or more objects. | Generalized Pigeonhole Principle | . - If N objects are placed into k boxes, then there is at least one box containing ceil(N/k) objects. | The Pigeonhole Proof | . example: . A. Among 50 people, what is the number of people that must be born on the same month? -&gt; ceil(50/12) = 4.16... =&gt; 5 B. How many students in a class must there be to ensure that 3 students get the same grade (one of A, B, C, D, or F)? -&gt; ceil(N/5) = 3 =&gt;then consider, (N-1)/5 = 2(3-1) =&gt; N = 10+1 = 11 . ",
    "url": "/10_combinatorics/1_basic_counting/5_pigeonhole_principle/",
    
    "relUrl": "/10_combinatorics/1_basic_counting/5_pigeonhole_principle/"
  },"17": {
    "doc": "3 generalized permutations combinations",
    "title": "3 generalized permutations combinations",
    "content": "Introduction . When elements may be used repeatedly (e.g., repeated digits on license plates) or when dealing with indistinguishable elements (e.g., identical letters in a word), standard permutation/combination formulas don't apply. This section covers four key scenarios: 1. Permutations with repetition 2. Combinations with repetition 3. Permutations with indistinguishable objects 4. Distributing objects into boxes . Permutations with Repetition . Scenario: Ordered arrangements where elements can repeat. Formula: . P(n, r) = n^r . Example: Number of 4-digit PINs with digits 0-9: . 10^4 = 10,000 . Theorem 1: The number of r-permutations of a set with n objects with repetition allowed is: . n^r . Combinations with Repetition . Scenario: Unordered selections where elements can repeat. Formula (Stars and Bars): . \\binom{n + r - 1}{r} = \\frac{(n + r - 1)!}{r!(n - 1)!} . Example: Select 5 fruits from apples, oranges, pears: . \\binom{3 + 5 - 1}{5} = 21 \\text{ ways} . Applications: . | Counting solutions to | . (x_1 + x_2 + ... + x_k = r) . | Counting nested loop iterations | . Detailed Example from Rosen 6.5: A cookie shop sells 4 types of cookies. How many ways can you buy 10 cookies? . \\binom{4 + 10 - 1}{10} = \\binom{13}{10} = 286 . Now suppose you want to buy at least 2 chocolate and 1 peanut butter cookie: Assign minimums: 2 chocolate, 1 peanut butter → 7 left to distribute . \\binom{4 + 7 - 1}{7} = \\binom{10}{7} = 120 . Permutations with Indistinguishable Objects . Scenario: Arrangements with duplicate items. Formula: . \\frac{n!}{n_1!n_2!...n_k!} . Example: Arrangements of “SUCCESS”: . \\frac{7!}{3!2!1!1!} = 420 . Theorem 3: For (n) objects with (k) types of duplicates, the number of distinct permutations is: . \\frac{n!}{n_1!n_2!...n_k!} . Multinomial Coefficients . Generalization of binomial coefficients: . \\binom{n}{k_1,k_2,...,k_m} = \\frac{n!}{k_1!k_2!...k_m!} . Applications: . | Polynomial expansions | Counting anagrams | . # How much way to shuffle? - MISSISSIPPI -&gt; (11!)/(4!4!2!) - RRUURRUU -&gt; (8!)/(4!4!) . examples: . | cese1715_Creating Strings II | . Given a string, your task is to calculate the number of different strings that can be created using its characters. Print the number of different strings modulo 1e9+7 -&gt; n!/(a!b!c!…) . Distributing Objects into Boxes . https://usaco.guide/CPH.pdf#page=219 . Four main cases exist based on object/box distinguishability: . Case 1: Distinguishable Objects → Distinguishable Boxes . Formula: . \\frac{n!}{n_1!n_2!...n_k!} . Example: Deal 5 cards each to 4 players from 52-card deck: . \\frac{52!}{5!5!5!5!32!} . Case 2: Indistinguishable Objects → Distinguishable Boxes . Formula: Same as combinations with repetition . \\binom{n + k - 1}{n} . Case 3: Distinguishable Objects → Indistinguishable Boxes . Uses Stirling numbers of the second kind: . S(n,k) = \\frac{1}{k!} \\sum_{i=0}^{k} (-1)^i \\binom{k}{i}(k-i)^n . Case 4: Indistinguishable Objects → Indistinguishable Boxes . Counts integer partitions of (n) into (\\leq k) parts. No closed formula. - Scenario 1: Each box can contain at most one ball. For example, when n = 5 and k = 2, there are 10 solutions-&gt; the answer is directly the binomial coefficient C(n,k). - Scenario 2: A box can contain multiple balls. For example, when n = 5 and k = 2, there are 15 solutions -&gt; the number of solutions is C(n+k−1,k) - Scenario 3: Each box may contain at most one ball, and in addition, no two adjacent boxes may both contain a ball. For example, when n = 5 and k = 2, there are 6 solutions -&gt; There are n − 2k + 1 such boxes and k + 1 positions for them. Thus, using the formula of scenario 2, the number of solutions is C(n−k+1,n−2k+1). Summary . \\[\\begin{array}{|c|c|c|} \\hline \\textbf{Scenario} &amp; \\textbf{Formula} &amp; \\textbf{Example} \\\\ \\hline\\\\ \\text{Permutations with repetition} &amp; n^r &amp; \\text{License plates} \\\\\\\\ \\hline\\\\ \\text{Combinations with repetition} &amp; \\binom{n+r-1}{r} &amp; \\text{Fruit selection} \\\\\\\\ \\hline\\\\ \\text{Indistinguishable permutations} &amp; \\frac{n!}{\\Pi \\text{duplicates}!} &amp; \\text{Anagram counting} \\\\\\\\ \\hline\\\\ \\text{Dist. objects → dist. boxes} &amp; \\frac{n!}{\\Pi \\text{box sizes}!} &amp; \\text{Card dealing} \\\\\\\\ \\hline\\\\ \\text{Indist. objects → dist. boxes} &amp; \\binom{n+k-1}{n} &amp; \\text{Ball-bin problems} \\\\\\\\ \\hline \\end{array}\\] References . | Rosen, K. H. Discrete Mathematics and Its Applications | USACO Guide | Bóna, M. A Walk Through Combinatorics | . ",
    "url": "/10_combinatorics/1_basic_counting/3_generalized_permutations_combinations/",
    
    "relUrl": "/10_combinatorics/1_basic_counting/3_generalized_permutations_combinations/"
  },"18": {
    "doc": "1 basic rules",
    "title": "Basic Counting Problems",
    "content": "https://flexbooks.ck12.org/cbook/ck-12-college-precalculus/section/14.2/primary/lesson/counting-with-permutations-and-combinations-c-precalc/ . - Probability is a mathematical way of calculating how likely an event is to occur. P(event) = (# of favorable outcomes)/total outcomes - The method of calculating the number of total outcomes can be stated as a general rule called the Counting Principle. - The Counting Principle states that the number of choices or outcomes for two independent events. Total outcomes for A and B = (# outcomes for A)*(# outcomes for B) . | The Counting Principle | . Consider choice A with 3 options (A1,A2,A3), and choice B with 2 options (B1,B2). If you had to choose an option from A and then an option from B, the overall total number of options would be 3⋅2=6. The options are A1B1,A1B2,A2B1,A2B2,A3B1,A3B2. - A decision tree is a graph that models the options possible at each stage of an experiment. ",
    "url": "/10_combinatorics/1_basic_counting/1_basic_rules/#basic-counting-problems",
    
    "relUrl": "/10_combinatorics/1_basic_counting/1_basic_rules/#basic-counting-problems"
  },"19": {
    "doc": "1 basic rules",
    "title": "1 basic rules",
    "content": "- How to solve Counting problem? firstly - breakdown the problem then - how much (choice/option/select) for each part . Two Rule of Basic Counting . - Rule of Sum (either/or) - Rule of Product (and) (Total Way = prev way * next way, ex. contribution technique) . Rule of Sum (one event, multiple ways) . - If a task can be done in either one of n1 ways or in one of n2 ways, where the two sets of ways are disjoint, then there are n1+n2 ways to complete the task. - If A and B are two disjoint sets (i.e., A∩B=∅),the total number of elements in their union is given by:∣A∪B∣=∣A∣+∣B∣ . example: . - A. A woman has decided to shop at one store today, either in the north part of town or the south part of town. If she visits the north part of town, she will shop at either a mall, a furniture store, or a jewelry store. If she visits the south part of town then she will shop at either a clothing store or a shoe store. How many possible shops are there?ore or a shoe store. How many possible shops are there? -&gt; 2 + 3 = 5 - B. computer science instructor has two colleagues. One colleague has three textbooks on the analysis of algorithms and the other has 5 textbooks. If n denotes the maximum number of different books on this topic that this instructor can borrow, give the possible value(s) for n. -&gt; min: 5, max: 8 . - how many number with at most 4 digit? -&gt; (9*10*10*10)+(9*10*10)+(9*10)+9 . Rule of Product (2 events (or more)) . - If there are m ways that one event can occur and n ways that another event can occur, then there are m x n ways that both events can occur. - If A1, A2, ... ,Am are finite sets, then the number of elements in the Cartesian product of these sets is the product of the number of elements of each set. example: . - A. During a local campaign, three republican and two democratic candidates are nominated for president of the school board. How many possibilities exist for a pair of candidates (one from each party) to oppose each other for the eventual election. -&gt; 3*2 = 6 A student ID is made of 3 upper-case letters followed by two digits. B. How many possible IDs exist? 26 * 26 * 26 * 10 * 10 = 1,757,600 C. How many IDs are possible if duplicate letters or numbers aren't allowed? 26 * 25 * 24 * 10 * 9 = 1,404,000 D. How many student IDs are possible with an even number of \"A\"s? - For 0 \"A\"s: 25 * 25 * 25 * 10 * 10 = 1,562,500 - For 2 \"A\"s: 3 * (25 * 25 * 10 * 10) = 1,562,500 + 3 * 2,500 = 1,570,000 . - 4 digit number how many? -&gt; 9 * 10 * 10 * 10 - 4 digit even number? -&gt; 9 * 10 * 10 * 5 - 4 digit even palindrome number? -&gt; 4 * 10 * 1 * 1 - 5 digit palindrome number? -&gt; 9 * 10 * 10 * 1 * 1 - how many 4 digit number with unique digit? -&gt; 9 * 9 * 8 * 7 . | https://cses.fi/problemset/task/1617 | . | The Complement Rule and Complex Counting Problems (at least -&gt; Complement of none) | . - Sometimes when dealing with enumeration problems, it is easier to answer the opposite problem. That is, we can find all outcomes for which our condition isn't true, then subtract that total from our sample space, or total number of outcomes. - IDs with Repetition = Sample space - no repeats =&gt; (26^3*10^2) - (26*25*24*10\\*9) . example: . Determine the number of 6 digit integers (no leading zeros) in which: A. Digis may be repeated -&gt; 9*10*10*10*10*10 = 900,000 B. No digit may be repeated -&gt; 9*9*8*7*6*5 = 136,080 C. No digit may be repeated, even number -&gt; last digit 0 or (2,4,6,8) =&gt; (9*8*7*6*5*1) + (8*8*7*6*5*4) = 68,800 D. Digits may be repeated, even number -&gt; 9*10*10*10*10*5 = 450,000 E. No digit may be repeated, divisible by 5 -&gt; last digit 0 or 5 =&gt; (9*8*7*6*5*1) + (8*8*7*6*5*1) = 28,560 F. No digit may be repeated, divisible by 4 -&gt; last m=2(2^m) digit is divisible by 4 =&gt; (last two digit -&gt; have one 0 or not zero) =&gt; (8*7*6*5*6(0X|X0)) + (7*7*6*5*16(24-6-2(44,88))) = 33,600 . - 4 digit number which have at least one 0? (total - no zero) -&gt; 9*10*10*10 - 9*9*9*9 - 4 digit number which have at least two consecutive digits are same? -&gt; 9*10*10*10 - 9*9*9*9 . The Subtraction and Division Rules . The Subtraction Rule - a.k.a. Principle of Inclusion-Exclusion . - If a task can be done in either n1 ways or n2 ways, then the total number of ways to do the task is n1+n2 minus the number of ways to do the task that were counted in both n1 and n2. A ∪ B = A + B − A ∩ B . example: . A. How many bit strings of length 7 either start with \"1\" bit or end with the 3 bit \"000\"? -&gt; (1*2*2*2*2*2*2) + (2*2*2*2*1*1*1) - (1*2*2*2*1*1*1) = 64 + 16 - 8 = (64-8)56 + (16-8)8 + 8 = 72 B. A software company receives 200 applications from collage graduations for a job planning a new ed.tech application. If 107 of the applicants majored in web development, 116 majored in computer science, and 23 majored in something else, how many applicants majored in both web development and computer science? -&gt; 200 - 23 = 107 + 116 - A ∩ B . The Division Rule . - There are n/d ways to do a task if it can be done using a procedure that can be carried out in n ways, where there are d corresponding outcomes per group. - Or, If the finite set A is the union of n pairwise disjoint subsets each with d elements, then n = |A|/d - In terms of functions: If f is a function from A to B, where both are finite sets, and for every value y belongs to B there are exactly d values x belongs to A such that f(x)=y, then |B|=|A|/d . example: . The arrangement (ABCD) is same as (BCDA,CDAB,DABC) because each person has the same left and right neighbors. Since there are 4 possible rotations for any seating order(one for each person being first), every unique circular arrangement is counted 4 times in the linear arrangement. To find the number of unique circular arrangements, we divide the total linear arrangements by the number of rotations. -&gt; 24/4 = 6 . ",
    "url": "/10_combinatorics/1_basic_counting/1_basic_rules/",
    
    "relUrl": "/10_combinatorics/1_basic_counting/1_basic_rules/"
  },"20": {
    "doc": "4 stars and bars",
    "title": "4 stars and bars",
    "content": ". ",
    "url": "/10_combinatorics/1_basic_counting/4_stars_and_bars/",
    
    "relUrl": "/10_combinatorics/1_basic_counting/4_stars_and_bars/"
  },"21": {
    "doc": "1 basic counting",
    "title": "1 basic counting",
    "content": "https://youkn0wwho.academy/topic-list/?category=basics&amp;subCategory=basic_counting . Problem Solve . | class 11 permutation-combination | discreate math. rozen (counting) | Combinatorics a problem solving oriented approch - marcus (1st part) | . ",
    "url": "/10_combinatorics/1_basic_counting/",
    
    "relUrl": "/10_combinatorics/1_basic_counting/"
  },"22": {
    "doc": "4 inclusion exclusion",
    "title": "4 inclusion exclusion",
    "content": "example: . | https://codeforces.com/problemset/problem/1598/B | . ",
    "url": "/10_combinatorics/4_inclusion_exclusion/",
    
    "relUrl": "/10_combinatorics/4_inclusion_exclusion/"
  },"23": {
    "doc": "10 combinatorics",
    "title": "10 combinatorics",
    "content": "Combinatorics studies methods for counting combinations of objects. Usually, the goal is to find a way to count the combinations efficiently without generating each combination separately. A combinatorial problem can often be solved using a recursive function. Sometimes, a recursive formula can be replaced with a closed-form formula. ",
    "url": "/10_combinatorics/",
    
    "relUrl": "/10_combinatorics/"
  },"24": {
    "doc": "06 bit manipulation and bitmasks",
    "title": "06 bit manipulation and bitmasks",
    "content": "Basic Technique . https://codeforces.com/blog/entry/73490 . | In bitwise operation, we have to think it bit by bit. It’s nothing means in decimal number systems. | We have to use bracket() when we use bitwise operation. | LEFT SHIFT: (x«1) == x*2 , (x«2)==x*2*2 … go on … (x«k) == x*2k. | (1«n) == 2n | RIGNT SHIFT: (x»1) == x/2, (x»k) == x/(2k) | . LEFT SHIFT RIGHT SHIFT 13 = 1101 13 = 1101 (13 &lt;&lt; 2) = 110100 (13 &gt;&gt; 2) = 11 . | by default (1) is int. If we need more than 2^31-1, then use (1LL) and store it in long long | (~a)==(~-a) | xor -&gt; (a^b) -&gt; single 1 then 1 otherwise 0. | ODD number check (x&amp;1)==1 // last bit is 1 in all odd number//0 for even | something&amp;1 = something /// something&amp;0=0 | . NOTE: - for any int n, (bitwise and) always give a num(x&amp;n)&lt;=n - subarray have min and value - whole array - subarray have max and value - in length 1 - for any int n, (bitwise or) always give a num(x|n)&gt;=n - subarray have max or value - whole array - subarray have min and value - in length 1 - xor gives same number of digits(both have). - can't say anything . https://codeforces.com/blog/entry/123404 (max xor subarray) . Check a Bit ON or OFF . Last bit-&gt; (x &amp; 1) ith bit-&gt; ((x &gt;&gt; i) &amp; 1) . Index of all on bit //Count all on bit . int cnt = 0; for(int i=0;i&lt;32;i++) //31(0-30) is also good//because last bit is sign bit { if(((x&gt;&gt; i)&amp;1)){//on ith bit cout&lt;&lt;i&lt;&lt;\" \"; cnt++; } } . SET kth bit ON . (x |= (1 &lt;&lt; k)) // x or 2^k . SET kth bit OFF . (x &amp;= ~(1 &lt;&lt; k)) // x and ~2^k . Toggle kth bit . 0^1=1 1^1=0 - using xor (x ^= (1 &lt;&lt; k)) . Number is power of 2 or not . if(num_of_set_bit==1) . # . https://www.programiz.com/cpp-programming/bitwise-operators . # . Builtin Functions . int x = 20; // x in binary: 00000000 00000000 00000000 00010100 long long y = 30; // y = 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00011110 // 1. Counting Set Bits cout&lt;&lt;__builtin_popcount(x);//2 cout&lt;&lt;__builtin_popcountll(y);//4 // 2. Counting Leading Zeros cout&lt;&lt;__builtin_clz(x);//27 cout&lt;&lt;__builtin_clzll(y);//59 // 3. Counting Trailing Zeros cout&lt;&lt;__builtin_ctz(x);//2 cout&lt;&lt;__builtin_ctzll(y);//1 // 4. Finding the Position of the First Set Bit cout&lt;&lt;__builtin_ffs(x); cout&lt;&lt;__builtin_ffsll(x); // 5. Parity of the Number of Set Bits int parity = __builtin_parity(x); int parity_ll = __builtin_parityll(y); //6. Index of the highest set bit (MSB) cout&lt;&lt;31 - __builtin_clz(x)&lt;&lt;endl;//4 cout&lt;&lt;63 - __builtin_clzll(y)&lt;&lt;endl;//4 cout&lt;&lt;__lg(x)&lt;&lt;endl;//4 cout&lt;&lt;__lg(y)&lt;&lt;endl;//4 //7. Index of the lowest set bit (LSB) cout&lt;__builtin_ffs(x) - 1&lt;&lt;endl;//2 cout&lt;__builtin_ffsll(y) - 1&lt;&lt;endl;//1 cout&lt;&lt;__builtin_ctz(x)&lt;&lt;endl;//2 . Bitwise OR . Bitwise AND . XOR Tricks . https://codeforces.com/contest/2048/problem/C . https://florian.github.io//xor-trick/ . | a^a = 0 | . (xor of even number of same type = 0, otherwise(odd) only one have that type) . | a^0 = a | a^b = 0 (a==b) | . Don’t matter order of operations. | a^b^a = 0^b = b | a^b = c =&gt; a = b^c (vise-versa) | . if we have a sequence of xor operations... we can remove pair of douplicate value. Duplicate number finding . we have 1 to n all numbers and a extra one number&lt;=n, we have to find that extra number. (1^2^3^....^n)^(xor of given all numbers) = extra one . Missing number finding . we have 1 to n-1, we have to find missing number. (1^2^3^....^n)^(xor of given all numbers) = missing one . Prefix XOR (Subarray XOR) . cses1650_Range Xor Queries . Given an array of n integers, your task is to process q queries of the form: what is the xor sum of values in range [a,b]? hint: same as prefix sum . | https://codeforces.com/problemset/problem/2039/C1 | . BitMasks . Total Combination + Total Subset . vector arr = {1, 6, 8, 9}; // total n! combination// 4! =24 //pick all but different time do { int num = arr[0] * 1000 + arr[1] * 100 + arr[2] * 10 + arr[3]; cout &lt;&lt; num &lt;&lt; endl; } while (next_permutation(arr.begin(), arr.end())); // total subset 2^n -- pick or not pick for (int mask = 0; mask &lt; (1 &lt;&lt; arr.size()); mask++) { for (int i = 0; i &lt; arr.size(); i++) { if ((mask &gt;&gt; i) &amp; 1) { cout &lt;&lt; arr[i]; } } cout &lt;&lt; endl; } Output:- 1689 1698 1869 1896 1968 1986 6189 6198 6819 6891 6918 6981 8169 8196 8619 8691 8916 8961 9168 9186 9618 9681 9816 9861 - total combination {} 1 6 16 8 18 68 168 9 19 69 169 89 189 689 1689 - total subset &lt;/pre&gt; - You are given N≤20 numbers, each up to 109. Is there a subset with sum equal to given goal S? for(int mask = 0; mask &lt; (1 &lt;&lt; n); mask++) { //O(2n*n) long long sum_of_this_subset = 0; for(int i = 0; i &lt; n; i++) { if(mask &amp; (1 &lt;&lt; i)) { sum_of_this_subset += a[i]; } } if(sum_of_this_subset == S) { puts(\"YES\"); return 0; } } puts(\"NO\"); #### Checking Set Bit https://codeforces.com/contest/2020/problem/C int a = 0; for (int i = 60; i &gt;= 0; i--) { int x = ((1LL &lt;&lt; i) &amp; b) != 0; int y = ((1LL &lt;&lt; i) &amp; c) != 0; int z = ((1LL &lt;&lt; i) &amp; d) != 0; int canBe = m[ {x, y, z}];//pre-calculating truth table if (canBe == -1)//something that cannot possible { a = -1; break; } else { a += canBe * (1LL &lt;&lt; i);//answer calculation } } --- ### Bit Manipulation - The Bit Law Always think bit by bit. If the solution is independent of the other bits, then we can solve the problem for each bit separately. [1601A_Array Elimination](./1_bit_manipulation/1601A_Array%20Elimination.cpp) Everytime select k element, do \"bitwise and\" for all of that element, Calculate x=ai1 &amp; ai2 &amp; … &amp; aik, Subtract x from each of ai1,ai2,…,aik; all other elements remain untouched. print all values k, such that it's possible to make all elements of a equal to 0 in a finite number of elimination operations with the given parameter k - firstly think to solve of zero/one array - then solve independent bit (if possible) - if all a[i] = 1, then select k such that our \"and\" outcome would be 1, then 1-1 = 0 - count of 1 is a multiple of k - every bit is independent . #### Some Technique - [Sum of all Numbers in an array using the Bit Law](./1_bit_manipulation/sum_of_all_bitlaw.cpp) - any number &lt;=1e9 can be represented as sum of(i=0-&gt;30) 2i*bi - For each bit k, we can calculate the number of numbers that have 1 in the k-th bit. if there are cntk[1] numbers with 1. then the sum of all numbers with 1 in the k-th bit is cntk[1]*2i*bi . ```cpp int n; cin &gt;&gt; n; vector cnt(30, 0); for (int i = 1; i &lt;= n; i++) { int x; cin &gt;&gt; x; for (int k = 0; k &lt; 30; k++) { if (x &gt;&gt; k &amp; 1) { cnt[k]++; } } } int ans = 0; for (int k = 0; k &lt; 30; k++) { ans += cnt[k] * (1 &lt;&lt; k); } cout &lt;&lt; ans &lt;&lt; endl; ``` - [Sum of Pair XORs](./1_bit_manipulation/sum_of_pair_xor.cpp) - find how much pair possible where first 0 and second 1 -&gt;cnt[0]*cnt[1]*2 (01/10) . ```cpp //bruteforce for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= n; j++) { ans += a[i] ^ a[j]; } } //optimise solution int cnt[30][2]; memset(cnt, 0, sizeof(cnt)); for (int i = 1; i &lt;= n; i++) { for (int k = 0; k &lt; 30; k++) { if (a[i] &gt;&gt; k &amp; 1) { cnt[k][1]++; } else { cnt[k][0]++; } } } ll ans = 0; for (int k = 0; k &lt; 30; k++) { ll contrib = 1LL * cnt[k][0] * cnt[k][1] * 2; ans += contrib * (1 &lt;&lt; k); } ``` - [Sum of Pair ANDs](./1_bit_manipulation/sum_of_pair_ands.cpp) - cnt[1]\\*cnt[1] . ```cpp //bruteforce for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= n; j++) { ans += a[i] &amp; a[j]; } } //optimise ll ans = 0; for (int k = 0; k &lt; 30; k++) { ll contrib = 1LL * cnt[k][1] * cnt[k][1]; ans += contrib * (1 &lt;&lt; k); } ``` - Sum of Pair ORs - Sum of Subset XORs - half of subset has odd number of count - 2cnt[1]-1 . ```cpp ll ans = 0; for (int k = 0; k &lt; 30; k++) { if(!cnt[k][1])continue; //edge case ll contrib = (1&lt;&lt;(cnt[k][0]+cnt[k][1]-1));//2^n-1 ans += contrib * (1 &lt;&lt; k); } ``` - Sum of Subset ANDs - Sum of Subset ORs - Number of Subarrays with XOR 0 - convert to prefix xor - p(l,r)-&gt; p[r]^p[l-1] . --- . ",
    "url": "/06_bit_manipulation_and_bitmasks/",
    
    "relUrl": "/06_bit_manipulation_and_bitmasks/"
  },"25": {
    "doc": "1 basic graphs",
    "title": "1 basic graphs",
    "content": "https://youkn0wwho.academy/topic-list/?category=basics&amp;subCategory=very_basic_graphs . # . https://medium.com/basecs/a-gentle-introduction-to-graph-theory-77969829ead8 . - Graphs are mathematical structures that represent pairwise relationships between objects. - A graph is a flow structure that represents the relationship between various objects. It can be visualized by using nodes and edges. - Graphs don’t have any concept of a “root” node. And why would they? Nodes can be connected in any way possible, really. One node might be connected to five others! Graphs also don’t have any notion of “one-directional” flow — instead, they might have direction, or they might have no direction whatsoever. Or, to complicate matters further, they could have some links that have direction and others that don’t! - Graph needs at least a single node in order to be considered a “graph”, referred to as a singleton graph - Edges (sometimes referred to as links) can connect nodes in any way possible. (no real rules) graphs can have two types of edges: a edge that has a direction or flow, and an edge that has no direction or flow. https://www.hackerearth.com/practice/algorithms/graphs/graph-representation/tutorial/ . Types of nodes - Root node: The root node is the ancestor of all other nodes in a graph. It does not have any ancestor. Each graph consists of exactly one root node. Generally, you must start traversing a graph from the root node. - Leaf nodes: In a graph, leaf nodes represent the nodes that do not have any successors. These nodes only have ancestor nodes. They can have any number of incoming edges but they will not have any outgoing edges. - unlike trees, there is no hierarchy of nodes! Which means that we don’t need to order them, since order doesn’t matter here. - the origin node and destination node are not fixed. # . https://study.com/academy/lesson/graph-theory-concepts-and-terminology.html . Common Terms . - Vertices(n) + Edges(m) - Nodes are entities whose relationships are expressed using edges - Edges are the components that are used to represent the relationships between various nodes in a graph. An edge between two nodes expresses a one-way or two-way relationship between the nodes. - Neighbours (Adjacent Vertices -&gt; N[x]) + Degree (Number of Neighbours) - Self Loop (edges come and goes to the same vertices) - Path (everynode encounted one, not revisit any node) + Walk (revisit some node) + Cycle (going from one node and coming back to samenode (don't revisit any node except from the starting node)) -&gt; every cycle or path is a walk, walk can contains cycles - Simple Graph (doesn't contain self loop and multiple edges) - A graph is simple if no edge starts and ends at the same node, and there are no multiple edges between two nodes - Bridge + Articulation Point - A bridge is an edge in a graph whose removal increases the number of connected components. - An articulation point (or cut vertex) is a vertex whose removal increases the number of connected components. - Hamiltonian path (is a path in a graph that visits each vertex exactly once.) - Hamiltonian cycle (if a hamiltonian path forms a closed loop) . https://usaco.guide/CPH.pdf#page=119 . - A path leads from node a to node b through edges of the graph. The length of a path is the number of edges in it. - A path is a cycle if the first and last node is the same. - A path is simple if each node appears at most once in the path. - Two nodes are neighbors or adjacent if there is an edge between them. - The degree of a node is the number of its neighbors - The sum of degrees in a graph is always 2m, where m is the number of edges (the sum of degrees is always even). - A graph is regular if the degree of every node is a constant d. - A graph is complete if the degree of every node is n − 1 - N[x] = G - x node visit from every node (N[x]=G implies that x and all other vertices in G are part of N[x], which is true in a complete graph.) - every pair of distinct vertices is connected by a unique edge - In a directed graph, the indegree of a node is the number of edges that end at the node, and the outdegree of a node is the number of edges that start at the node. - In a coloring of a graph, each node is assigned a color so that no adjacent nodes have the same color. - A graph is bipartite if it is possible to color it using two colors (It turns out that a graph is bipartite exactly when it does not contain a cycle with an odd number of edges.) . # . Types of Graph . two types of graphs are pretty common in graph theory problems: directed graphs, and undirected graphs. - Directed graph -&gt; Edges have a direction, meaning that edges with arrows connect one vertex to another. (A graph is directed if the edges can be traversed in one direction only (uni-directional)) - Undirected graph -&gt; Edges do not have a direction, meaning that each edge can be traversed in both directions (Bi-directional). - Cyclic + Acyclic - A graph is cyclic if the graph comprises a path that starts from a vertex and ends at the same vertex. That path is called a cycle. - An acyclic graph is a graph that has no cycle. - Connected + Disconnected - A graph is connected if there is a path between any two nodes. - The connected parts of a graph are called its components. (A connected component is a set of nodes within which anynode can reach any other node.) . - Unweighted vs Weighted (In a weighted graph, each edge is assigned a weight or cost. The weights are often interpreted as edge lengths) - The length of a path in a weighted graph is the sum of the edge weights on the path. - The smallest length path is the shortest path. # . Properties of Graph . Longest Path Tricks - An undirected graph where each node has at degree at least 2 will contain a cycle - A directed graph where each node has at least 1 in-degree and at least 1 out-degree will contain a cycle - The sum of all degree is even. The number of vertices with odd degree is even . # . Representation of Graph . https://www.geeksforgeeks.org/graph-and-its-representations/ https://usaco.guide/CPH.pdf#page=113 https://www.hackerearth.com/practice/algorithms/graphs/graph-representation/tutorial/ . (Adjacency List, Adjacency Matrix and Edge List) . # . | Adjacency Matrix . (Primary use of the adjacency matrix is the Floyd-Warshall algorithm) . | . -&gt; Adding O(1), Checking O(1), Listing all edges O(N*N) -&gt; Memory using O(N*N) (maybe encounted memory limit exceded) (V*V binary matrix) An adjacency matrix is a two-dimensional array that indicates which edges the graph contains. We can efficiently check from an adjacency matrix if there is an edge between two nodes. The matrix can be stored as an array - A binary matrix is a matrix in which the cells can have only one of two possible values - either a 0 or 1. - The adjacency matrix can also be modified for the weighted graph in which instead of storing 0 or 1 in Aij, the weight or cost of the edge will be stored. - if the graph were undirected, each edge (i,j) will have two corresponding entries in the matrix, both cell (i,j) and cell (j,i). In the case of an undirected graph, the adjacency matrix is symmetric. - Adjacency matrix provides constant time access (O(1)) to determine if there is an edge between two nodes. Space complexity of the adjacency matrix is O(V2). - best use when the graph is dense. https://www.geeksforgeeks.org/adjacency-matrix/ . //for directed graph bool A[10][10];//adj[][] void initialize() { for (int i = 0; i &lt; 10; ++i) for (int j = 0; j &lt; 10; ++j) A[i][j] = false; /* where each value adj[a][b] indicates whether the graph contains an edge from node a to node b. If the edge is included in the graph, then adj[a][b] = 1, and otherwise adj[a][b] = 0. */ } int main() { int x, y, nodes, edges; initialize(); //Since there is no edge initially cin &gt;&gt; nodes; //Number of nodes cin &gt;&gt; edges; //Number of edges for (int i = 0; i &lt; edges; ++i) { cin &gt;&gt; x &gt;&gt; y; A[x][y] = true; //Mark the edges from vertex x to vertex y } if (A[3][4] == true) cout &lt;&lt; \"There is an edge between 3 and 4\" &lt;&lt; endl; else cout &lt;&lt; \"There is no edge between 2 and 3\" &lt;&lt; endl; return 0; } /*Input file 4 // nodes 5 //edges 1 2 //showing edge from node 1 to node 2 2 4 //showing edge from node 2 to node 4 3 1 //showing edge from node 3 to node 1 3 4 //showing edge from node 3 to node 4 4 2 //showing edge from node 4 to node 2 */ . for unwighted graph instead of weight write 1 and 0 (also it’s a symetric matrix(for undirected)) . The drawback of the adjacency matrix representation is that the matrix contains n2 elements, and usually most of them are zero. For this reason, the representation cannot be used if the graph is large. https://csacademy.com/lesson/graph_representation . Advantages . - Edge lookup, i.e. checking if a particular edge exists, is done easily. - Adding new edges, or deleting existing ones, is also straightforward. - If the graph is dense, i.e. the number of edges is large. This is usually the preferred method of representing the graph. - Certain algorithms are easier to implement using an adjacency matrix. Disadvantages . - The memory allocated is always an N∗N matrix, even in the case of sparse graphs, i.e. the number of edges is small. - For a given node finding all its neighbours, i.e. other nodes that share an edge with it, requires checking an entire row of elements in the matrix. # . | Adjacency List with Vector (most used) . (BFS, DFS, Dijkstra’s, or other single source graph traversal algorithms) . | . -&gt; Adding O(1), Checking O(N), Listing O(M) ...M = no. of edges -&gt; Memory using O(M) //O(V+E) In the adjacency list representation, each node x in the graph is assigned an adjacency list that consists of nodes to which there is an edge from x. Adjacency lists are the most popular way to represent graphs, and most algorithms can be efficiently implemented using them. - For each node i, we store an array of its neighbours. - For a weighted graph, the weight or cost of the edge is stored along with the vertex in the list using pairs. - In an undirected graph, if vertex j is in list Ai then vertex i will be in list Aj. - A sparse matrix is a matrix in which most of the elements are zero, whereas a dense matrix is a matrix in which most of the elements are non-zero. //If the graph is undirected, it can be stored in a similar way, but each edge is added in both directions. //For a weighted graph, vector&lt;pair&lt;int,int&gt;&gt; adj[N]; adj[1].push_back({2,5}); adj[2].push_back({3,7}); adj[2].push_back({4,6}); adj[3].push_back({4,5}); adj[4].push_back({1,2}); //The benefit of using adjacency lists //following loop goes through all nodes to which we can move from node s: for (auto u : adj[s]) { // process node u } . //for directed graph vector &lt;int&gt; adj[10]; int main() { int x, y, nodes, edges; cin &gt;&gt; nodes; //Number of nodes cin &gt;&gt; edges; //Number of edges for (int i = 0; i &lt; edges; ++i) { cin &gt;&gt; x &gt;&gt; y; adj[x].push_back(y); //Insert y in adjacency list of x } for (int i = 1; i &lt;= nodes; ++i) { cout &lt;&lt; \"Adjacency list of node \" &lt;&lt; i &lt;&lt; \": \"; for (int j = 0; j &lt; adj[i].size(); ++j) { if (j == adj[i].size() - 1) cout &lt;&lt; adj[i][j] &lt;&lt; endl; else cout &lt;&lt; adj[i][j] &lt;&lt; \" --&gt; \"; } } return 0; } . Advantages . - For a graph with N nodes and M edges, the memory used depends on M. This makes the adjacency lists ideal for storing sparse graphs. Let's assume we have a directed graph with 5 000 nodes and (only) 10 000 edges. In the case of the adjacency matrix, we would have allocated 25 000 000 elements, whereas in the case of adjacency lists we only need 10 000. - For a given node finding all its neighbours requires checking only the node's list which contains a numbers of elements equal to the number of neighbours (one per neighbour). - Adding an edge can be done easily, by appending the neighbour(s) in the corresponding list(s). Disadvantages . - Edge lookup is slow, in the worst case being necessary to traverse all the elements of a node's list. - Erasing an edge is just as slow as the lookup. - If the graph is dense, the adjacency lists are probably not as good as an adjacency matrix. - Implementing them is slightly more difficult than an adjacency matrix. Even so, we still recommend them in most of the cases. # . | Adjacency List with Set (Hash Table) | . When to Use set in Adjacency List? - You need sorted neighbors. - Duplicate edges must be prevented without extra checks. - Graphs have moderate sizes since set is slightly slower and memory-intensive. For other cases, consider using vector for adjacency lists for faster operations and reduced memory usage. - Compared to a simple vector, a set uses more memory due to the underlying balanced tree structure. &lt;/pre&gt; ```cpp vector&lt;set&gt; /*or*/ setadj[N] ``` ```cpp //for undirected graph const int N = 1e5 + 5; // Maximum number of vertices set adj[N]; // Adjacency list using set void addEdge(int u, int v) { adj[u].insert(v); // Add v to the adjacency list of u adj[v].insert(u); // Add u to the adjacency list of v (since it's undirected) } void printGraph(int nodes) { for (int i = 0; i &lt; nodes; i++) { cout &lt;&lt; i &lt;&lt; \": \"; for (int neighbor : adj[i]) { cout &lt;&lt; neighbor &lt;&lt; \" \"; } cout &lt;&lt; endl; } } int main() { int nodes = 5; // Number of vertices addEdge(0, 1); addEdge(0, 2); addEdge(1, 3); addEdge(3, 4); cout &lt;&lt; \"Adjacency List:\" &lt;&lt; endl; printGraph(nodes); return 0; } ``` # - Edge List Representation (We use this in weighted undirected graphs when we want to sort the edges by weight (ex. DSU) ) An edge list contains all edges of a graph in some order. This is a convenient way to represent a graph if the algorithm processes all edges of the graph and it is not needed to find edges that start at a given node. ```cpp vector&lt;pair&lt;int,int&gt;&gt; edges; //where each pair (a, b) denotes that there is an edge from node a to node b. edges.push_back({1,2}); edges.push_back({2,3}); edges.push_back({2,4}); edges.push_back({3,4}); edges.push_back({4,1}); //If the graph is weighted, vector&lt;tuple&lt;int,int,int&gt;&gt; edges;//(a,b,w) edges.push_back({1,2,5}); edges.push_back({2,3,7}); edges.push_back({2,4,6}); edges.push_back({3,4,5}); edges.push_back({4,1,2}); ``` ```cpp //edge list representation struct Edge { int a, b, w; Edge(int start, int end, int weight): a(start), b(end), w(weight) { } bool operator&lt;(const Edge &amp; e) const { // sort order is ascending, by weight // to sort in descending order, just negate the value of the compare function., ! return w &lt; e.w; } }; int n, m; // number of nodes and edges vector edges; int main() { cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; m; i++) { // for each of the m edges int a, b, w; cin &gt;&gt; a &gt;&gt; b &gt;&gt; w; // a--; b--; // subtract 1 to maintain zero-indexing of vertices edges.push_back(Edge(a, b, w)); // add the edge to the list } sort(edges.begin(), edges.end()); for(auto x:edges){ auto [a,b,w] = x; cout&lt;&lt;a&lt;&lt;\" \"&lt;&lt;b&lt;&lt;\" \"&lt;&lt;w&lt;&lt;endl; } return 0; } ``` Advantages of Edge List - Simple to Implement: Easy to create and manipulate. - Efficient for Sparse Graphs: Works well when the number of edges is much smaller than n2. - Kruskal's Algorithm: Directly supports edge-based algorithms like MST using Kruskal. Disadvantages of Edge List - Inefficient for Adjacency Queries: Checking if two vertices are connected is O(E) since all edges must be traversed. - Memory Usage: For dense graphs, adjacency matrices or lists are more efficient in terms of storage and access time. # ###### Complexity in Graphs - Adding O(logN), Checking O(logN), Listing O(N) -&gt; Memory using O(M) . https://www.hello-algo.com/en/chapter_graph/graph_operations/#922-implementation-based-on-adjacency-list (n = no. of vertices/nodes, m = no. of edges) ![comparison](https://i.ibb.co.com/cgG3s7s/Screenshot-from-2024-11-28-03-58-13.png) # example: - [Aizu-ALDS1_11_A_Graph](./Aizu_ALDS1_11_A_Graph.cpp) There are two standard ways to represent a graph G=(V,E), where V is a set of vertices and E is a set of edges; Adjacency list representation and Adjacency matrix representation. Write a program which reads a directed graph G represented by the adjacency list, and prints its adjacency-matrix representation. (Convert Adjacency List to Adjacency Matrix) . - [292B_Network Topology](./292B_Network%20Topology.cpp) A bus is a connected graph that is the only path, that is, the graph where all nodes are connected with two other ones except for some two nodes that are the beginning and the end of the path. A ring is a connected graph, where all nodes are connected with two other ones. A star is a connected graph, where a single central node is singled out and connected with all other nodes. - [leetcode_1791. Find Center of Star Graph](./leetcode1791_Find%20Center%20of%20Star%20Graph.cpp) There is an undirected star graph consisting of n nodes labeled from 1 to n. A star graph is a graph where there is one center node and exactly n - 1 edges that connect the center node with every other node. You are given a 2D integer array edges where each edges[i] = [ui, vi] indicates that there is an edge between the nodes ui and vi. Return the center of the given star graph. - [leetcode1557_Minimum Number of Vertices to Reach All Nodes.cpp](./leetcode1791_Find%20Center%20of%20Star%20Graph.cpp) Given a directed acyclic graph, with n vertices numbered from 0 to n-1, and an array edges where edges[i] = [fromi, toi] represents a directed edge from node fromi to node toi. Find the smallest set of vertices from which all nodes in the graph are reachable. It's guaranteed that a unique solution exists. Notice that you can return the vertices in any order. - [330B_Road Construction](./330B_Road%20Construction.cpp) A country has n cities. Initially, there is no road in the country. One day, the king decides to construct some roads connecting pairs of cities. Roads can be traversed either way. He wants those roads to be constructed in such a way that it is possible to go from each city to any other city by traversing at most two roads. You are also given m pairs of cities — roads cannot be constructed between these pairs of cities. Your task is to construct the minimum number of roads that still satisfy the above conditions. The constraints will guarantee that this is always possible. -&gt; like star topology . # . ",
    "url": "/15_graph_theory/1_basic_graphs/",
    
    "relUrl": "/15_graph_theory/1_basic_graphs/"
  },"26": {
    "doc": "15 graph theory",
    "title": "15 graph theory",
    "content": "https://medium.com/basecs/a-gentle-introduction-to-graph-theory-77969829ead8 Non-Linear Data Structures (Trees, Graphs) . Fundamental Characteristics: - their data doesn’t follow an order — at least, not an obvious numerical one, like we see in arrays or linked lists. Basic Graphs . # . Application of Graph . Graph Traversals . | DFS | . - graph can have cycle (unlike tree), so we need a visited[] array . void dfs(int cur, vector&lt;vector&lt;int&gt;&gt;&amp;edges, vector&lt;bool&gt;&amp;vis) { vis[cur] = true; cout &lt;&lt; cur &lt;&lt; \" \"; for (auto e : edges[cur]) { if (!vis[e]) { dfs(e, edges, vis); } } } void solve() { int n, m; cin &gt;&gt; n &gt;&gt; m; // no. of nodes, edges vector&lt;vector&lt;int&gt;&gt;edges(n, vector&lt;int&gt;()); for (int i = 0; i &lt; m; i++) { int u, v; cin &gt;&gt; u &gt;&gt; v; //0 based indexing edges[u].push_back(v); edges[v].push_back(u); } vector&lt;bool&gt;visited(n, false); dfs(0, edges, visited); } . | BFS (Single source and Multi source) | . - Uses a queue to explore nodes level by level. void bfs(int start, vector&lt;vector&lt;int&gt;&gt;&amp; edges, vector&lt;bool&gt;&amp; vis) { queue&lt;int&gt; q; q.push(start); vis[start] = true; while (!q.empty()) { int cur = q.front(); q.pop(); cout &lt;&lt; cur &lt;&lt; \" \"; for (auto e : edges[cur]) { if (!vis[e]) { vis[e] = true; q.push(e); } } } } void solve() { int n, m; cin &gt;&gt; n &gt;&gt; m; // number of nodes and edges vector&lt;vector&lt;int&gt;&gt; edges(n); for (int i = 0; i &lt; m; i++) { int u, v; cin &gt;&gt; u &gt;&gt; v; // 0-based indexing edges[u].push_back(v); edges[v].push_back(u); } vector&lt;bool&gt; visited(n, false); for (int i = 0; i &lt; n; i++) { if (!visited[i]) { bfs(i, edges, visited); } } } . Application of Traversals . - Connected Components - Path Construction - Cycle Detection - Shortest Path (unweighted graph, ex. cses1193) . Topological Sort and Strongly Connected Components are only for Directed Graph . Connected Components . //connected components void bfs(int start, vector&lt;vector&lt;int&gt;&gt;&amp; edges, vector&lt;bool&gt;&amp; vis, vector&lt;int&gt;&amp; component) { queue&lt;int&gt; q; q.push(start); vis[start] = true; while (!q.empty()) { int cur = q.front(); q.pop(); component.push_back(cur); for (auto e : edges[cur]) { if (!vis[e]) { vis[e] = true; q.push(e); } } } } void solve() { int n, m; cin &gt;&gt; n &gt;&gt; m; // number of nodes and edges vector&lt;vector&lt;int&gt;&gt; edges(n); for (int i = 0; i &lt; m; i++) { int u, v; cin &gt;&gt; u &gt;&gt; v; // 0-based indexing edges[u].push_back(v); edges[v].push_back(u); } vector&lt;bool&gt; visited(n, false); vector&lt;vector&lt;int&gt;&gt; connectedComponents; for (int i = 0; i &lt; n; i++) { if (!visited[i]) { vector&lt;int&gt; component; bfs(i, edges, visited, component); connectedComponents.push_back(component); } } // Output the connected components cout &lt;&lt; \"Connected Components:\\n\"; for (auto&amp; component : connectedComponents) { for (int node : component) { cout &lt;&lt; node &lt;&lt; \" \"; } cout &lt;&lt; \"\\n\"; } } /* 1 2 3 4 5 6 7 8 9 10 */ . example: . | cses1666_Building Roads . Byteland has n cities, and m roads between them. The goal is to construct new roads so that there is a route between any two cities. Your task is to find out the minimum number of roads required, and also determine which roads should be built. no. of connected component - 1 . | . Cycles Detecting . //if graph is disconnected then run dfs for every node int n; vector&lt;vector&lt;int&gt;&gt; adj; vector&lt;int&gt; color, parent; int cycle_start, cycle_end; bool dfs(int v) { color[v] = 1; for (int u : adj[v]) { if (color[u] == 0) { parent[u] = v; if (dfs(u)) return true; } else if (color[u] == 1) { cycle_end = v; cycle_start = u; return true; } } color[v] = 2; return false; } void find_cycle() { color.assign(n, 0); parent.assign(n, -1); cycle_start = -1; for (int v = 0; v &lt; n; v++) { if (color[v] == 0 &amp;&amp; dfs(v)) break; } if (cycle_start == -1) { cout &lt;&lt; \"Acyclic\\n\"; } else { vector&lt;int&gt; cycle; for (int v = cycle_end; v != cycle_start; v = parent[v]) cycle.push_back(v); cycle.push_back(cycle_start); cycle.push_back(cycle_end); // Add cycle end for clarity reverse(cycle.begin(), cycle.end()); cout &lt;&lt; \"Cycle found: \"; for (int v : cycle) cout &lt;&lt; v &lt;&lt; \" \"; cout &lt;&lt; \"\\n\"; } } int main() { cin &gt;&gt; n; adj.resize(n); int m; cin &gt;&gt; m; // number of edges for (int i = 0; i &lt; m; i++) { int u, v; cin &gt;&gt; u &gt;&gt; v; adj[u].push_back(v); } find_cycle(); } //using bfs . Path Construction . vector&lt;int&gt; find_path(int start, int end, vector&lt;vector&lt;int&gt;&gt;&amp; adj, int n) { vector&lt;int&gt; parent(n, -1); queue&lt;int&gt; q; vector&lt;bool&gt; visited(n, false); q.push(start); visited[start] = true; while (!q.empty()) { int u = q.front(); q.pop(); if (u == end) break; for (int v : adj[u]) { if (!visited[v]) { visited[v] = true; parent[v] = u; q.push(v); } } } // Reconstruct the path vector&lt;int&gt; path; if (!visited[end]) { cout &lt;&lt; \"No path found\\n\"; return path; } for (int v = end; v != -1; v = parent[v]) { path.push_back(v); } reverse(path.begin(), path.end()); return path; } int main() { int n, m; cin &gt;&gt; n &gt;&gt; m; // number of nodes and edges vector&lt;vector&lt;int&gt;&gt; adj(n); for (int i = 0; i &lt; m; i++) { int u, v; cin &gt;&gt; u &gt;&gt; v; adj[u].push_back(v); } int start, end; cin &gt;&gt; start &gt;&gt; end; vector&lt;int&gt; path = find_path(start, end, adj, n); if (!path.empty()) { cout &lt;&lt; \"Path found: \"; for (int node : path) { cout &lt;&lt; node &lt;&lt; \" \"; } cout &lt;&lt; \"\\n\"; } } . Shortest Path for Unweighted Graph . example: . | cses1193_Labyrinth . You are given a map of a labyrinth, and your task is to find a path from start to end. You can walk left, right, up and down. - dfs works for the path construction (doesn't give shortest path) - bfs for shortest path (because it goes to level-wise) unweighted graph shortest path . | . Bipartite Graphs . https://cp-algorithms.com/graph/bipartite-check.html . A bipartite graph is a graph whose vertices can be divided into two disjoint sets so that every edge connects two vertices from different sets (i.e. there are no edges which connect vertices from the same set). Properties . You are given an undirected graph. Check whether it is bipartite, and if it is, output its sides. - Odd Length Cycles (can't be) - A Tree is always bipartile . //bipartile check int n; vector&lt;vector&lt;int&gt;&gt; adj; vector&lt;int&gt; side(n, -1); bool is_bipartite = true; queue&lt;int&gt; q; for (int st = 0; st &lt; n; ++st) { if (side[st] == -1) { q.push(st); side[st] = 0; while (!q.empty()) { int v = q.front(); q.pop(); for (int u : adj[v]) { if (side[u] == -1) { side[u] = side[v] ^ 1; q.push(u); } else { is_bipartite &amp;= side[u] != side[v]; } } } } } cout &lt;&lt; (is_bipartite ? \"YES\" : \"NO\") &lt;&lt; endl; . example: . # . Topological Sorting (for only DAG) . - it is a linear ordering of vertices such that if there is an edge between u to v, then u should come before v. - there can be multiple topological sort in graph. - topological sort is valid only directed ***asylic*** graph(DAG). https://yuminlee2.medium.com/topological-sort-cf9f8e43af6a . | DFS Method | . - if we see the last element of the topo. sort, then it must have some edges coming towards it. - deepest node possible in the DFS. //code for topological sort using DFS void dfs(int node, vector&lt;int&gt;&amp;vis, stack&lt;int&gt;&amp;st, vector&lt;int&gt;adj[]) { vis[node] = 1; for (auto it : adj[node]) { if (vis[it] == 0) { dfs(it, vis, st, adj); } } st.push(node); } void topologicalSort() { int n, m; //no. of vertices, edges cin &gt;&gt; n &gt;&gt; m; vector&lt;int&gt; adj[n + 1]; //adjacency list for (int i = 0; i &lt; m; i++) { int u, v; cin &gt;&gt; u &gt;&gt; v; adj[u].push_back(v); } vector&lt;int&gt;vis(n + 1, 0); stack&lt;int&gt;st; for (int i = 1; i &lt;= n; i++) { if (vis[i] == 0) { dfs(i, vis, st, adj); } } while (st.empty() == false) { cout &lt;&lt; st.top() &lt;&lt; \" \"; st.pop(); } cout &lt;&lt; endl; } . | BFS Method (Kahn’s Algorithm) | . - if node has indegree zero(not coming any edges), then it has complete changes to be at the first position at topo. sort. - calculate indegree of each nodes. - every time go to that node that has indegree zero, and then reduced by one every connected node for that parent node. //code for kahn's algorithm void topoSort(int node, vector&lt;int&gt;&amp;indeg, vector&lt;int&gt;&amp;topo, vector&lt;int&gt;adj[], vector&lt;int&gt;&amp;vis) { vis[node] = 1; queue&lt;int&gt;q; q.push(node); while (q.empty() == false) { int x = q.front(); q.pop(); topo.push_back(x); for (auto it : adj[x]) { indeg[it]--; if (indeg[it] == 0) { q.push(it); vis[it] = 1; } } } } void kahns_algo() { int n, m; //no. of vertices, edges cin &gt;&gt; n &gt;&gt; m; vector&lt;int&gt; adj[n + 1]; //adjacency list vector&lt;int&gt; indeg(n + 1, 0); //indegree for (int i = 0; i &lt; m; i++) { int u, v; cin &gt;&gt; u &gt;&gt; v; adj[u].push_back(v); indeg[v]++; } vector&lt;int&gt;vis(n + 1, 0); vector&lt;int&gt;topo; for (int i = 1; i &lt;= n; i++) { if (indeg[i] == 0 and vis[i] == 0) { topoSort(i, indeg, topo, adj, vis); } } for (auto x : topo) { cout &lt;&lt; x &lt;&lt; \" \"; } cout &lt;&lt; endl; } . example: . | 510C Fox And Names | . Lexicographical order is defined in following way. When we compare s and t, first we find the leftmost position with differing characters: si ≠ ti. If there is no such position (i. e. s is a prefix of t or vice versa) the shortest string is less. Otherwise, we compare characters si and ti according to their order in alphabet. if there exists an order of letters in Latin alphabet such that the names on the paper she is submitting are following in the lexicographical order. If so, you should find out any such order as a permutation of characters 'a'-'z' n number of name given, we have find a dictionary order according to the number given. if we not find any such then print impossible. ex. - (r, ra , raj) no order required then ans -&gt; a - z - (raj, ra ,r) above should be smaller than lower but not in here -&gt; impossible(-1) - first should be lower length - compare two same length string, above should be come first than next in dictionary order. - (two string at a time) if same then go to next char, if not then, if we make edges between upper char to below char it must be follow topological_sort, if one is end before done, still it's bigger than other -&gt; -1 - also we have a cycle in this graph -&gt; -1 . Graph Connectivity . Strongly Connected Components (Kosaraju’s Algorithm) - SCC . | Kosaraju’s Algorithm | . - divide graph into some components - each components, we can visit every node in a component from any node of the component. -&gt; is called SCC quetions like in SCC : -&gt; how many components are there? -&gt; what are the nodes in there in the same componet. Theory: . - SCC1 -&gt; SCC2 -&gt; SCC3 ... - using dfs in scc1, we can visit every nodes from that components. than scc2,scc3... - using dfs bottom most elements are the deepest node - if we reverse all edges, then SCC3 -&gt; SCC@ -&gt; SCC1 - then if we start dfs using the top element (swallowest node) in that previous stack, we found each components separately. (each dfs traversal elements, if already visited encounter) - looks like topo. sort, but it actually not. //code for scc_kosaraju's algorithm stack&lt;int&gt;st; vector&lt;int&gt;temp; vector&lt;vector&lt;int&gt;&gt;scc; void dfs1(int node, vector&lt;int&gt;adj[], vector&lt;int&gt;&amp;vis) {//pre dfs vis[node] = 1; for (auto it : adj[node]) { if (vis[it] == 0) { dfs1(it, adj, vis); } } st.push(node); } void dfs2(int node, vector&lt;int&gt;tadj[], vector&lt;int&gt;&amp;vis) {//post dfs vis[node] = 1; temp.push_back(node); for (auto it : tadj[node]) { if (vis[it] == 0) { dfs2(it, tadj, vis); } } } void kosarajus_algo() { int n, m; //no. of vertices, edges cin &gt;&gt; n &gt;&gt; m; vector&lt;int&gt; adj[n + 1], tadj[n + 1]; //adjacency list, transfer adjacency list for (int i = 0; i &lt; m; i++) { int u, v; cin &gt;&gt; u &gt;&gt; v; adj[u].push_back(v); tadj[v].push_back(u); } vector&lt;int&gt;vis(n + 1, 0); for (int i = 1; i &lt;= n; i++) { if (vis[i] == 0) { dfs1(i, adj, vis); } } fill(vis.begin(), vis.end(), 0); while (st.empty() == false) { int node = st.top(); st.pop(); if (vis[node] == 0) { dfs2(node, tadj, vis); scc.push_back(temp); temp.clear(); } } cout &lt;&lt; scc.size() &lt;&lt; endl;//total components for (auto it : scc) { for (auto x : it) {//each component has cout &lt;&lt; x &lt;&lt; \" \"; } cout &lt;&lt; endl; } cout &lt;&lt; endl; } . example: . | cses1682_Flight Routes Check | . There are n cities and m flight connections, your task is to check if you can travel from any city to any other city using the available flights. if possible -&gt; YES, if not -&gt; NO and two cities that can't be travelled. - possible if no. of scc == 1 - if no then print two different scc members . | cses1683_Planets and Kingdoms | . A game has n planets, connected by m teleporters, two planets a and b belong to the same kingdom if there is a route both from (a-&gt;b and b-&gt;a) print number of kingdoms and (each planet a kingdom) . | cses1686_Coin Collector.cpp | . Undirected Graph . DSU - Disjoint Set Union . cp algorithm . | When is DSU required? . we are solving some node and edges problems using dsu. ex. node a and b in same components? # bruteforces (O(N))- single query travers(bfs) in component 1 which have node a, if we find b in that component also - yes. # multiple query -O(NQ)-using bruteforces-give TLE that time dsu come to play. - consider we are not constructing graph over here. - there is no disconnect query in dsu. | . | How to find parent? (Path Compression Technique) . every time connect node to the ultimate parrent (not in immidiate parent) - is called path compression. | find parent (DP kind of approach O(4x)-&gt;O(1)) . int find_parent(int node) { if (node == parent[node]) return node; return parent[node] = find_parent(parent[node]); } . | . To optimize(&lt;O(N)) union set(that will store each parrent) operation, we have two method, . # connecting smaller to bigger (reduce dept of the tree) # don't relay on height because height is changing everytime. https://takeuforward.org/data-structure/disjoint-set-union-by-rank-union-by-size-path-compression-g-46/ . Both of them perform similarly . | Union by rank (not always increase) . The rank of a node generally refers to the distance (the number of nodes including the leaf node) between the furthest leaf node and the current node. Basically rank includes all the nodes beneath the current node. | Union by size (always increasing, so we have to maintain size array) . This is as same as the Union by rank method except this method uses the size to compare the components while connecting. That is why we need a ‘size’ array of size N(no. of nodes) instead of a rank array. The size array will be storing the size for each particular node i.e. size[i] will be the size of the component starting from node i. Typically, the size of a node refers to the number of nodes that are connected to it. | . // code for DSU class dsu { vector&lt;int&gt; parent, size, rank; public: dsu(int n) { for (int i = 0; i &lt;= n; i++) { parent.push_back(i); size.push_back(1); rank.push_back(0); } } int findPar(int node) { if (parent[node] == node) { return node; } //path compression return parent[node] = findPar(parent[node]); } void unionSize(int u, int v) { int pu = findPar(u); int pv = findPar(v); if (pu == pv) { return; } //attach smaller to bigger if (size[pu] &lt; size[pv]) { parent[pu] = pv; size[pv] += size[pu]; } else { parent[pv] = pu; size[pu] += size[pv]; } } void unionRank(int u, int v) { int pu = findPar(u); int pv = findPar(v); if (pu == pv) { return; } if (rank[pu] == rank[pv]) { parent[pu] = pv; rank[pu]++; } else if (rank[pu] &lt; rank[pv]) { parent[pu] = pv; } else { parent[pv] = pu; } } }; . example: . | codechef_ABROADS_Ancient Berland Roads | . | spoj_CLFLARR - COLORFUL ARRAY . given n unpainted elements(initialy have 0). q query, each (l r c) index l to r color it with c (each new color overrides it's previous color) output the color of all elements after all query processed. | . MST . - mostly use krushkal's algorithms . Kruskal’s Algorithm (application of DSU) . - used to find minimum spanning tree (MST) - graph is weighted - we have to connect (n-1) edges - begin with least weighted edges - if already connected, then not construct anything (remove edge) . //dsu code first then other void krushkalAlgo() { int n, m; //n = size of dsu, m = node cin &gt;&gt; n &gt;&gt; m; vector&lt;pair&lt;int, pair&lt;int, int&gt;&gt;&gt;edges; for (int i = 0; i &lt; m; i++) { int u, v, w; //connected node and their weight cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; edges.push_back({w, {u, v}}); } sort(edges.begin(), edges.end());//sort by weight dsu d(n); int sum = 0; for (auto it : edges) { int w = it.first; int u = it.second.first; int v = it.second.second; if (d.findPar(u) != d.findPar(v)) { sum += w; d.unionRank(u, v); cout &lt;&lt; u &lt;&lt; \" \" &lt;&lt; v &lt;&lt; \" \" &lt;&lt; w &lt;&lt; endl; } } cout &lt;&lt; sum &lt;&lt; endl; } . example: . | 25D_Roads not only in Berland . First of all, it was decided to build new roads so that from each city of Berland and neighboring countries it became possible to reach all the others. There are n cities in Berland and neighboring countries in total and exactly (n - 1) two-way roads. **build a new road it has to close some of the existing ones. Every day it is possible to close one existing road and immediately build a new one. **determine how many days would be needed to rebuild roads so that from each city it became possible to reach all the others. | . Prim’s Algorithm . - get the sum of edges of mst - get the edges as well . Theory: . - weighted undirected graph - we can go each node to all other nodes - maintain two things - visited array(initialy all 0) - priority queue (min at top)(each - weight,node,parent) - in p_queue min is out first - initial first pq have wt-0, node-x, parent-0 . to . //code for prim's algorithm int n, m; cin &gt;&gt; n &gt;&gt; m; //num of nodes and edges vector&lt;pair&lt;int, int&gt;&gt; adj[n + 1];// adjacent list -&gt; vector of pair //vector&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt; adj(n + 1); for (int i = 0; i &lt; m; i++) { int u, v, w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; adj[u].push_back({v, w}); adj[v].push_back({u, w}); } priority_queue&lt;vector&lt;int&gt;&gt;pq; vector&lt;int&gt;vis(n + 1, 0); pq.push({0, 1, 0}); //wt, node, par int sum = 0; vector&lt;pair&lt;int, int&gt;&gt;edges; while (pq.empty() == false) { int wt = -pq.top()[0]; int node = pq.top()[1]; int par = pq.top()[2]; pq.pop();//pop first if (vis[node] == 1) continue;//if already visited vis[node] = 1; sum += wt; if (par != 0) { edges.push_back({node, par}); } for (auto it : adj[node]) { if (vis[it.first] == 0) { pq.push({ -it.second, it.first, node});// neg because of min heap } } } cout &lt;&lt; sum &lt;&lt; endl; for (auto it : edges) { cout &lt;&lt; it.first &lt;&lt; \" \" &lt;&lt; it.second &lt;&lt; endl; } . example: . 1624G_MinOr Tree . # find mst such that their bitwise or as minimum as possible we have to iterate (msb to lsb) bit and check that if this bit can be unset in the answer (try to remove all edges with this bit set) and check the no. of components -&gt; 1 can be done (more than one can't be done) . Shortest Paths . | Dijkstra’s is more common than bellman ford or floyd warshall | . single source shortest path . | Dijkstra’s Algorithm (non-negative weight edges) . | . - it's a single source shortest path algorithm - non-negative edge weights - works both directed and undirected graph - find shortest path from given node to every other nodes . Steps: . - mark distance of given node = 0, all other node distance = infinity - push node into priority queue (small value at top) - pop small then visit it's neighbour node and update there distance - then update next node (using small distance) - on every iteration the marked vertex is the one that can never have a better distance later on. //code for dijkstra's algorithm //using set void dijkstras_algo_using_set(int src, int n, vector&lt;vector&lt;pair&lt;int, ll&gt;&gt;&gt; &amp;edges, vector&lt;ll&gt;&amp;dist) { fill(dist.begin(), dist.end(), LLONG_MAX); vector&lt;bool&gt;marked(n, false); dist[src] = 0; set&lt;pair&lt;ll, int&gt;&gt;toExplore; //weight,node toExplore.insert({0LL, src}); while (toExplore.size() &gt; 0) { pair&lt;ll, int&gt;top = *toExplore.begin(); toExplore.erase(top); int poppedNode = top.second; ll distSoFar = top.first; marked[poppedNode] = true; for (auto i : edges[poppedNode]) { int node = i.first; ll addedDist = i.second; if (marked[node]) { continue; } if (dist[node] &gt; distSoFar + addedDist) { toExplore.erase({dist[node], node}); dist[node] = distSoFar + addedDist; toExplore.insert({dist[node], node}); } } } } . //using priority queue //recomanded O((n+m)logn) void dijkstras_algo_using_priority_queue(int src, int n, vector&lt;vector&lt;pair&lt;int, ll&gt;&gt;&gt; &amp;edges, vector&lt;ll&gt;&amp;dist, vector&lt;int&gt;&amp;parent) { dist.assign(n, LLONG_MAX); // parent.assign(n,-1); //Retrieving the shortest path dist[src] = 0; priority_queue&lt;pair&lt;ll, int&gt;, vector&lt;pair&lt;int, ll&gt;&gt;, greater&lt;pair&lt;ll, int&gt;&gt;&gt;q; q.push({0LL, src}); while (!q.empty()) {// O(N) pair&lt;ll, int&gt;top = q.top(); q.pop();//O(logN) int poppedNode = top.second; ll distSoFar = top.first; if (distSoFar != dist[poppedNode]) { continue; } for (auto i : edges[poppedNode]) {//O(M) int node = i.first; ll addedDist = i.second; if (dist[node] &gt; distSoFar + addedDist) { dist[node] = distSoFar + addedDist; //parent[node]=poppedNode; q.push({dist[node], node});//O(logN) } } } } // get shortest path void getPath(int node, vecctor&lt;int&gt;&amp;parent) { while (node != -1) { cout &lt;&lt; node &lt;&lt; \" \"; node = parent[node]; } } . | Dijkstra’s Tree | . | Number of shortest paths to every node | . ## . | Bellman Fort Algorithm (work with negative weight edges) . | . - single source shortest path algorithm - works in negative edge weight(directed) but **not in negative cycles** - using to find negative cycles - using the principal of mathematical induction - algorithm goes upto n-1 . Theory: . - after k iterations, all node which require &lt;=k edges in the minimum path would have their final answeer. - each iteration go each node and relaxed it . //code for bellman-ford void BellmanFord(int n, int src, vector&lt;pair&lt;int, ll&gt;&gt; *edges, vector&lt;ll&gt;&amp; dist, set&lt;int&gt;&amp; negCycle) { fill(all(dist), INF); dist[src] = 0; vector&lt;pair&lt;ll, pair&lt;int, int&gt;&gt;&gt; e; for (int i = 0; i &lt; n; i++) { for (auto j : edges[i]) { e.pb({j.ss, {i, j.ff}}); } } for (int i = 0; i &lt; n - 1; i++) { for (auto j : e) { dist[j.ss.ss] = min(dist[j.ss.ss], dist[j.ss.ff] + j.ff); } } //checking negative cycle for (int i = 0; i &lt; n; i++) { for (auto j : e) { if (dist[j.ss.ss] &gt; dist[j.ss.ff] + j.ff) { dist[j.ss.ss] = dist[j.ss.ff] + j.ff; negCycle.insert(j.ss.ss); } } } } . all pair shortest path . Floyd Warshall Algorithm . O(N3) . - use to find all pair shortest path - brute force dp algorithm in graph - directed or undirected weighted graph - cost[i][j] = min cost to travel from i to j - use adjacency matrix (cost matrix) - if no direct path i to j, then cost is infinity - i==j -&gt; 0 - negative cycle can be checked . | two types of adjacency relation . | adjacency list | adjacency matrix | . | . Theory: . - first construct direct path - then construct via path - because of via (i,j and j,i) are same - if column and row are intersect, then those produce same result (column == row) - if better result than previous then update those path . //code for floyd warshall int n, m; cin &gt;&gt; n &gt;&gt; m; //num of nodes and edges int cost[n + 1][n + 1]; for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= n; j++) { if (i == j) cost[i][j] = 0; else { cost[i][j] = INT_MAX; } } } for (int i = 0; i &lt; m; i++) { int u, v, w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; cost[u][v] = min(cost[u][v], w); } for (int k = 1; k &lt;= n; k++) { //O(n*n*n) for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= n; j++) { if (cost[i][k] == INT_MAX || cost[k][j] == INT_MAX) continue; cost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]); } } } for (int i = 1; i &lt; n; i++) { for (int j = 1; j &lt; n; j++) { cout &lt;&lt; cost[i][j] &lt;&lt; \" \"; } cout &lt;&lt; endl; } . LCA (Lowest Common Ancestors) . Eulerian Path . Satisfiability . ",
    "url": "/15_graph_theory/",
    
    "relUrl": "/15_graph_theory/"
  },"27": {
    "doc": "11 string algorithms",
    "title": "11 string algorithms",
    "content": "https://codeforces.com/problemset/problem/2039/B . ",
    "url": "/11_string_algorithms/",
    
    "relUrl": "/11_string_algorithms/"
  },"28": {
    "doc": "13 dp",
    "title": "13 dp",
    "content": "Why dp? . | to optimized brute force | overlapping subproblems -&gt; calculate no. of days b/w date1 &amp; date2 | maximize/minimize some value -&gt; (dp/greedy) | finding number of ways -&gt; find out number of way to go node A to node B and taking modulo 1e9+7 | covering all cases (DP vs Greedy) | check for possibility | . When to need DP? Let’s understand from a problem . | find nth fibonacci number | f(n) = f(n-1)+f(n-2) | f(1) = f(2) = 1 | . Memoization . | Why calculate f(x) again and again when we can calculate it once and use it every time when it is required? -&gt; Check if f(x) has been calculated - if no, then calculate it and store it somewhere - if yes, then return the value without calculating again | . | without DP -&gt; O(2^N) | . // for n=30 -&gt; functionEntered=1664079 int fibonacci(int n) { if (n &lt;= 1) return n; return fibonacci(n - 1) + fibonacci(n - 2); } int main() { int n = 10; // Change as needed cout &lt;&lt; \"Fibonacci(\" &lt;&lt; n &lt;&lt; \") = \" &lt;&lt; fibonacci(n) &lt;&lt; endl; return 0; } . | with DP -&gt; O(N) -&gt; top down approach -&gt; memoization | . // for n=30 -&gt; functionEntered=57 vector&lt;int&gt; dp(100, -1); int fibonacci(int n) { if (n &lt;= 1) return n; if (dp[n] != -1) return dp[n]; return dp[n] = fibonacci(n - 1) + fibonacci(n - 2); } int main() { int n = 10; // Change as needed cout &lt;&lt; \"Fibonacci(\" &lt;&lt; n &lt;&lt; \") = \" &lt;&lt; fibonacci(n) &lt;&lt; endl; return 0; } . only go down and right . #include &lt;bits/stdc++.h&gt; using namespace std; // Naive recursive approach int minPathSumNaive(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int i, int j) { if (i == grid.size() - 1 &amp;&amp; j == grid[0].size() - 1) { return grid[i][j]; } int down = INT_MAX, right = INT_MAX; if (i &lt; grid.size() - 1) { down = minPathSumNaive(grid, i + 1, j); } if (j &lt; grid[0].size() - 1) { right = minPathSumNaive(grid, i, j + 1); } return grid[i][j] + min(down, right); } // Dynamic Programming approach int minPathSumDP(vector&lt;vector&lt;int&gt;&gt;&amp; grid) { int n = grid.size(); if (n == 0) return 0; int m = grid[0].size(); vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt;(m, 0)); dp[n - 1][m - 1] = grid[n - 1][m - 1]; // Fill last row from right to left for (int j = m - 2; j &gt;= 0; --j) { dp[n - 1][j] = grid[n - 1][j] + dp[n - 1][j + 1]; } // Fill last column from bottom to top for (int i = n - 2; i &gt;= 0; --i) { dp[i][m - 1] = grid[i][m - 1] + dp[i + 1][m - 1]; } // Fill remaining cells for (int i = n - 2; i &gt;= 0; --i) { for (int j = m - 2; j &gt;= 0; --j) { dp[i][j] = grid[i][j] + min(dp[i + 1][j], dp[i][j + 1]); } } return dp[0][0]; } int main() { vector&lt;vector&lt;int&gt;&gt; grid = { {1, 5, 8}, {6, 2, 7}, {9, 3, 4} }; cout &lt;&lt; \"Naive approach result: \" &lt;&lt; minPathSumNaive(grid, 0, 0) &lt;&lt; endl; cout &lt;&lt; \"DP approach result: \" &lt;&lt; minPathSumDP(grid) &lt;&lt; endl; return 0; } . Important Terminology . | State: A subproblem defined by parameters (e.g., dp[i][j]). | Transition: A rule that connects states (e.g., dp[i][j] = …). | Core Principle: States and transitions work together to solve complex problems efficiently by breaking them into overlapping subproblems and reusing solutions. | . Two types of DP . | Buttom Up | Top Down | . ",
    "url": "/13_dp/",
    
    "relUrl": "/13_dp/"
  },"29": {
    "doc": "3 sliding window",
    "title": "3 sliding window",
    "content": "1. Fixed Size Sliding Window 2. Variable Size Sliding Window (2 Pointer) Used is array based problem, basically is subarray . Current Window must get enough info to get the ans for that window . ",
    "url": "/08_optimizations/3_sliding_window/",
    
    "relUrl": "/08_optimizations/3_sliding_window/"
  },"30": {
    "doc": "08 optimizations",
    "title": "08 optimizations",
    "content": "Prefix Sum . example: . | CSUMQ - Cumulative Sum Query | . You are given a list of N numbers and Q queries. Each query is specified by two numbers i and j; the answer to each query is the sum of every number between the range [i, j] (inclusive). Note : 0 Based Indexing . | https://codeforces.com/contest/2075/problem/C | . 2D Prefix Sum / Prefix Sum of Matrix . https://www.geeksforgeeks.org/prefix-sum-2d-array/ . - prefix[i][j] = ​prefix[i−1][j]+prefix[i][j−1] − prefix[i−1][j−1]+arr[i][j]​ - Corner Cases (First row and first column) If i = 0 and j = 0 psa[i][j] = a[i][j] If i = 0 and j &gt; 0 psa[i][j] = psa[i][j-1] + a[i][j] If i &gt; 0 and j = 0 psa[i][j] = psa[i-1][j] + a[i][j] . | Given n*m matrix (n,m&lt;=1000), and q queries, we have to find sum of submatrix in each query | . using ll = long long; const int N = 1e3 + 9; int a[N][N]; ll pref[N][N]; int32_t main() { ios_base::sync_with_stdio(false); cin.tie(NULL); int n, m; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= m; j++) { cin &gt;&gt; a[i][j]; } } for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= m; j++) { pref[i][j] = pref[i - 1][j] + pref[i][j - 1] - pref[i - 1][j - 1] + a[i][j]; } } int q; cin &gt;&gt; q; while (q--) { int x1, y1, x2, y2; cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2; ll ans = pref[x2][y2] - pref[x1 - 1][y2] - pref[x2][y1 - 1] + pref[x1 - 1][y1 - 1]; cout &lt;&lt; ans &lt;&lt; endl; } return 0; } . 3D Prefix Sum . Two Pointer . 1. Adhoc Two Pointer 2. Good Segment Category* . https://usaco.guide/silver/two-pointers?lang=cpp . | Iterating two monotonic pointers across an array to search for a pair of indices satisfying some condition in linear time. | Each variable moves in a single direction, and they only traverse the array a single time. Therefore, time complexity will be O(N+M) . | . Optimization_Technique . Binary Search on Array O(NlogN)-&gt; using two pointer O(N) Binary Search &lt;-&gt; Two Pointer . https://www.geeksforgeeks.org/two-pointers-technique/ . Variable Size Sliding Window (Also known as two pointer) . The general steps to solve these questions by following below steps: . In this type of sliding window problem, we increase our right pointer one by one till our condition is true. At any step if our condition does not match, we shrink the size of our window by increasing left pointer. Again, when our condition satisfies, we start increasing the right pointer and follow step 1. We follow these steps until we reach to the end of the array. Good Segment Technique Tricks . *If segment within [L,R] is good, segment enclosed within will be good. -&gt; Increasing, Decreasing Technique *Do not use binary search in that problem *Good segment-&gt; multiple of (j-i+1) for every i in (longest_subarray_length_sum&lt;=k) . Some Technique . | Given two sorted array, we have to merge it within O(N+M) and makes array sorted. | . vector&lt;int&gt; merge(vector&lt;int&gt;&amp;l, vector&lt;int&gt;&amp;r) { int n = l.size(), m = r.size(); vector&lt;int&gt;ans; int i = 0, j = 0; while (i &lt; n and j &lt; m) { if (l[i] &lt; r[j]) { ans.push_back(l[i++]); } else { ans.push_back(r[j++]); } } while (i &lt; n) ans.push_back(l[i++]); while (j &lt; m) ans.push_back(r[j++]); return ans; } . | Given two sorted array, we have to find a[i] + b[i] = x | . //using two pointer O(N+M)... using bs it's go to O(NlogN) for (int i = 0, j = m - 1; i &lt; n; i++) // O(N){ int rem = x - a[i]; while (j &gt;= 0 and b[j] &gt; rem){ // O(M) in total j--; } if (j &gt;= 0 and b[j] == rem){ cout &lt;&lt; i &lt;&lt; \" \" &lt;&lt; j &lt;&lt; endl; return; } } . https://usaco.guide/CPH.pdf#page=87 . | Subarray sum -&gt;(Given an array of N (1&lt;=N&lt;=1e5 ) positive elements, find a contiguous subarray that sums to X.) | . A[] ={1 3 2 5 1 1 2 3} , x = 8 Naive Method : Find all subarray and compare to x, but that give O(N\\*N). This problem can be solved in O(n) time by using the two pointers method . The running time of the algorithm depends on the number of steps the right pointer moves. we know that the pointer moves a total of O(n) steps during the algorithm, because it only moves to the right. Pros and Cons: f(A[i]&lt;0) then it will give WRONG ANSWER The above solution does not work for arrays with negative numbers. Then, We use [Hashing + Prefix Sum] O(N) time and O(N) Space . https://darrenyao.com/usacobook/cpp.pdf#page=70 . | 2SUM problem (Given an array of N elements (1&lt;=N&lt;=1e5 ), find two elements that sum to X) | . We can solve this problem using two pointers; sort the array, then set one pointer at the beginning and one pointer at the end of the array. int left = 0; int right = n - 1; while (left &lt; right) { if (arr[left] + arr[right] == x) { break; } else if (arr[left] + arr[right] &lt; x) { left++; } else { right--; } } // if left &gt;= right after the loop ends, no answer exists. | Maximum subarray sum (Given an array of N integers (1&lt;=N&lt;=1e5 ), which can be positive or negative, find the maximum sum of a contiguous subarray) | . It is not solved by two pointers, but it similar to that kind of problem.We can solve this problem using Kadane’s algorithm. //kadane's algorithm int best = 0, current = 0; for (int i = 0; i &lt; n; i++) { current = max(0, current + arr[i]); best = max(best, current); } . | Largest Subarray with sum &lt;=s | . //bruteforce solution O(N*N) int ans = 0; for (int l = 1; l &lt;= n; l++) { int sum = 0; for (int r = l; r &lt;= n; r++) { sum += a[r]; if (sum &lt;= s) { ans = max(ans, r - l + 1); }else{ break; } } } cout &lt;&lt; ans &lt;&lt; endl; //two pointer solution O(2N)-&gt; O(N) -&gt; everytime l is increament by 1 and r is increament by 1 //all value is positive // if [l,r] is good then [l,r-1] or [l+1,r] is also good int ans = 0, r = 1; ll sum = 0; for (int l = 1; l &lt;= n; l++) { while (r &lt;= n and a[r] + sum &lt;= s) { sum += a[r]; r++; } ans = max(ans, r - l); //[l,r-1] is the largest subarray with sum&lt;=s {r-l+1-1} sum -= a[l]; } cout &lt;&lt; ans &lt;&lt; endl; . | Number of Subarray with sum &lt;=s | . int r = 1; ll sum = 0, ans = 0; for (int l = 1; l &lt;= n; l++) { while (r &lt;= n and a[r] + sum &lt;= s) { sum += a[r]; r++; } ans += r - l; //[l,r-1] is the largest subarray with sum&lt;=s {r-l+1-1} sum -= a[l]; } cout &lt;&lt; ans &lt;&lt; endl; . | Number of Subarray with sum &gt;=s | . int r = 1; ll sum = 0, ans = 0; for (int l = 1; l &lt;= n; l++) { while (r &lt;= n and a[r] + sum &lt; s) { sum += a[r]; r++; } ans += n - r + 1; //r is the smallest index in which sum of [l,r-1]&lt;s sum -= a[l]; } cout &lt;&lt; ans &lt;&lt; endl; . | Number of good segment where, in each segment abs(max-min) at most k (&lt;=k) | . //always increase difference //if [l,r] good then [l,r+1] also good using ll = long long; const int N = 1e5 + 9; ll a[N]; struct DS { multiset&lt;ll&gt;ms; DS() {} void insert(ll x) { ms.insert(x); } void erase(ll x) { ms.erase(ms.find(x)); } ll get_max() { return *(--ms.end()); } ll get_min() { return *ms.begin(); } ll get() { return get_max() - get_min(); } } ds; int32_t main() { ios_base::sync_with_stdio(false); cin.tie(NULL); int n; cin &gt;&gt; n; ll k; cin &gt;&gt; k; for (int i = 1; i &lt;= n; i++) { cin &gt;&gt; a[i]; } int r = 1; ll ans = 0; for (int l = 1; l &lt;= n; l++) { while (r &lt;= n) { ds.insert(a[r]); if (ds.get() &gt; k) { ds.erase(a[r]); break; } r++; } ans += r - l; //r - 1 is the maximum index i, such that max(a[l...i])-min(a[l...i])&lt;=k ds.erase(a[l]); } cout &lt;&lt; ans &lt;&lt; endl; return 0; } . example: . 2033D D. Kousuke’s Assignment . Sliding Window . https://usaco.guide/gold/sliding-window?lang=cpp . - A sliding window is a constant-size subarray that moves from left to right through the array. - For each position of the window, we want to compute some information. | Sum of every k length subarray | . int sum = 0; for(int i=1;i&lt;=n;i++){ sum+=a[i]; if(i&gt;=k){ cout&lt;&lt;sum&lt;&lt;\" \"; sum-=a[i-k+1]; } } . | Maximum sum subarray of length k | . struct DS { multiset&lt;ll&gt;ms; DS() {} void insert(ll x) { ms.insert(x); } void erase(ll x) { ms.erase(ms.find(x)); } ll get_max() { return *(--ms.end()); } } ds; for(int i=1;i&lt;=n;i++){ ds.insert(a[i]); if(i&gt;=k){ cout&lt;&lt;ds.get_max()&lt;&lt;\" \"; ds.erase(a[i-k+1]); } } . | Maximum of all subarray of length k . | Number of unique elements in all subarrays of length k . | . Difference Array / Static Range Update . https://codeforces.com/blog/entry/78762 . - perform multiple range update queries where we only need to find the answer after performing all the queries - in difference array, d[i] = a[i] - a[i-1] - original array is the prefix sum of difference array . //finding the difference array from the original array a[0] = 0; for(int i=1;i&lt;=n;i++){ d[i] = a[i] - a[i-1]; } //finding the original array from the difference array for(int i=1;i&lt;=n;i++){ a[i] = a[i-1] + d[i]; } //prefix sum of difference array for(int i=1;i&lt;=n;i++){ p[i] = p[i-1] + d[i]; } //it's the original array for(int i=1;i&lt;=n;i++){ cout&lt;&lt;p[i]&lt;&lt;\" \"; } . | Given an array and q query, each query given l,r,x; (l-&gt;r add x), after all query find the final array | . //naive method O(nq) -&gt; difference array O(n+q) const int N = 1e6 + 9; long long a[N], d[N]; int32_t main() { ios_base::sync_with_stdio(false); cin.tie(NULL); int n, q; cin &gt;&gt; n &gt;&gt; q; a[0] = 0; for (int i = 1; i &lt;= n; i++) { cin &gt;&gt; a[i]; } for (int i = 1; i &lt;= n; i++) {//create difference array d[i] = a[i] - a[i - 1]; } while (q--) {//query update int l, r, x; cin &gt;&gt; l &gt;&gt; r &gt;&gt; x; d[l] += x; d[r + 1] -= x; } for (int i = 1; i &lt;= n; i++) {//finding the main array a[i] = a[i - 1] + d[i]; } for (int i = 1; i &lt;= n; i++) { cout &lt;&lt; a[i] &lt;&lt; \" \"; } return 0; } . | Given n number of list, initially all is empty, we have q query (l,r,x)(list from l to r append x), after all query, print the number of unique element in each list (n,q&lt;=1e6) | . //within O(nlogn) const int N = 1e6 + 9; vector&lt;int&gt; add[N], rem[N]; int32_t main() { ios_base::sync_with_stdio(false); cin.tie(NULL); int n, q; cin &gt;&gt; n &gt;&gt; q; while (q--) { int l, r, x; cin &gt;&gt; l &gt;&gt; r &gt;&gt; x; add[l].push_back(x); rem[r + 1].push_back(x); } map&lt;int, int&gt;mp; for (int i = 1; i &lt;= n; i++) { for (auto x : add[i]) { mp[x]++; } for (auto x : rem[i]) { mp[x]--; if (mp[x] == 0) { mp.erase(x); } } cout &lt;&lt; mp.size() &lt;&lt; endl; } return 0; } . example: . | 295A_Greg and Array . n array size, m operation (each l-&gt;r, +x), then k query (x,y)&lt;=m, that means that one should apply operations with numbers xi, xi + 1, ..., yi to the array. after all operations print the array . | . https://codeforces.com/contest/2014/problem/D . 2D Difference Array / 2D Static Range Update . | Given n*m matrix, q query, each given submatrix (top_left, bottom_right) add +x, after performing all query, print final array | . using ll = long long; const int N = 1e3 + 9; ll a[N][N], d[N][N]; int32_t main() { ios_base::sync_with_stdio(false); cin.tie(NULL); int n, m; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= m; j++) { cin &gt;&gt; a[i][j]; } } int q; cin &gt;&gt; q; while (q--) { int x1, y1, x2, y2, x; cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2 &gt;&gt; x; d[x1][y1] += x; d[x2 + 1][y1] -= x; d[x1][y2 + 1] -= x; d[x2 + 1][y2 + 1] += x; } for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= m; j++) { d[i][j] += d[i - 1][j] + d[i][j - 1] - d[i - 1][j - 1];//prefix sum of difference array } } for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= m; j++) { a[i][j] += d[i][j];//finding main array } } for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= m; j++) { cout &lt;&lt; a[i][j] &lt;&lt; \" \"; } cout &lt;&lt; endl; } return 0; } . Circular Array . https://codeforces.com/contest/2036/problem/D . 2D Circular Array . ",
    "url": "/08_optimizations/",
    
    "relUrl": "/08_optimizations/"
  },"31": {
    "doc": "02 stl",
    "title": "",
    "content": "String . // index 2 to upto 2 char string sub = s.substr(2,2);//char of index 2-3 [cautions its not range like] int pos = s.find(\"kk\");//first occurance -&gt; O(N*N) int pos = s.rfind('1');//last occurance -&gt; O(N) if(pos==string::npos)//not found (-1) else //found at pos (starting index) s.replace(11,5,\"abcde\"); s.append(\"abc\"); s.compare(\"abc\"); std::getline(std::cin, str);//line input s+='a';//O(1) s = s+'a';//O(N) //works in both index based and iterator based s.insert(); s.erase(); string s = string(c_string); char c_string[] = s.c_str(); . | std::string Interface &amp; Utilities Overview | . ",
    "url": "/02_stl/",
    
    "relUrl": "/02_stl/"
  },"32": {
    "doc": "02 stl",
    "title": "",
    "content": "Multidimentional Arrays and Strings . example: . | 2033B_Sakurako and Water https://www.spoj.com/problems/MAX_NUM/en/ | . Stack (LIFO) . - empty() -&gt; Test whether container is empty (public member function) - size() -&gt; Return size (public member function) - top() -&gt; Access next element (public member function) - push() -&gt; Insert element (public member function) - emplace() -&gt; Construct and insert element (public member function) - pop() -&gt; Remove top element (public member function) - swap() -&gt; Swap contents (public member function) . Queue (FIFO) . - empty(): Checks if the queue is empty. - size(): Returns the number of elements in the queue. - push(): Adds an element to the back of the queue. - front(): Accesses the front element. - **back(): Accesses the back element. - pop(): Removes the front element. - swap(): Exchanges the contents of two queues. Deque . empty(): Checks if the deque is empty. push_back(): Adds an element to the end. **push_front(): Adds an element to the front. size(): Returns the number of elements. front(): Accesses the front element. back(): Accesses the back element. pop_back(): Removes the back element. **pop_front(): Removes the front element. emplace_back(): Constructs and inserts an element at the back. emplace_front(): Constructs and inserts an element at the front. insert(): Inserts an element at a specific position. erase(): Removes an element at a specific position. swap(): Exchanges the contents with another deque. clear(): Removes all elements. - access any index[] - vector is more memory efficient than deque . | std::deque&lt; ValueType &gt; | . Priority Queue/Heap . - priority_queue&lt; int&gt; pq; //default maxHeap//max at top//pop that max - no way to access random or bottom element - priority_queue&lt; int, vector&lt; int&gt;, greater&gt; minHeap;//min at top push(): Inserts an element. In a max-heap (default), the largest element has the highest priority; in a min-heap, the smallest element has the highest priority. size(): Returns the number of elements in the priority queue. top(): Accesses the top element, which is the largest (or smallest, if a min-heap) based on the heap type. pop(): Removes the top element. empty(): Checks if the priority queue is empty. swap() &lt;/pre&gt; ```cpp class Compare { public: bool operator()(pair&lt;int, int&gt; below, pair&lt;int, int&gt; above) { auto [l1, r1] = below; auto [l2, r2] = above; return abs(l1 - r1) &lt; abs(l2 - r2); } }; priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, Compare&gt; pq; ``` --- ### Set bool cmp(int x,int y){ return x&gt;y; } - set&lt; int,decltype(&amp;cmp)&gt;s(cmp);//reversee order - unique and sorted all operation in logn - s.insert(x); - s.erase(s.find(x)); // s.erase(velue);//both valid - int cnt = s.count(x); - can't find index like vector because it's use bidirectional iterator - auto it = s.lower_bound(x);(*it&gt;=x)(first encounder which value at least x) - auto it = s.upper_bound(x);(*it&gt;x)(which value strictly &gt; x) - if not exist then (lower_bound==upper_bound) - only increase or decrease by one (except next(),prev()) - lower_bound(s.begin(),s.end()) -&gt; work but O(N), s.lower_bound(x) -&gt; O(logN), same as upper_bound - set &lt; int&gt;se(v.begin(),v.end())//vector input in set . - std::set&lt;KeyType,Compare&gt; ![set cheatmap](https://hackingcpp.com/cpp/std/set_crop.png) https://www.spoj.com/problems/ADAFIELD/en/ --- ### Unordered Set - don't care order but unique . - std::unordered_set&lt;KeyType,Hash,KeyEqual&gt; ![unordered set](https://hackingcpp.com/cpp/std/unordered_set_crop.png) --- ### Ordered Set / PBDS - order_of_key (k) : Number of items strictly smaller than k . - find_by_order(k) : K-th element in a set (counting from zero). ```cpp #include &lt;ext/pb_ds/assoc_container.hpp&gt; #include &lt;ext/pb_ds/tree_policy.hpp&gt; using namespace __gnu_pbds; #define ordered_set tree&lt;int, null_type,less, rb_tree_tag,tree_order_statistics_node_update&gt; //or typedef tree&lt;pair&lt;int, int&gt;, null_type, less&lt;pair&lt;int, int&gt;&gt;, rb_tree_tag, tree_order_statistics_node_update&gt; PBDS; //for multiset #define ordered_multiset tree&lt;int, null_type,less_equal, rb_tree_tag,tree_order_statistics_node_update&gt; ``` ### Multiset - sorted but not unique - m.erase(m.find(a));//remove first occurrance -&gt; O(logN) - m.erase(a);//remove all occurrences of a -&gt; O(logN+K) - can't be m.erase(m.end()) in any container - int cnt = m.count(x)//O(logN+K) - if not find() any then return m.end() -&gt; so check every time//but don't matter in value . --- ### Map - key, value pair (key must be unique) - map always sorted by key - access random using key (O(logN))-&gt;m[key]-&gt;value; - auto it = m.find(key); (have if it!=m.end()) - m.erase(it);//m.erase(key); . - std::map&lt;KeyType,MappedType,KeyCompare&gt; ## ![map](https://hackingcpp.com/cpp/std/map_crop.png) https://codeforces.com/problemset/problem/920/B ### Unordered Map/HashTable/HashMap - isn't sort using key. - accessing in average case O(1) worst case O(N) -&gt; but in map always O(logN) . ```cpp //if key is int or ll //otherwise not work custom hash //https://codeforces.com/blog/entry/62393 struct custom_hash { static uint64_t splitmix64(uint64_t x) { // http://xorshift.di.unimi.it/splitmix64.c x += 0x9e3779b97f4a7c15; x = (x ^ (x &gt;&gt; 30)) * 0xbf58476d1ce4e5b9; x = (x ^ (x &gt;&gt; 27)) * 0x94d049bb133111eb; return x ^ (x &gt;&gt; 31); } size_t operator()(uint64_t x) const { static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count(); return splitmix64(x + FIXED_RANDOM); } }; ``` - std::unordered_map&lt;KeyType,MappedType,Hash,KeyEqual&gt; ![unordered map](https://hackingcpp.com/cpp/std/unordered_map_crop.png) --- ### Multimap --- ### Policy Based Data Structure ## https://codeforces.com/contest/2051/problem/D ### List/Linked List - default list is doubly linked list . --- ### STL Array - c_type array(not stl array) pass by referrence by default. - pass by value need more time than pass by reference --- ### Bitset - bitset fixed at compile time - must have constant size, complexity O(N/64) - bitset&lt;8&gt;bs(88);//also convert binary string -&gt; bs(\"0010101\") - i can randomly choose bit left to right LSB-&gt;MSB(bs[0-7]-&gt;O(1)) like array - bs.set() -&gt; all value 1//bs.set(index) - bs.reset() -&gt; all value 0//bs.reset(index); - bs.flip()-&gt; 0-1, 1-0//bs.flip(index) - bs.count()-&gt; number of 1 - bs.size(); - bs.to_ullong();//with in range of ull - bs.to_string(); - bs.any()-&gt; check at least one - bs.none()-&gt; all bit 0 or not - bs.all()-&gt; all bit 1 or not binary operation on bitset - (bs1 | bs2) //and &amp; ^ all operation . --- ### Others - Standard Algorithms ![algo](https://hackingcpp.com/cpp/std/algorithms_crop.png) - Lambda Expressions - [&amp;] capture all variable by refference - [=] capture all variable by value - [a,&amp;b] capture a by value, b byb refference . ![Lambda Expressions](https://hackingcpp.com/cpp/lang/lambdas_crop.png) - Custom Comparator - weak ordering (a&gt;=b) (in C++ '=' always return false) - so don't use it('=') in comparator function . ```cpp sort(v.begin(),v.end(),[](pair&lt;int,int&gt;a,pair&lt;int,int&gt;b){ if(a.first!=b.first){ return a.first&gt;b.first; } return a.second&gt;b.second; }); ``` example: - [632C_The Smallest String Concatenation](./2_string/632C_The%20Smallest%20String%20Concatenation.cpp) We have to sort all string by lexicographical order. (a &lt; b), (b &lt; c) -&gt; (a &lt; c) . ",
    "url": "/02_stl/#-1",
    
    "relUrl": "/02_stl/#-1"
  },"33": {
    "doc": "02 stl",
    "title": "02 stl",
    "content": "Basics . | pointers . - memory address of variable x -&gt; &amp;x - pointer variable-&gt; int* ptr(used to store memory address) like, ptr = &amp;n; (dereference operator *) used to access a value that stored at the memory location pointed by a pointer. - *ptr -&gt; value(value of stored address) - update that value -&gt; *ptr = num - null pointers -&gt; int *ptr = nullptr..or..NULL -&gt;ptr = 0 - ith element in array -&gt; x+4*(i-1) ...(x initial address), accessing any element in O(1)-&gt; ptr+(i-1) a+(i-1) //in array - *ptr = *ptr+2 //value of ptr+2 replace in that original ptr value . | references (call by value &amp; call by reference) . - int x=5; int y = x; (x and y have differenct address) - int x=5; int &amp;y = x; (x and y have same address and value) (int &amp;y; y = x;-&gt;wrong approach) y+=5 -&gt; x=10 - call by reference is most faster than call by value - in cpp array is pass by reference by default (array always work in pointer), we can't pass array by value. - container copy time O(n) . | iterators . - iterators are used to access and traverse the elements of a container (act like a pointer) - vector&lt;int&gt;::iterator it = v.begin();// auto it = v.begin();//(it - container specific) - *it (output value shown) - it++;(it = next(it)) it--;(it = prev(it)) it+=x;(it = next(it,x)) it-=x;(it = prev(it,x)) - begin()-&gt; pointing to first element, end()-&gt; pointing to last+1 element - it = v.end(); it--; (*it)-&gt;last element - r.begin()-&gt;last element , r.end()-&gt;first - 1 - vector&lt;int&gt;::reverse_iterator it = v.rbegin(); - normal - , reverse + - v.end()-v.begin() -&gt; n//index - range = distance(v.begin()+2,v.begin()+5);//(2,3,5)//end-of-range iterator q points one behind - after changing in container - previous all declare iterator is invalid//we have to declare new - random iterator(vector, deque, array, string)//it+=x; it-=x; - bidirectional iterator(list, set, map)//it+=1; it-=1; - forward iterator(forward_list, unordered_set, unordered_map)//it+=1 - accesing vector of pair-&gt; (*it).first . | struct vs class . | . #include &lt;iostream&gt; using namespace std; // Using struct struct Point { double x; double y; void display() const { cout &lt;&lt; \"Point(\" &lt;&lt; x &lt;&lt; \", \" &lt;&lt; y &lt;&lt; \")\\n\"; } }; // Using class class Circle { private: double radius; Point center; public: Circle(double r, double cx, double cy) : radius(r), center{cx, cy} {} void display() const { cout &lt;&lt; \"Circle with radius \" &lt;&lt; radius &lt;&lt; \" at \"; center.display(); } }; int main() { Point p1{3.5, 4.5}; p1.display(); // Access is public by default in struct Circle c1(5.0, 2.0, 2.0); c1.display(); // Access is controlled by public methods in class return 0; } . | operator overloading | . pair&lt;int,int&gt; operator + (const pair&lt;int,int&gt;a, const pair&lt;int,int&gt;b){ return make_pair(a.first+b.first,a.second+b.second); } int main(){ pair&lt;int,int&gt; a = {2,3}; pair&lt;int,int&gt; b = {5,3}; pair&lt;int,int&gt; c = a+b; return 0; } . | others . - boolalpha cout&lt;&lt;boolalpha&lt;&lt;a&lt;&lt;\" \"&lt;&lt;b&lt;&lt;endl;(a,b condidion) - sizeof cout&lt;&lt;sizeof(int)&lt;&lt;endl;(4 bytes)//special type size_t(64bit uint) n = sizeof(a)/sizeof(a[0]);//sizeof(a)/size_of(int) - size()-1 //infinite loop(not actually)//segmentation fault size_t n = v.size();//every container size has type size_t // if don't exist any size() unsigned int -&gt; 0-1 -&gt; 2^64-1 (circular)(-1 don't exist in unsigned int range) solution -&gt; (int)v.size()-1; (convert to int) . | . Auto/Pair/Tuple . | auto is used for type interface, must be initialize with value. | . pair&lt;int,double&gt;p; tie(a,b) = p; p = make_pair(a,a/5);//{a.a/5} cout&lt;&lt;p.first&lt;&lt;\" \"p.second&lt;&lt;endl; tuple&lt;int, int, int&gt;t = {1, 2, 3};//tuple can have more than 2 elements auto [a, b, c] = t;//c++17* //structured binding cout &lt;&lt; a &lt;&lt; \" \" &lt;&lt; b &lt;&lt; \" \" &lt;&lt; c &lt;&lt; endl; t = make_tuple(a,b,c); cout&lt;&lt;get&lt;0&gt;(t)&lt;&lt;get&lt;1&gt;t&lt;&lt;get&lt;2&gt;t&lt;&lt;endl; get&lt;0&gt;(get&lt;2&gt;t)// last to first int x,y,z; tie(x,y,z) = t;// if already declare x,y,z pair&lt;int,int&gt;points[10]//array of points pair&lt;pair&lt;int, int&gt;, int&gt;p; p = make_pair(make_pair(1, 2), 3); //p = {4, 5}, 6}; cout &lt;&lt; p.first.first &lt;&lt; \" \" &lt;&lt; p.first.second &lt;&lt; \" \" &lt;&lt; p.second &lt;&lt; endl; . Vector . //some functions in vector v.clear()-&gt;O(N) v.assign(10,1) //upto 10th element assign by 1 v.sort(v.begin()+1,v.end()-1)//{8, 1, 2, 3, 1}//right exclusive v.insert(v.begin()+i,x);//immediade pos go to next v.erase(v.begin()+i);//next go this pos // range always right exclusive reverse(range) or sort(v.rbegin(),v.rend()); swap(u,v) or u.swap(v)//swap two vectors element auto it = find(v.begin(),v.end(),x);//first occurance if(it==v.end())//not occur x index = it - v.begin(); auto it = find(v.rbegin(),v.rend(),x);//last occurance if(it==v.rend())//not occur x count(v.begin(),v.end(),x); accumulate(v.begin(),v.end(),0LL);//0LL initial sum *min_element(v.begin(),v.end()); *max_element(v.begin(),v.end()); partial_sum(v.begin(),v.end(),pre.begin()); . right exclusive -&gt; (v.begin(),v.end()) . | std::vector&lt; ValueType &gt; | . ",
    "url": "/02_stl/",
    
    "relUrl": "/02_stl/"
  },"34": {
    "doc": "17 game theory",
    "title": "17 game theory",
    "content": "example: . | cses1072_Two Knights . Your task is to count for k=1,2,...,n the number of ways two knights can be placed on a k * k chessboard so that they do not attack each other. total no. of ways two knight can place - no. of ways they can place(attack) C(n*n, 2) - (how much 2x3 or 3x2 exist)*2 . | 1957C. How Does the Rook Move? . We are given an n x n chessboard where a player and a computer alternately place rooks (white and black respectively) under the constraint that no two rooks attack each other (i.e., no two rooks share the same row or column). The player starts first, and each move by the player at (r, c) is mirrored by the computer at (c, r), unless r == c, in which case the computer skips its turn. After k initial moves (which are valid and already processed), we need to determine the number of possible final configurations of the board when the game is played to completion (i.e., no more valid moves are left). The answer should be computed modulo 1e9+7 . | . Card . example: . | spoj_HC12_Card_Game . The game's rules are as follows: There is deck of N cards from which each person is dealt a hand of K cards. Each card has an integer value representing its strength. A hand's strength is determined by the value of the highest card in the hand. The person with the strongest hand wins the round. Bets are placed before each player reveals the strength of their hand. John needs your help to decide when to bet. He decides he wants to bet when the strength of his hand is higher than the average hand strength. Hence John wants to calculate the average strength of ALL possible sets of hands. You are given an array a with N ≤ 10 000 different integer numbers and a number, K, where 1 ≤ K ≤ N. For all possible subsets of a of size K find the sum of their maximal elements modulo 1 000 000 007. total subset 2^n-1 fixed_length_subset nCr fixed_value_subset = *C(n-1,k-1) like . | . ",
    "url": "/17_game_theory/",
    
    "relUrl": "/17_game_theory/"
  },"35": {
    "doc": "05 recursion backtracking memoization",
    "title": "05 recursion backtracking memoization",
    "content": "Recursion . | 1+2+3+4…n //O(N) . int sum(int n){ if(n==0)return 0;//base case return sum(n-1)+n; } . | n! . int factorial(int n){ if(n==0)return 1; return factorial(n-1)*n; } . | fibonacci . int fibonacci(int n){ if(n==0)return 0; if(n==1)return 1; return fibonacci(n-1)+fibonacci(n-2); } . | . Visualizer Tool . | recursion tree | recursion stck | . Time Complexity in Recursion . the number of nodes in the recursion tree. (time complexity in each node * number of nodes) . Space complexity = (maximum dept * each node ) . # . Notices: . | a stack overflow occurs when the call stack exceeds it’s maximum capacity. -Runtime Error/Segmentation Fault . | if it make cycle, then recursion will never end. ex. f(n) = f(n-1)+f(n+1) . | . # . Memoization / DP . O(2^N)-&gt;O(N) . called only number of unique state. | Power of two . vector&lt; int&gt; memo(100,-1); int power_of_two(int n){ if(n==0)return 1; if(memo[n]!=-1)return memo[n]; memo[n]=power_of_two(n-1)+power_of_two(n-1); return memo[n]; } . | . BackTracking . Genereting all subsequence . int n,a[20]; bool isTaken[20]; void recursion(int pos){ if(pos&gt;n){ for(int i=1;i&lt;=n;i++){ if (isTaken[i]){ cout&lt;&lt;a[i]&lt;&lt;\" \"; } } cout&lt;&lt;endl; return; } isTaken[pos] = false;//not take recursion(pos+1); isTaken[pos]=true;//take recursion(pos+1); } recursion(1); . a[3] = {1,2,3} {},{3},{2},{2,3},{1},{1,3},{1,2},{1,2,3} . {} / \\ Not Pick 1 Pick 1 / \\ {} {1} / \\ / \\ Not Pick 2 Pick 2 Not Pick 2 Pick 2 / \\ / \\ {} {2} {1} {1, 2} / \\ / \\ / \\ / \\ Not Pick 3 Pick 3 Not Pick 3 Pick 3 Not Pick 3 Pick 3 Not Pick 3 Pick 3 / \\ / \\ / \\ / \\ {} {3} {2} {2, 3} {1} {1, 3} {1, 2} {1, 2, 3} . ",
    "url": "/05_recursion_backtracking_memoization/",
    
    "relUrl": "/05_recursion_backtracking_memoization/"
  },"36": {
    "doc": "1 adhoc",
    "title": "1 adhoc",
    "content": " ",
    "url": "/01_adhoc_implementation_constructive/1_adhoc/",
    
    "relUrl": "/01_adhoc_implementation_constructive/1_adhoc/"
  },"37": {
    "doc": "01 adhoc implementation constructive",
    "title": "01 adhoc implementation constructive",
    "content": "Adhoc Problems . Adhoc problems don’t rely on specific algorithms or data structures. They require creative, case-by-case solutions based on the problem description. Example: Finding the second-largest number in a list. example: . | miaki-presents-kuet-iupc-onsite-2025_K-Beast | . Implementation Problems . These problems focus on correctly implementing a sequence of steps or rules, often based on real-world processes or detailed problem instructions. Example: Simulating a traffic light system based on a set of predefined rules. Implementation Tricks / Suggestion . - use #define, auto //to make code shorter and easier to read - (long long) a*b &lt;-&gt; 1LL*a*b; - use of function, to modularize code - array&lt;type,size&gt; can be useful stl array vector&lt;tuple&lt;int,int,int,int,int&gt;&gt; &lt;-&gt; vector&lt;array&lt;int,5&gt;&gt;v; - use lamda function//helpful in comparator and predicate function - memset(), fill() &lt;-&gt; to initialize array - unique element in vector sort(v.begin(),v.end()); v.erase(unique(v.begin(),v.end())/*first iterator that is not unique*/,v.end()); - sort in decending order sort(v.begin(),v.end(),greater&lt;int&gt;)//easier sort(v.rbegin(),v.rend());//easiest - max/min of multiple value max({a,b,c,d,e}); - max/min in vector *max_element(), *min_element() . Constructive Problems . Constructive problems require building a solution that satisfies a set of constraints. You develop the answer step by step rather than just determining if something is possible. Example: Constructing a valid sequence of parentheses. - check careful about the constraints. - mostly constructive problems have multiple solutions. | Always Check for [first + last + in between] &lt;- very important | . example: . | 1559C_Mocha and Hiking The city where Mocha lives in is called Zhijiang. There are n+1 villages and 2n−1 directed roads in this city. There are two kinds of roads: - n−1 roads are from village i to village i+1, for all 1≤i≤n−1 - n roads can be described by a sequence a1,…,an. If ai=0, the i-th of these roads goes from village i to village n+1, otherwise it goes from village n+1 to village i, for all 1≤i≤n Mocha plans to go hiking with Taki this weekend. To avoid the trip being boring, they plan to go through every village exactly once. They can start and finish at any villages. Can you help them to draw up a plan? -&gt; If a1=1, then the path [(n+1)→1→2→⋯→n] is valid. If an=0, then the path [1→2→⋯→n→(n+1)] is valid. Otherwise, since a1=0∧an=1, there must exists an integer i (1≤i&lt; n) where ai=0∧ai+1=1, then the path [1→2→⋯→i→(n+1)→(i+1)→(i+2)→⋯n] is valid. This is a step to prove that there always exists an Hamiltonian path in a tournament graph. | . ",
    "url": "/01_adhoc_implementation_constructive/",
    
    "relUrl": "/01_adhoc_implementation_constructive/"
  },"38": {
    "doc": "07 greedy algorithms",
    "title": "07 greedy algorithms",
    "content": "Greedy problems involve making the best local choice at each step in the hope of achieving a globally optimal solution. These problems require the greedy-choice property to ensure the local optimum leads to the global optimum. Example: The Activity Selection Problem or Huffman Coding. ",
    "url": "/07_greedy_algorithms/",
    
    "relUrl": "/07_greedy_algorithms/"
  },"39": {
    "doc": "14 ds tree range queries",
    "title": "14 ds tree range queries",
    "content": "https://medium.com/basecs/a-gentle-introduction-to-graph-theory-77969829ead8 https://darrenyao.com/usacobook/cpp.pdf#page=41 . - Tree is a subset of graphs. - tree need at least one root node in order to be considered a “tree” Trees, start with a root node, and might connect to other nodes, which means that could contain subtrees within them. Trees are defined by a certain set of rules: one root node may or may not connect to others, but ultimately, it all stems (ডালপালা) from one specific place. Some trees have even more specific rules, like binary search trees, which can only ever have two links to two nodes at any given time. - A tree can also only have one-way connections — a child node can only have one parent, and a tree can’t have any loops, or cyclical (চক্রাকার) links. - A tree is an undirected graph in which any \"two vertices are connected by only one path\". A tree is an acyclic graph and has N - 1 edges where N is the number of vertices. Each node in a graph may have one or multiple parent nodes. However, in a tree, each node (except the root node) comprises exactly one parent node. Note: A root node has no parent. A tree cannot contain any cycles or self loops, however, the same does not apply to graphs. Trees are nothing more than restricted types of graphs, just with many more rules to follow . A tree will always be a graph, but not all graphs will be trees. - A tree is a connected graph that consists of n nodes and n − 1 edges. There is a unique path between any two nodes of a tree. ",
    "url": "/14_ds_tree_range_queries/",
    
    "relUrl": "/14_ds_tree_range_queries/"
  },"40": {
    "doc": "1 divisors perfect square ntf",
    "title": "1 divisors perfect square ntf",
    "content": "- odd number of divisors are perfect square (i==n/i we eliminate one divisors because of unique divisors.) (ex. cf2020B) - otherwise all other number has even number of divisors . //finding divisors using sqrt method O(sqrt(n)) //used to find single number vector&lt;int&gt;divisors_of_n(int n) { vector&lt;int&gt;divisors; //we have to maintain (i*i) not go to overflow //if(overflow) then it go to infinite loop for (int i = 1; i * i &lt;= n; i++) {//because of sqrt()-&gt; may cause precision error if (n % i == 0) { divisors.push_back(i); if (i != n / i) {//because of unique divisors divisors.push_back(n / i); } } } sort(divisors.begin(), divisors.end()); for (auto x : divisors) { cout &lt;&lt; x &lt;&lt; \" \"; } return divisors; } . | Number of Divisors from 1 to N (Each Number) | . normal way O(nsqrt(n) causes TLE) (n upto 1e5)-&gt; O(nlogn) . //complexity O(nlogn) //used to find multiple number const int N = 1e7+9; int d[N]; for(int i=1;i&lt;N;i++){ for(int j=i;j&lt;N;j+=i){//harmonic series d[j]++; } } // if(d[i]==2) -&gt; they are prime . for(int i=1;i&lt;=n;i++){ if(n%i==0){ cout&lt;&lt;i&lt;&lt;\" \"; } } . | (b | a) -&gt; b divide a | . | . example: . | atcoder C - Cream puff . | 1485A_Add and Divide You can perform two kinds of operations: a=⌊a/b⌋ (replace a with the integer part of the division between a and b) b=b+1 (increase b by 1) Find the minimum number of operations required to make a=0 . we can try to increase b to a certain value and then divide a by b until it is 0. Being careful as not to do this with b&lt;2, the number of times we divide is going to be O(loga). In particular, if you reach b≥2 (this requires at most 1 move), you need at most ⌊log2(10^9)⌋=29 moves to finish. Let y be the number of moves of type 2; we can try all values of y (0≤y≤30) and, for each y, check how many moves of type 1 are necessary. Complexity: O(log^2 a) . | 2029A_Set | One of the first 1234567 positive integers is chosen at random. Compute the probability that it is divisible by 3? . -&gt; Pattern Identification: Every third number in the sequence of positive integers is divisible by 3: - Example: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, ... - From this pattern, it's clear that every package of three numbers contains exactly **one** divisible by 3. -&gt; Count Numbers Divisible by 3: To find how many numbers in the first 1234567 are divisible by 3: floor(1234567/3) -&gt; Calculate Probability: The probability of selecting a number divisible by 3 is: P = Numbers Divisible by 3 / Total Numbers = 411522 / 1234567 ≈ 0.33333306 -&gt; Result: This matches the expected approximation of 1/3, derived from the pattern of divisibility. - The probability `P ≈ 1/3` arises naturally from the definition of divisibility. - The slight deviation from `1/3` comes from the truncation during integer division. This method demonstrates how understanding divisibility patterns simplifies complex calculations. | Find all integers x for which it can be said that the positive integer 2x + 9 divides the positive integer 3x + 4? . From the problem statement, we can extract the following requirements: x ∈ Z 2x + 9 ∈ Z+ =⇒ x ∈ Z≥−4 3x + 4 ∈ Z+ =⇒ x ∈ Z≥−1 3x + 4 ≥ 2x + 9 =⇒ x ∈ Z≥5 Additionally, we require (3x + 4)/(2x + 9) = 1 + (x − 5)/(2x + 9) =⇒ (x − 5)/(2x + 9) ∈ Z≥0. This secondary requirement means that either x = 5 or x − 5 ≥ 2x + 9 =⇒ x ∈ Z≤−14. The second case is clearly impossible due to the strict x ∈ Z≥5 requirement from earlier, so the only valid integer x is 5 . | . Number Theoretic Function . Two important number theoretic functions in mathematics are: - τ(n) (Tau function): Counts the number of positive divisors of n - σ(n) (Sigma function): Calculates the sum of all positive divisors of n other two are eulers and mobius function n -&gt; 1e16 =&gt; sqrt(n) -&gt; 1e8 : it can pass . | τ(n) (Tau function) | . τ(12) =&gt; - Step 1: Prime Factorization 12 = 22 × 31 - Step 2: Use the divisor-counting formula If n = p1a × p2b × ... × pkz, then τ(n) = (a + 1)(b + 1)...(z + 1) -&gt; (+1 because of 0) So, τ(12) = (2 + 1)(1 + 1) = 3 × 2 = 6 - Step 3: List all divisors of 12 All numbers of the form 2i × 3j where 0 ≤ i ≤ 2, 0 ≤ j ≤ 1 → Possible combinations: i = 0, j = 0 → 1 i = 0, j = 1 → 3 i = 1, j = 0 → 2 i = 1, j = 1 → 6 i = 2, j = 0 → 4 i = 2, j = 1 → 12 → Divisors of 12: 1, 2, 3, 4, 6, 12 Hence, τ(12) = 6 ✔ Confirmed: The number of positive divisors of 12 is 6. -&gt; odd divisors not count for 2 -&gt; square divisors : a^x . b^y . c^z =&gt; (no.(o,2,4..x)).(no.(o,2,4..y)).(no.(o,2,4..z)) -&gt; non square -&gt; squarefree (not divide by any square) . //number of disisors using ll = long long int tau(ll n) { int cnt = 0; for (ll i = 1; i * i &lt;= n; i++) { if (n % i == 0) { cnt++; if (i != n / i)cnt++; } } return cnt; } . | Sieve-Based Implementation of τ(n) | . 1 2 3 4 5 6 7 8 9 10 ... n |-||-||-|||-||-||||-||-||||-|||-|||| (for 1 to n go all divisor of i and add 1) 1 2 2 3 2 4 2 4 3 4 . const int nmax = 1e5 + 10; int tau[nmax]; int sigma[nmax]; //can go easily 1e6 void seive() { //O(nlog(n)) //can't go upto 9e7 but original can go for (int i = 1; i &lt; nmax; i++) { for (int m = i; m &lt; nmax; m += i) { tau[m]++ sigma[m] += i; } } } /* original seive-&gt; O(nloglogn) -&gt; only find prime record ... then apply math formula of tau and sigma... try to use this all the time*/ . \\log n \\approx 1 + \\frac{1}{2} + \\frac{1}{3} + \\cdots + \\frac{1}{n} . | Sieve-Based Implementation (Optimised) | . /* SPF sieve: O(n log log n) Main loop: O(n) amortized Total: O(n log log n) + O(n) = O(n log log n)*/ const int nmax = 1e5 + 10; int spf[nmax]; // smallest prime factor int tau[nmax]; int sigma[nmax]; void optimized_sieve() { // Initialize smallest prime factors iota(spf, spf + nmax, 0); // spf[i] = i // Sieve of Eratosthenes to find smallest prime factors for (int i = 2; i * i &lt; nmax; i++) { if (spf[i] == i) { // i is prime for (int j = i * i; j &lt; nmax; j += i) { if (spf[j] == j) spf[j] = i; } } } // Initialize tau and sigma for n = 1 tau[1] = 1; sigma[1] = 1; for (int n = 2; n &lt; nmax; n++) { if (spf[n] == n) { // n is prime tau[n] = 2; sigma[n] = n + 1; } else { // Factorize n using spf int p = spf[n]; int m = n; int exponent = 0; while (m % p == 0) { m /= p; exponent++; } // Using multiplicative properties: // τ(n) = τ(m) * (exponent + 1) // σ(n) = σ(m) * (p^(exponent+1) - 1)/(p - 1) tau[n] = tau[m] * (exponent + 1); int power = 1; for (int i = 0; i &lt;= exponent; i++) { power *= p; } sigma[n] = sigma[m] * (power - 1) / (p - 1); } } } . | σ(n) (Sigma function) | . σ(12) =&gt; - Step 1: Prime Factorization 12 = 22 × 31 - Step 2: Formula for sum of divisors If n = p1a × p2b × ... × pkz, then σ(n) = [(p10 + p11 + ... + p1a) × (p20 + p21 + ... + p2b) × ... ] ((p1a1+1-1)/(p1-1)).((p2a2+1-1)/(p2-1))... So, σ(12) = (20 + 21 + 22) × (30 + 31) = (1 + 2 + 4) × (1 + 3) = 7 × 4 = 28 =&gt; 12 = 22 × 31 Apply the formula: σ(12) = ((22+1 - 1) / (2 - 1)) × ((31+1 - 1) / (3 - 1)) = ((23 - 1) / 1) × ((32 - 1) / 2) = (8 - 1) × (9 - 1) / 2 = 7 × 8 / 2 = 7 × 4 = 28 - Step 3: List all divisors and sum them directly Divisors of 12: 1, 2, 3, 4, 6, 12 Sum = 1 + 2 + 3 + 4 + 6 + 12 = 28 ✔ Confirmed: σ(12) = 28 . \\sigma(n) = \\left( \\frac{p_1^{a_1+1} - 1}{p_1 - 1} \\right) \\cdot \\left( \\frac{p_2^{a_2+1} - 1}{p_2 - 1} \\right) \\cdot \\dots \\cdot \\left( \\frac{p_k^{a_k+1} - 1}{p_k - 1} \\right) . ❗ So, even though the individual terms look like fractions, they always simplify to integers because they represent the sum of a geometric series of powers of integers. //sum of all disisors using ll = long long int sigma(ll n) { int sum = 0; for (ll i = 1; i * i &lt;= n; i++) { if (n % i == 0) { sum += i; if (i != n / i) sum += n/i; } } return sum; } . | Sieve-Based Implementation of σ(n) | . 1 2 3 4 5 6 7 8 9 10 ... n (for 1 to n go all divisor of i and add i everytime) . const int nmax = 1e5 + 10; int tau[nmax]; int sigma[nmax]; void seive() { for (int i = 1; i &lt; nmax; i++) { for (int m = i; m &lt; nmax; m += i) { tau[m]++ sigma[m] += i; } } } . example: . | spojABA12D - Sum of divisors! | . he decided to look out for numbers whose sum of divisors is a prime number and he was the inventor of these special numbers he gave them the name K-numbers. Given a range [A, B] you are expected to find the number of K-numbers in this range. 1 &lt;= T &lt;= 10000, 1&lt;=A&lt;=B&lt;=10^6 . Perfect Square . - odd number of divisors are perfect square (i==n/i we eliminate one divisors because of unique divisors.) - otherwise all other number has even number of divisors . bool isSquare(i64 n) { int x = std::sqrt(n); return 1LL * x * x == n; } . example: . | https://codeforces.com/contest/2071/problem/B | https://codeforces.com/contest/2020/problem/B | https://codeforces.com/contest/2031/problem/C | . ",
    "url": "/09_number_theory/1_primes_coprime_divisors_factorization_perfect_square/1_divisors_perfect_square_ntf/",
    
    "relUrl": "/09_number_theory/1_primes_coprime_divisors_factorization_perfect_square/1_divisors_perfect_square_ntf/"
  },"41": {
    "doc": "2 primes factorization legendre",
    "title": "2 primes factorization legendre",
    "content": "- prime has exactly two divisors (1 &amp; that number) - other number can be represented by multiple of different prime numbers - if p divide a*b then -&gt; p (divide a) or (divide b) or (both) - 1 neither prime nor composite - after 2 all prime is odd - primes2 has exactly three divisors (4 -&gt; 1,2,4) . | Prime-Counting Function π(N) / Prime number theorem | . The prime-counting function π(N) gives the exact number of primes less than or equal to N. For: N = 2^64 = 18,446,744,073,709,551,616 A rough estimate of π(2^64) using the logarithmic integral approximation is: π(2^64) ≈ 2^64 / ln(2^64) = 2^64 / (64 . ln(2)) ≈ 4.2 × 10^17 However, modern number theory research and computational results provide a more precise estimate: π(2^64) ≈ 416,971,064,282,000 That’s approximately 417 trillion prime numbers less than or equal to 2^64. not exact ~ approx . \\pi(n) \\sim \\frac{n}{\\ln n} . | Trial Division (Naive) -&gt; best for single number | . - Complexity -&gt; O(sqrt(n), Space: O(1) - Suitable for n &lt;= 1e6 - for 1 test case it can go upto 1e14 (1e7 instruction need) n = a.b =&gt; a &lt; sqrt(n) for whose prime number square (25-&gt;5.5) it fails because it runs upto 1,2,3,4 not 5 that's why we need a &lt;= sqrt(n) . //check n is prime or not -&gt; O(sqrt(n) bool is_prime(long long n){ if(n==1) return false; for(int i=2;1LL*i*i&lt;=n;i++){ if(n%i==0){ return false; } } return true; } . // more optimized // O(√n / 3) Time Complexity: Much faster than a naive O(√n) approach. // Use this function when you need a fast, deterministic primality test for integers. bool isPrime(int n) { if (n &lt;= 1) // 1 and below are not prime return false; if (n == 2 || n == 3) // 2 and 3 are prime return true; if (n % 2 == 0 || n % 3 == 0) // Eliminate multiples of 2 and 3 return false; // Check divisibility for numbers of form 6k ± 1 up to √n for (int i = 5; i * i &lt;= n; i += 6) { if (n % i == 0 || n % (i + 2) == 0) return false; } return true; } . // Function to return the smallest // prime number greater than N int nextPrime(int N){ // Base case if (N &lt;= 1) return 2; int prime = N; bool found = false; // Loop continuously until isPrime returns // true for a number greater than n while (!found){ prime++; if (isPrime(prime)) found = true; } return prime; } . example: . | Prove that, for all primes p, the smallest positive integer whose factorial is divisible by p is p itself. | . It is trivial by inspection that p satisfies this condition. Let the smallest positive such integer be k. For the sake of contradiction, assume that k &lt; p and p|k!. Then, k! is the product of all positive integers less than p and p is present in the prime factorization of k!. Some of the positive integers in this product are themselves primes less than p, while others are less than p and have unique prime factorizations involving only primes less than p by the fundamental theorem of arithmetic. Thus, p cannot be present in prime factorization of k!, establishing contradiction. This means that k = p. | 1562B - Scenes From a Memory | . find the smallest non-prime number that can be formed by digits from a given string (as a subsequence) . | https://codeforces.com/contest/2093/problem/C | . | Sieve of Eratosthenes (Precompute Primes) | . - Generate all primes up to N using a boolean sieve. - Time: O(NloglogN) Space: O(N) - Best for precomputing primes up to 1e7(memory limits apply). | https://en.wikipedia.org/wiki/Harmonic_series_(mathematics) . | General Seive . | . /*loop goes upto : n/2+n/3+n/5+n/7+... -&gt; n(1/2+1/3+1/5+...) -&gt; harmonic series -&gt; 0(nloglogn)*/ //basic seive (no optimization) //work upto 5e7 bool mark[50000000 + 5]; void seive(int n) { mark[1] = true; for (int i = 2; i &lt;= n; i++) { if (mark[i]) continue; for (int m = 2 * i; m &lt;= n; m += i) {//only go when i is prime mark[m] = true; } } } . | Optimized Seive 1 | . //complexity same as general seive void seive(int n) { mark[0] = mark[1] = true; for(int i=4;i&lt;=n;i+=2){//even handle fast mark[i] = true; } for (int i = 3; i &lt;= n; i+=2) { if (mark[i]) continue; for (int m = 3 * i; m &lt;= n; m += i+i) {//only go when i is prime mark[m] = true; } } } . | Optimized Seive 2 (Time Efficient) | . //more prefer than previous version bool mark[50000000 + 5]; void seive(int n) { mark[0] = mark[1] = true; for (int i = 4; i &lt;= n; i += 2) { //even handle fast mark[i] = true; } for (int i = 3; 1LL * i * i &lt;= n; i += 2) { if (mark[i]) continue; for (int m = i * i; m &lt;= n; m += i + i) { mark[m] = true; } } } . | Optimized Seive 3 (Time and Memory Efficient) | . //using array instead of vector const int MAX = 1e8; // Main sieve limit bitset&lt;MAX + 1&gt; is_prime; int primes[50000000 + 5]; // Stores primes up to MAX int primecnt = 0; // Optimized sieve that populates both is_prime and primes[] void optimized_sieve(int n) { is_prime.set(); is_prime[0] = is_prime[1] = false; // Handle evens for (int i = 4; i &lt;= n; i += 2) is_prime[i] = false; primes[primecnt++] = 2; // Sieve odd numbers for (int64_t i = 3; i &lt;= n; i += 2) { if (is_prime[i]) { primes[primecnt++] = i; for (int64_t j = i * i; j &lt;= n; j += 2 * i) is_prime[j] = false; } } } . example: . | spoj_TDKPRIME - Finding the Kth Prime | . An integer stating the number of queries Q (equal to 50000), and Q lines follow, each containing one integer K between 1 and 5000000 inclusive. Q lines with the answer of each query: the Kth prime number. n = 86028122 ~ 1e8 for 5e6 . | uva_543 - Goldbach’s Conjecture | . Euler re-expressed the conjecture as: Every even number greater than or equal to 4 can be expressed as the sum of two prime numbers. Each test case consists of one even integer n with 6 ≤ n &lt; 1000000. | https://lightoj.com/problem/lucky-number | . seive + segment tree . Factorization . - 1 number does not have more than log(N) prime . | General Factorization | . //complexity -&gt; O(sqrt(n)) vector&lt;ll&gt;factorize(ll n) { vector&lt;ll&gt;ret; if (n == 1) { return ret; } for (ll i = 2; i * i &lt;= n; i++) {//can go upto prime list if (n % i == 0) { while (n % i == 0) { n /= i; ret.push_back(i); } } } if(n != 1){//&gt;1 ret.push_back(n); } return ret; } . | Factorization from primes | . using ll = long long; const ll MAX_SIEVE = 1e7; std::vector&lt;ll&gt; spf(MAX_SIEVE + 1); std::vector&lt;ll&gt; primes; // Precompute smallest prime factors and primes list void precompute_primes() { spf[0] = spf[1] = 1; for (ll i = 2; i &lt;= MAX_SIEVE; i++) { if (spf[i] == 0) { // i is prime spf[i] = i; primes.push_back(i); for (ll j = i * i; j &lt;= MAX_SIEVE; j += i) { if (spf[j] == 0) spf[j] = i; } } } } // Optimized factorization using precomputed primes std::vector&lt;ll&gt; factorize_with_primes(ll n) { std::vector&lt;ll&gt; factors; if (n == 1) return factors; // Check against precomputed primes for (ll p : primes) { if (p * p &gt; n) break; while (n % p == 0) { factors.push_back(p); n /= p; } } if (n &gt; 1) factors.push_back(n); return factors; } . | Factorization From Seive | . int mark[50000000 + 5]; void seive(int n) { mark[0] = mark[1] = 0; for (int i = 2; i &lt;= n; i++) { if (mark[i] &gt; 0) continue; for (int m = 2 * i; m &lt;= n; m += i) { mark[m] = i; } } } //vector return makes vector copy to another vector&lt;int&gt;factorize(int n) {//O(logn) vector&lt;int&gt;ret; if(n == 1) return ret; while (mark[n] != 0) {//no wasted ret.push_back(mark[n]); n /= mark[n]; } ret.push_back(n); return ret; } . example: . | 576A_Vasya and Petya’s Game | . # thought of number x between 1 and n, another tries to guess the number # another can ask, is the unknown number divisible by number y? # find the minimum number of questions he should ask to make a guaranteed guess number. n factorize = (2,2,2,3,5...y) if(n is divisible y) y*y until find n.. then next y . | 230B_T-primes | . A number is called a T-prime if it has exactly three distinct positive divisors. Given n numbers, determine if each is a T-prime. | spoj_FACT0 - Integer Factorization (15 digits) | . Given some integers, you need to factor them into product of prime numbers. | 1366D. Two Divisors | . You are given n integers a1,a2,…,an For each ai, find its two divisors d1&gt;1 and d2&gt;1 such that gcd(d1+d2,ai)=1 (where gcd(a,b) is the greatest common divisor of a and b) or say that there is no such pair. 2 &lt;= ai &lt;= 1e7 not possible when n = p^x d1 = p d2 = q.r... Legendre’s Formula . | https://artofproblemsolving.com/wiki/index.php/Legendre’s_Formula | . Legendre’s formula gives the exponent of a prime number ( p ) in the factorization of ( n! ). It is expressed as: . e_p(n!) = \\sum_{i=1}^{\\infty} \\left\\lfloor \\dfrac{n}{p^i} \\right\\rfloor = \\frac{n - S_p(n)}{p - 1} = \\left\\lfloor \\frac{n}{p} \\right\\rfloor + \\left\\lfloor \\frac{n}{p^2} \\right\\rfloor + \\left\\lfloor \\frac{n}{p^3} \\right\\rfloor + \\cdots . Where: . | e_p(n!) is the exponent of prime p in n! | S_p(n) is the sum of digits of n in base p | floor(x) denotes the floor function ⎣x⎦ (greatest integer less than or equal to x) | . This formula is especially useful in number theory and combinatorics for evaluating factorial prime powers efficiently. int legendre(int n, int p) { int exponent = 0; while (n &gt; 0) { n /= p; exponent += n; } return exponent; } //Count trailing zeros in n! (exponent of 5 in n!) int countTrailingZeros(int n) { return legendre(n, 5); } . example: . | To determine how many times the prime number 2 appears in the factorization of 10! (10 factorial), we can use Legendre’s Formula. | . Calculation for ( p = 2 ) in ( 10! ) . e_2(10!) = \\left\\lfloor \\frac{10}{2} \\right\\rfloor + \\left\\lfloor \\frac{10}{4} \\right\\rfloor + \\left\\lfloor \\frac{10}{8} \\right\\rfloor + \\left\\lfloor \\frac{10}{16} \\right\\rfloor + \\cdots \\\\ = 5 + 2 + 1 + 0 + \\cdots= 8 . | lightoj_ Trailing Zeroes (II) | . Find the number of trailing zeroes for the following function: (nCr)×pq where n, r, p, q are given as Input. Input starts with an integer T (≤ 10000), denoting the number of test cases. Each case contains four integers: n, r, p, q (1 ≤ n, r, p, q ≤ 1e6, r ≤ n). =&gt; 2^x, 5^y -&gt; min(x,y) n! -&gt; cnt 2,5 r! -&gt; cnt 2,5 (n-r)! -&gt; cnt 2,5 total = (n! -&gt; cnt 2,5)-((r! -&gt; cnt 2,5) + ((n-r)! -&gt; cnt 2,5)) . ",
    "url": "/09_number_theory/1_primes_coprime_divisors_factorization_perfect_square/2_primes_factorization_legendre/",
    
    "relUrl": "/09_number_theory/1_primes_coprime_divisors_factorization_perfect_square/2_primes_factorization_legendre/"
  },"42": {
    "doc": "2 modular multiplicative inverse",
    "title": "2 modular multiplicative inverse",
    "content": "https://cp-algorithms.com/algebra/module-inverse.html https://forthright48.com/modular-multiplicative-inverse/ . First we have to determine whether Modular Inverse even exists for given A and M before we jump to finding the solution. - Modular Inverse of A with respect to M, that is, X=A−1(mod M) exists, if and only if A and M are coprime. - Division and fractions(more complicated) are different in modular arithmetic than other operator. It's requires a concept called \"modular multiplicative inverse\". - The modular multiplicative inverse of a number a is the number a−1 such that a⋅a−1 mod m = 1. Bruteforcing all numbers to a prime number close to a billion will usually cause you to exceed the time limit. There are two faster ways to calculate the inverse: the extended GCD algorithm, and Fermat's little theorem. Though the extended GCD algorithm is more versatile and sometimes slightly faster, the Fermat's little theorem method is more popular, a.am−1 mod m = 1 = a⋅am−2 mod m, therefore the number we need is a-1 = am−2 mod m (m!=0) This also extends the mod operator to rational numbers (i.e. fractions), as long as the denominator is coprime to m. (Thus the reason for choosing a fairly large prime; that way puzzle writers can avoid denominators with m as a factor). If a and m aren't coprime, there is no multiplicative inverse of a modulo m, i.e., there is no integer x where a⋅x mod m=1. This is because all a⋅x mod m is divisible by gcd(a,m)≠1. - Z/pZ is just a fancy term meaning the set of integers from 0 to p−1 treated as residues modulo p. # Something to know - divisions through modular multiplicative inverse would be slower than the other operations (O(logm) instead of O(1)), so you may want to cache/memoize the inverses you use frequently in your program. - comparisons are generally meaningless. - exponentiation (when evaluating xn mod m, you can't store n as n mod m. If n turns out to be really huge, you need to calculate it modulo φ(m) instead, where φ stands for Euler's totient function. If m is prime, φ(m) = m−1. Do be careful about the special case 00, which should typically be defined as 1, while 0φ(m) would still be 0. - A modular multiplicative inverse a−1 mod m is always unique within the range 0≤a−1 mod m &lt;=m if it exists (and it exists as long as gcd(a,m)=1, a and m are coprime) . Properties: . 1. Existence . | Not all numbers have a modular multiplicative inverse. | The modular inverse of a mod m exists if and only if a and m are coprime, i.e., gcd(a, m) = 1. | If gcd(a, m) ≠ 1, a has no inverse modulo m. | . 2. Uniqueness . | If a has an inverse modulo m, it is unique modulo m. | There is only one x in the range 0 ≤ x &lt; m such that: a * x ≡ 1 (mod m) | if a has a modular multiplicative inverse modulo m, then all a*i mod m are distinct for i [1,m] | . 3. Multiplicative Property . | If a and b both have inverses modulo m, then: (a * b)-1 ≡ a-1 * b-1 (mod m) | . 4. Inverse of 1 . | The modular inverse of 1 is always 1: 1 * 1 ≡ 1 (mod m) | . 5. Inverse of -a . | The modular inverse of -a is -a&lt;sup&gt;-1&lt;/sup&gt; modulo m: (-a) * (-a-1) ≡ 1 (mod m) | . 6. Relation with Modular Exponentiation . | For prime m, the modular inverse of a can be computed using Fermat’s Little Theorem: a-1 ≡ a(m-2) (mod m) | . | **_Naive Method (modular inverse)_** | . - A number a has a modular multiplicative inverse modulo m if there exists a number b such that a*b ≡ 1 (mod m)...(b is a modular inverse of a) -&gt; xx−1 mod m = 1. - If a has a modular multiplicative inverse modulo m, then we can write a-1 for the modular multiplicative inverse of a modulo m. a modular inverse does not always exist, x−1 mod m can be calculated exactly when x and m are coprime. //naive O(mod) int inverse(int a, int m) { for (int i = 1; i &lt; m; i++) { if (1LL * a * i % m == 1) { return i; } } return -1;//inverse doesn't exist } . **_M is Prime_** -&gt; 1e9+7 or 998244353 . | **_Fermat’s Little Theorem (fast exponentiation)_** | . Fermat’s Little Theorem says-&gt; if gcd(a,m)=1 then ap−1≡1 (mod p) If a modular inverse exists, it can be calculated using the formula x−1 = xϕ(m)−1. If m is prime, the formula becomes x−1 = xm−2. Optimize Approach -&gt; ap-1 ≡ 1 (mod p). (from little fermat's theorem) -&gt; a.y ≡ 1 (mod p) -&gt; a.ap-2 = ap-1 ≡ 1 (mod p) -&gt; a-1 = ap-2 (mod p) - Except for 0-1 -&gt;valid range: (0 &lt; a &lt; mod) -&gt; mod must be prime . //faster O(logm) int power(int x, int n, int mod) { int ans = 1 % mod; while (n &gt; 0) { if (n &amp; 1) { ans = 1LL * ans * x % mod; } x = 1LL * x * x % mod; n &gt;&gt;= 1; } return ans; } // mod must be prime int inverse(int a, int mod) { if (a % mod == 0) { cout &lt;&lt; \"Inverse doesn't exist (a is divisible by m).\" &lt;&lt; endl; return -1; } return power(a, mod - 2, mod); } . **_M is not Prime_** (in general) . inverse(a)%mod only have, as long long as gcd(a,mod)=1(co-prime) . | Using Euler’s Theorem (general method) | . It is possible to use Euler’s Theorem to find the modular inverse. We know that: Aϕ(M) ≡ 1(mod M) Aϕ(M)−1 ≡ A−1(mod M) This process works for any M as long as it’s coprime to A, but it is rarely used since we have to calculate Euler Phi value of M which requires more processing. Euler's theorem provides a general method to compute modular inverses, but for prime modulus, Fermat's Little Theorem (or the Extended Euclidean Algorithm) is usually faster. // complexity -&gt; O(sqrt(mod)) // Function to compute gcd (needed to check if inverse exists) int gcd(int a, int b) { return b == 0 ? a : gcd(b, a % b); } // Function to compute Euler's totient function φ(m) int euler_phi(int m) { int result = m; for (int p = 2; p * p &lt;= m; p++) { if (m % p == 0) { while (m % p == 0) m /= p; result -= result / p; } } if (m &gt; 1) result -= result / m; return result; } // Function to compute a^b mod m using fast exponentiation int power(int x, int n, int mod) { //O(logn) int ans = 1; while (n &gt; 0) { if (n &amp; 1) { ans = 1LL * ans * x % mod; } x = 1LL * x * x % mod; n &gt;&gt;= 1; } return ans; } // Function to compute modular inverse using Euler's theorem long long inverse_using_euler(long long a, long long m) { if (gcd(a, m) != 1) { cout &lt;&lt; \"Inverse doesn't exist (a and m are not coprime).\" &lt;&lt; endl; return -1; } long long phi_m = euler_phi(m); return power(a, phi_m - 1, m); } int main() { int a = 3, m = 7; long long inv = inverse_using_euler(a, m); if (inv != -1) { cout &lt;&lt; \"The modular inverse of \" &lt;&lt; a &lt;&lt; \" mod \" &lt;&lt; m &lt;&lt; \" is \" &lt;&lt; inv &lt;&lt; endl; } return 0; } . | **_Using Bezout's Lemma (Extended Euclidean Algorithm)_** (most efficient) | . Bézout's Lemma states that for any integers a and b and gcd(a,b) = g, there exist integers x and y such that: ax + by = g We are trying to solve the congruence, AX ≡ 1(mod M). We can convert this to an equation. AX ≡ 1(mod M) AX + MY = 1 (mod M) =&gt; AX + (M%M)Y = AX + (0)Y = 1 (mod M) Here, both X and Y are unknown. This is a linear equation and we want to find integer solution for it. Which means, this is a Linear Diophantine Equation. // Returns gcd(a, b) and sets x and y such that a*x + b*y = gcd(a, b) // int extended_gcd(int a, int b, int &amp;x, int &amp;y) { // if (b == 0) { // x = 1; // y = 0; // return a; // } // int x1, y1; // int gcd = extended_gcd(b, a % b, x1, y1); // x = y1; // y = x1 - (a / b) * y1; // return gcd; // } int ext_gcd(int A, int B, int *X, int *Y) { int x2, y2, x1, y1, x, y, r2, r1, q, r; x2 = 1; y2 = 0; x1 = 0; y1 = 1; for (r2 = A, r1 = B; r1 != 0; r2 = r1, r1 = r, x2 = x1, y2 = y1, x1 = x, y1 = y) { q = r2 / r1; r = r2 % r1; x = x2 - (q * x1); y = y2 - (q * y1); } *X = x2; *Y = y2; return r2; } int modInv(int a, int m) { int x, y; ext_gcd(a, m, &amp;x, &amp;y); // Process x so that it is between 0 and m-1 //x can be large, can be (-ve) x %= m; if (x &lt; 0) x += m; //a*x % m = 1 confirmed return x; } . | **_Dynamic Programming Approach_** (when need many inverses) | . Efficient Computation of Modular Inverses . This is an efficient method to compute modular inverses for integers from 1 to N-1 using an iterative approach based on the Extended Euclidean Algorithm. Modular Inverse Basics . The modular inverse of an integer a modulo m is an integer x such that: . a * x ≡ 1 (mod m) . For a prime modulus mod, every integer a not divisible by mod has a unique inverse. Fermat’s Little Theorem . For a prime mod and a not divisible by mod: . a^(mod-1) ≡ 1 (mod mod) =&gt; a * a^(mod-2) ≡ 1 (mod mod) . Thus, a^(mod-2) is the inverse of a. However, computing this for each number up to N using exponentiation would be O(N log mod), which is less efficient than the dynamic programming approach shown. Dynamic Programming Approach . The given code uses a recurrence relation based on the following mathematical insight: . For a prime mod and i &lt; mod, we can express the inverse of i as: . inv[i] ≡ - (mod / i) * inv[mod % i] (mod mod) . Here’s why this works: . | Let mod = q*i + r, where q = mod // i and r = mod % i (so 0 &lt; r &lt; i). | Then, modulo mod: q*i + r ≡ 0 (mod mod) =&gt; r ≡ -q*i (mod mod) . | Multiply both sides by inv[i] * inv[r]: r * inv[i] * inv[r] ≡ -q * i * inv[i] * inv[r] (mod mod) . | Since i * inv[i] ≡ 1 (mod mod) and r * inv[r] ≡ 1 (mod mod), this simplifies to: inv[i] ≡ -q * inv[r] (mod mod) . | Substituting back q = mod // i and r = mod % i: inv[i] ≡ (mod - (mod // i)) * inv[mod % i] % mod . | . Code Explanation . inv[1] = 1; // Base case: 1*1 ≡ 1 mod any number for (int i = 2; i &lt; N; i++) { inv[i] = 1LL * (mod - mod / i) * inv[mod % i] % mod; } . | inv[1] = 1: The inverse of 1 is always 1. | For each i &gt; 1, the inverse is computed as (mod - mod/i) * inv[mod % i] % mod. | mod - mod/i is equivalent to -mod/i modulo mod (but ensures positivity). | inv[mod % i] is already computed because mod % i &lt; i. | . | . Complexity Analysis . | Iterative approach: O(N) time complexity. | Fermat’s theorem (for prime mod): O(N log N) if computed separately. | Advantage: This method is significantly faster for large N. | . Example Computation (mod = 7) . For N = 7, the computed modular inverses are: . | i | inv[i] | . | 1 | 1 | . | 2 | 4 | . | 3 | 5 | . | 4 | 2 | . | 5 | 3 | . | 6 | 6 | . Each satisfies the modular inverse property: . 1 * 1 ≡ 1, 2 * 4 ≡ 1, 3 * 5 ≡ 1, 4 * 2 ≡ 1, 5 * 3 ≡ 1, 6 * 6 ≡ 1 (mod 7) . This method is possible because: . | The recurrence relation correctly expresses the inverse of i in terms of the inverse of mod % i. | The dynamic programming approach ensures we compute inverses in the correct order (smallest to largest). | The prime modulus guarantees the existence of inverses for all i &lt; mod. | . This is one of the most efficient ways to precompute modular inverses for a range of numbers when the modulus is prime. This approach is widely used in competitive programming and number theory problems to efficiently precompute modular inverses for multiple values. Best Choice? - If is prime → Fermat’s Little Theorem (fast exponentiation). - If is not prime → Extended Euclidean Algorithm (Bézout’s Lemma) (most efficient). - If you need many inverses → Dynamic Programming approach. Fermat’s Little Theorem is fine but not better than Bézout. example: . | hackerearth_modular inverse You have been a number A. You need to output the inverse of number A modulo 1e9+7 . | eolymp9606_modular division Three positive integers a,b, and n are given. Compute the value of a / b mod n. In other words, find a value x such that b⋅x = a mod n. n&lt;=2e9, 1 &lt; a,b &lt; n -&gt; (a*inverse(b))%n . | . ",
    "url": "/09_number_theory/4_multiplicative_functions/2_modular_multiplicative_inverse/",
    
    "relUrl": "/09_number_theory/4_multiplicative_functions/2_modular_multiplicative_inverse/"
  },"43": {
    "doc": "1 eulers fermats coprime",
    "title": "1 eulers fermats coprime",
    "content": "- no common factors other than one . | How Many Primes are There? | . example: . | spoj_VECTAR8 - Primal Fear | . They are afraid of the prime numbers (without the digit zero), that remain prime no matter how many of the leading digits are omitted. For example, they are afraid of 4632647 because it doesn't have the digit 0 and each of its truncations (632647, 32647, 2647, 647, 47, and 7) are primes. #given a number of N, find out the number of primes not greater that N, that changu and mangu are afraid of. T ≤ 10^5, 1 ≤ N &lt; 10^6 if(num has digit 0)return false; if(it's truncations not prime)return false; otherwise true; . | spoj_HS08PAUL_A conjecture of Paul Erdős | . #find the number of (positive) primes not larger than n which are of the form x2+y4 (where x and y are integers). Fermat’s Little Theorem . https://en.wikipedia.org/wiki/Fermat’s_little_theorem . In number theory, Fermat's little theorem states that if p is a prime number, then for any integer a, the number ap − a is an integer multiple of p. In the notation of modular arithmetic, this is expressed as a^p ≡ a (mod p) For example, if a = 2 and p = 7, then 2^7 = 128, and 128 − 2 = 126 = 7 × 18 is an integer multiple of 7. - Let p be a prime which does not divide the integer a(a is coprime to p), then ap-1 ≡ 1 (mod p). For example, if a = 2 and p = 7, then 2^6 = 64, and 64 − 1 = 63 = 7 × 9 is a multiple of 7. Fermat's(Pierre de Fermat) little theorem says that as long as the modulus m is a prime number (1e9+7 is prime, and so is 998 244 353, then am mod m = a mod m. Working backwards, am−1 mod m = 1 = a⋅am−2 mod m Note that this only works for a mod m≠0, because there is no number x such that 0⋅x mod m=1. In other words, you still can't divide by 0. Fermat’s theorem states that, xm−1 mod m = 1, when m is prime and x and m are coprime. This also yields xk mod m = xk mod (m−1) mod m. | Proof of Fermat's Little Theorem | . xn ≡ xn mod (p-1) (mod p), if p is prime - because x^0, x^1, x^2 ... cycles after p-1 terms More generally, Euler’s theorem states that, xϕ(m) mod m = 1, when x and m are coprime. Fermat’s theorem follows from Euler’s theorem, because if m is a prime, then ϕ(m) = m − 1. | Fermat's theorem (more) | . - Fermat's Last Theorem, about integer solutions to a^n + b^n = c^n - Fermat's little theorem, a property of prime numbers - Fermat's theorem on sums of two squares, about primes expressible as a sum of squares - Fermat's theorem (stationary points), about local maxima and minima of differentiable functions - Fermat's principle, about the path taken by a ray of light - Fermat polygonal number theorem, about expressing integers as a sum of polygonal numbers - Fermat's right triangle theorem, about squares not being expressible as the difference of two fourth powers . Euler’s Totient Theorem . - Euler's theorem is a generalization of Fermat's little theorem For m ∈ Z&gt;1, Euler’s totient function φ(m) counts the number of positive integers not exceeding m relatively prime to m. It turns out this is a very useful function for us in modular arithmetic. Euler’s totient function ϕ(n) gives the number of coprime numbers to n between 1 and n. - φ(12) -&gt; The prime factorization of 12 is 2^2 · 3, so φ(12) = 12 · 1/2 · 2/3 = 4. However, φ(12) also counts thenumber of positive integers not exceeding 12 relatively prime to 12. There are also four of these,1, 5, 7, and 11, as expected. Because 1, 5, 7 and 11 are coprime to 12. - What is φ(p) for prime p? -&gt; All positive integers less than p are relatively prime to p. Therefore, φ(p) = p − 1 . - For m ∈ Z&gt;1, prove that aφ(m) ≡ 1 (mod m) for all integers a such that gcd(a, m) = 1. This is known as Euler’s totient theorem. - For m, b ∈ Z&gt;1, show that ab ≡ ab mod φ(m) (mod m) for all integers a such that (a, m) = 1. - φ(n) =&gt; how much (1 &lt;= x &lt;= n) such that x and n are coprime - φ(p) = p − 1, where p is prime - φ(8) = 8 - (2, 4, 6, 8) &lt;- 23 =&gt; 8 - no. of multiple of 2 - φ(27~3^3) = 27 - no. of multiple of 3 = 18 &lt;- (27 - 27/3) - φ(10) = φ(2).φ(5) = (2-1).(5-1) = 4 (because 2, 5 are prime) - φ(100) = φ(2^2).φ(5^2) = (2^2-2^1).(5^2-5^1) = 40 . | Formula1: | . \\phi(n) = (p_1^{a_1} - p_1^{a_1 - 1}) \\cdot (p_2^{a_2} - p_2^{a_2 - 1}) \\cdot \\dots \\cdot (p_k^{a_k} - p_k^{a_k - 1}) . | Formula2: (only weekness have to divide - it has difficult when mod is apply - but very easy to use) | . \\phi(n) = n \\cdot \\left(1 - \\frac{1}{p_1} \\right) \\cdot \\left(1 - \\frac{1}{p_2} \\right) \\cdots \\left(1 - \\frac{1}{p_k} \\right) . int eulerTotient(int m) { int ans = m; for (int p = 2; p * p &lt;= m; ++p) { if (m % p == 0) { while (m % p == 0) { m /= p; } ans -= ans / p;//actual part } } if (m &gt; 1) { ans -= ans / m; } return ans; } . | Phi from Factorization | . int phi(int n) { vector&lt;int&gt; primes = factorize(n);//unique primes for (int p : primes) { n = n - n / p; } return n; } . | Seive Based Implementation of Phi | . //no optimization allow const int maxn = 1000000; int phi[maxn + 5]; bool mark[maxn + 5]; void seive() { for (int i = 1; i &lt;= maxn; i++) { phi[i] = i; } for (int i = 2; i &lt;= maxn; i++) { if (mark[i]) continue; phi[i] = i - 1; //for i which is prime for (int j = i + i; j &lt;= maxn; j += i) { mark[j] = true; phi[j] = phi[j] - phi[j] / i; } } } . \\begin{array}{|c|c|} \\hline \\textbf{Fermat's Little Theorem} &amp; \\textbf{Euler's Theorem} \\\\ \\hline \\text{If } p \\text{ is prime, and } a \\not\\equiv 0 \\pmod{p} &amp; \\text{If } \\gcd(a, m) = 1 \\\\ a^{p-1} \\equiv 1 \\pmod{p} &amp; a^{\\phi(m)} \\equiv 1 \\pmod{m} \\\\ \\hline \\end{array} . Application: # 0 &lt; a/b &lt;= 1, b &lt;= 10, a/b has no common factor(completly reduced form means a,b are coprime) how much fraction has possible? =&gt; b = 1 2 3 4 5 6 7 8 9 10 φ(1) + φ(2) + φ(3) + ... + φ(10) -&gt; reduced fraction -&gt; changes are use of phi # n = 100, x&lt;=100; how much x such that gcd(100,x) = 1 -&gt; φ(100) how much x such that gcd(100,x) = 5 =&gt; x/5 &lt;= 20, ... gcd(100/5,x/5) = 1 -&gt; φ(20) (two are equivalent) # 5100200 (mod 13) =&gt; 5100200(mod φ(13)) (mod 13) -&gt; if upper is too large (doesn't fit into any ds) than chage like that -&gt; make to manageable form. =&gt; 510 = 522 (mod 13) ... same as 534 = 546 = ... = 510 . 512 (mod 13) ... = 510 . 512 mod φ(13) (mod 13) = 510 . 1 (mod 13) # abcd (mod m) . example: . | Find the Last Two Digits of 781 - 381 Step 1: What are the last two digits? The last two digits of a number are the remainder when the number is divided by 100. We need to compute: 7^81 - 3^81 (mod 100) Step 2: Apply Euler's Totient Theorem Euler's Totient Theorem states: a^φ(n) ≡ 1 (mod n), if gcd(a, n) = 1. Here: n = 100 φ(100) = 40 (calculated as φ(100) = 100 × (1 - 1/2) × (1 - 1/5) = 40). Since both 7 and 3 are coprime to 100: 7^40 ≡ 1 (mod 100) 3^40 ≡ 1 (mod 100) Step 3: Reduce the exponents modulo φ(100) Since 81 mod 40 = 1: 7^81 ≡ 7^1 (mod 100) 3^81 ≡ 3^1 (mod 100) Step 4: Compute the difference Substitute the simplified results: 7^81 - 3^81 ≡ 7 - 3 ≡ 4 (mod 100) Final Answer: The last two digits of 7^81 - 3^81 are 04. | What is the remainder when 69354 is divided by 89? 89 is prime, so φ(89) = 88. Then, 69^354 ≡ 69^354 mod 88 ≡ 69^2 ≡ (−20)^2 ≡ 400 ≡ 44 (mod 89). | 2017 AMC 10B Problems/Problem 14 . An integer N is selected at random in the range 1 ≤ N ≤ 2020. What is the probability that the remainder when N16 is divided by 5 is 1? -&gt; Step 1: Restate the Problem We want to determine the probability that N^16 ≡ 1 (mod 5) for integers N in the range 1 ≤ N ≤ 2020. Step 2: Apply Fermat’s Little Theorem Fermat’s Little Theorem states: N^(p-1) ≡ 1 (mod p), where p is a prime number and N ≢ 0 (mod p). Here, p = 5, so for N ≢ 0 (mod 5): N^4 ≡ 1 (mod 5). Step 3: Extend the Result to N^16 Using the property of exponents: N^16 = (N^4)^4. Since N^4 ≡ 1 (mod 5), we have: N^16 ≡ 1^4 ≡ 1 (mod 5). Thus, for all N ≢ 0 (mod 5), N^16 ≡ 1 (mod 5). Step 4: Count N ≢ 0 (mod 5) Among the integers 1 ≤ N ≤ 2020, exactly 1/5 of them are divisible by 5. This is because the sequence of multiples of 5 is 5, 10, 15, ..., 2020, and there are: 2020 ÷ 5 = 404 multiples of 5. Thus, the remaining 2020 - 404 = 1616 values of N satisfy N ≢ 0 (mod 5), for which N^16 ≡ 1 (mod 5). Step 5: Compute the Probability The probability that N^16 ≡ 1 (mod 5) is the fraction of N values for which N ≢ 0 (mod 5): Probability = (Count of N ≢ 0 (mod 5)) / (Total Count of N) = 1616 / 2020 = 1 - (404 / 2020) = 1 - 1/5 = 4/5. Final Answer: The probability is: 4/5 . | What are the last two digits in the decimal representation of 201120122013? . 1. Simplify Base Modulo 100: 2011 ≡ 11 (mod 100), so the problem becomes 1120122013 mod 100. 2. Apply Euler's Totient Theorem: φ(100) = 40, so 1140 ≡ 1 (mod 100). Reduce the exponent 20122013 mod 40. 3. Simplify Exponent Modulo 40: 2012 ≡ 12 (mod 40), and 12k mod 40 cycles with length 4. Since 2013 ≡ 1 (mod 4), 20122013 ≡ 12 (mod 40). 4. Compute 1112 mod 100: - 112 ≡ 21 (mod 100), - 114 ≡ 41 (mod 100), - 118 ≡ 81 (mod 100), - 1112 ≡ 81 * 41 ≡ 21 (mod 100). Final Answer: 21. | CSES-1712_Exponentiation II | . we have to find abc modulo 1e9+7 - not working in normal way, we have to use euler's totient theorem - To find the multiplicative order of a modulo m, first find φ(m), i.e. Euler's totient of m. Then brute force over the divisors of the totient; the multiplicative order must be one of the divisors. | spojPOWERUP - Power the Power Up | . (a^b)^c mod 1e9+7 where a, b and c (0 &lt;= a, b, c &lt;= 2^31 - 1). | uva10990 Another New Function | . The depth of phi value of a number is denoted by the number of steps required before it reaches 1(repeateadly apply) Given the value of m and n your job is to find the value of SODF(m; n). Sum of depthphi function . | uva10179 Irreducible Basic Fractions | . A fraction m/n is basic if 0 ≤ m &lt; n and it is irreducible if gcd(m, n) = 1. Given a positive integer n, in this problem you are required to find out the number of irreducible basic fractions with denominator n(&lt; 1000000000) 4 irreducible basic fractions with denominator 12 0/12 , 5/12 , 7/12 , 11/12 . | spoj_GCDEX - GCD Extreme | . G = 0; for (i = 1; i &lt; N; i++) for (j = i+1; j &lt;= N; j++) G += gcd(i, j); The input file contains at most 20000 lines of inputs. Each line contains an integer N (1 &lt; N &lt; 1000001). 🔢 Definitions of ( G(N) ) . 1. Double Summation Form: . G(N) = \\sum_{i=1}^{N} \\sum_{j=i}^{N} \\gcd(i, j) . This is the basic definition of GCD Extreme — sum of GCDs for all pairs ( (i, j) ) where ( i \\leq j ). 2. Ellipsis Notation: . G(N) = \\gcd(1, 1 \\ldots N) + \\gcd(2, 2 \\ldots N) + \\cdots + \\gcd(N, N) . This informal form emphasizes the “extreme” pairwise GCDs — each number with all larger or equal numbers. 3. Optimized Formula (with Totient Function): . G(N) = \\sum_{d=1}^{N} d \\cdot \\varphi\\left( \\left\\lfloor \\frac{N}{d} \\right\\rfloor \\right) . This is the high-performance version used to efficiently compute ( G(N) ) for large ( N ), using number theory and Euler’s totient function. above solution would be like, . \\begin{aligned} F(1) &amp;= 1 \\cdot \\varphi(1) \\\\ F(2) &amp;= 1 \\cdot \\varphi(2) + 2 \\cdot \\varphi(1) \\\\ F(3) &amp;= 1 \\cdot \\varphi(3) + 3 \\cdot \\varphi(1) \\\\ F(4) &amp;= 1 \\cdot \\varphi(4) + 2 \\cdot \\varphi(2) + 4 \\cdot \\varphi(1) \\\\ F(5) &amp;= 1 \\cdot \\varphi(5) + 5 \\cdot \\varphi(1) \\\\ F(6) &amp;= 1 \\cdot \\varphi(6) + 2 \\cdot \\varphi(3) + 3 \\cdot \\varphi(2) + 6 \\cdot \\varphi(1) \\\\ \\end{aligned} . ",
    "url": "/09_number_theory/4_multiplicative_functions/1_eulers_fermats_coprime/",
    
    "relUrl": "/09_number_theory/4_multiplicative_functions/1_eulers_fermats_coprime/"
  },"44": {
    "doc": "2 euclidean algorithms",
    "title": "2 euclidean algorithms",
    "content": ". | GCD | . int gcd(int a, int b) { return b == 0 ? a : gcd(b, a % b); } . | LCM | . lcm(a,b) = (a*b)/gcd(a,b) . LCM and GCD Relationships: - For any prime k, the exponent in LCM(p, q) is the maximum of the exponents of k in p and q. - For any prime k, the exponent in GCD(p, q) is the minimum of the exponents of k in p and q. | https://codeforces.com/blog/entry/95694 | . \\[\\begin{array}{|c|l|} \\hline \\textbf{Property} &amp; \\textbf{Description} \\\\ \\hline \\text{Linear Combination} &amp; \\gcd(a, b) = d = ap + bq \\\\ \\hline \\text{Divisor of GCD} &amp; \\text{Every common divisor of } a \\text{ and } b \\text{ divides } \\gcd(a, b) \\\\ \\hline \\text{GCD of Zero} &amp; \\gcd(a, 0) = |a| \\text{ for } a \\ne 0 \\\\ \\hline \\text{Division Lemma} &amp; a \\mid bc \\text{ and } \\gcd(a, b) = d \\Rightarrow \\frac{a}{d} \\mid c \\\\ \\hline \\text{Scaling Rule} &amp; \\gcd(ma, mb) = m \\cdot \\gcd(a, b) \\\\ \\hline \\text{Coprime Reduction} &amp; \\text{If } \\gcd(a, b) = g, \\text{ then } \\frac{a}{g} \\perp \\frac{b}{g} \\\\ \\hline \\text{Additive Property} &amp; \\gcd(a, b) = \\gcd(a + mb, b) \\\\ \\hline \\text{Euclidean Algorithm} &amp; \\gcd(a, b) = \\gcd(b, a \\bmod b) \\\\ \\hline \\text{Factor Reduction} &amp; \\gcd\\left(\\frac{a}{m}, \\frac{b}{m}\\right) = \\frac{\\gcd(a, b)}{m} \\text{ if } m \\mid a, m \\mid b \\\\ \\hline \\text{Multiplicative GCD} &amp; a_1 \\perp a_2 \\Rightarrow \\gcd(a_1 a_2, b) = \\gcd(a_1, b)\\gcd(a_2, b) \\\\ \\hline \\text{GCD 1 Case} &amp; \\gcd(a, bc) = 1 \\Leftrightarrow \\gcd(a, b) = \\gcd(a, c) = 1 \\\\ \\hline \\text{Commutativity} &amp; \\gcd(a, b) = \\gcd(b, a) \\\\ \\hline \\text{Associativity} &amp; \\gcd(a, \\gcd(b, c)) = \\gcd(\\gcd(a, b), c) \\\\ \\hline \\text{GCD \\&amp; LCM} &amp; \\gcd(a, b) \\cdot \\text{lcm}(a, b) = |ab| \\\\ \\hline \\text{Distributive 1} &amp; \\gcd(a, \\text{lcm}(b, c)) = \\text{lcm}(\\gcd(a, b), \\gcd(a, c)) \\\\ \\hline \\text{Distributive 2} &amp; \\text{lcm}(a, \\gcd(b, c)) = \\gcd(\\text{lcm}(a, b), \\text{lcm}(a, c)) \\\\ \\hline \\text{Prime Factor Form} &amp; \\gcd(a, b) = \\prod p_i^{\\min(e_i, f_i)} \\text{ for } a = \\prod p_i^{e_i}, b = \\prod p_i^{f_i} \\\\ \\hline \\text{Lattice Points} &amp; \\gcd(a, b) = \\text{number of lattice points on the segment from } (0,0) \\text{ to } (a,b) \\\\ \\hline \\text{Power Mod Formula} &amp; \\gcd(n^a - 1, n^b - 1) = n^{\\gcd(a, b)} - 1 \\\\ \\hline \\text{Totient Identity} &amp; \\gcd(a, b) = \\sum_{k \\mid a,\\,k \\mid b} \\varphi(k) \\\\ \\hline \\end{array}\\] . | https://aryansh-s.github.io/assets/pdf/The_Art_of_Modular_Arithmetic.pdf p29_sol | . Basic Examples: . | What is the largest positive integer that divides 40 and 78(gcd(a,b))? | What about the smallest positive integer divisible by 40 and 78(lcm(a,b))? | . - Greedily, if we want to find the largest positive integer that divides 40 an 78, we need to selectively multiply together the largest power of each prime divisor common to both. - To find the smallest positive integer divisible by both 40 and 78, we again take a greedy approach: selectively multiply together the smallest power of each prime divisor that satisfies the divisibility requirement. | AOPS_1951 AHSME Problems/Problem 19 | . A six place number is formed by repeating a three place number; for example, 256256 or 678678, etc. Any number of this form is always exactly divisible by(gcd of all numbers of this forms)? -&gt; The number abcabc can be rewritten as 1000abc + abc (constructively, think of shifting the second abc three places to the right to make room for the first abc). Therefore, it is just 1001abc, and since nothing more can be said about abc, the answer is 1001 . | 1325A EhAb AnD gCd | . Find any such 2 positive integers a and b such that gcd(a,b) + lcm(a,b) = x, 2 &lt;= x &lt;= 1e9 (1,x-1) . Advanced Examples . | https://codeforces.com/problemset/problem/1866/B | . LCM and GCD Relationships: For any prime k, the exponent in LCM(p, q) is the maximum of the exponents of k in p and q. For any prime k, the exponent in GCD(p, q) is the minimum of the exponents of k in p and q. Exponent Conditions: For each prime k in X and Y, we must have: max(fk(p), fk(q)) = fk(X) min(fk(p), fk(q)) = fk(Y) Here, fk(p) denotes the exponent of prime k in p. Feasibility Check: If for any prime k, fk(Y) &gt; fk(X), it's impossible to satisfy both conditions, so the answer is 0. If fk(Y) = fk(X), then fk(p) = fk(q) = fk(X). If fk(Y) &lt; fk(X), there are two choices: fk(p) = fk(X) and fk(q) = fk(Y). fk(p) = fk(Y) and fk(q) = fk(X). The final result is 2 raised to the power of the number of primes where the exponent in X is greater than in Y, . | 343A_Rational Resistance | . # needs to assemble an element with a resistance(1 ohm) equal to the fraction of a/b. # determine the smallest possible number of resistors needs to make such an element. has lots of identical resistors with unit (1 ohm) resistance. our need resistance value can be constructed with these. e = x/y (resistance of a element, can be fraction because of parallelism) series: (x/y)+1 =&gt; (x+y)/y &gt;1; (1&lt;=a,b&lt;=1e18) parallel: 1/((1/(x/y))+1/1) =&gt; x/(x+y) &lt;1; (1&lt;=a,b&lt;=1e18) # If a fraction a/b can be obtained with k resistors, then it is simple to calculate that we can obtain fractions (a+b)/b and a/(a+b) with k + 1 resistors. So adding one resistor means performing one operation backwards in Euclidean algorithm. That means that the answer is equal to the number of steps in standard Euclidean algorithm. a/b = 1 + f(x/y) a &gt; b =&gt; ((x+y)/y ~ a/b) =&gt;x/y = a-b/a ---a/b = 1 + f(b,a-b) a &lt; b =&gt; (x/(x+y) ~ a/b) =&gt;x/y = a/b-a ---a/b = 1 + f(a,b-a) TLE-if use gcd(a,b-a)//O(N)~1e18 1+gcd(a%b,b) return lower value, we need upper value like 1+gcd(a-b,b) ex. 1+gcd(100%1,1)=2 , 1+gcd(100-1,1)=100 ~because we need num of resister(total num of time it called) but a/b + gcd(a%b,b) = 1+gcd(a-b,b) =&gt; produce same result . | Extended GCD | . gcd(15,51) = 3, Bezout's Lemma say, 15x + 51y = 3 =&gt; 15|51|3 45 -- 6|15|2 12 -- 3|6|2 6 -- 0 51 = 15(3)+6 --- I 15 = 6(2)+3 --- II 6 = 3(2)+0 --- III II=&gt; 6(2) = 15-3 =&gt; 6 = (15-3)/2 ---IV then from eq. I =&gt; 51 = 15(3)+6 =&gt; 51 = 15(3)+(15-3)/2; =&gt; 51(2) = 15(6) + 15 - 3 = 15(7) - 3 =&gt; 3 = 15(6) + 51(-2) . # Finding Bézout Coefficients for gcd(8, 5) = 1 We want integers `x` and `y` such that: 8x + 5y = 1 Step 1: Apply the Euclidean Algorithm We apply the Euclidean algorithm to compute gcd(8, 5): 8 = 5 × 1 + 3 (I) 5 = 3 × 1 + 2 (II) 3 = 2 × 1 + 1 (III) 2 = 1 × 2 + 0 (IV) Since the remainder becomes 0 in the last step, the GCD is the previous remainder, which is 1. Step 2: Back-Substitute to Find x and y From (III): 1 = 3 - 2 × 1 (A) From (II): 2 = 5 - 3 × 1 (B) Substitute (B) into (A): 1 = 3 - (5 - 3 × 1) × 1 = 3 - 5 × 1 + 3 × 1 = 3 × 2 + 5 × (-1) From (I): 3 = 8 - 5 × 1 (C) Substitute (C) into the previous expression: 1 = (8 - 5 × 1) × 2 + 5 × (-1) = 8 × 2 - 5 × 2 + 5 × (-1) = 8 × 2 + 5 × (-3) Final Result: Bézout Coefficients x = 2, y = -3 Verification 8 × 2 + 5 × (-3) = 16 - 15 = 1 ✓ Thus, the Bézout identity holds: 8×2 + 5×(−3) = 1 . General Solution Structure . If (x₀, y₀) is one solution, then all solutions are given by: . x = x₀ + k ⋅ (b / d) y = y₀ - k ⋅ (a / d) . where: . | d = gcd(a, b) | k is any integer. | . This means there are infinitely many integer solutions to the equation ax + by = gcd(a, b) if at least one solution exists. //using recursion int extended_gcd(int a, int b, int &amp;x, int &amp;y) { if (b == 0) { x = 1; y = 0; return a; } int x1, y1; int gcd = extended_gcd(b, a % b, x1, y1); x = y1; y = x1 - (a / b) * y1; return gcd; } . //*** int ext_gcd(int A, int B, int *X, int *Y) { int x2, y2, x1, y1, x, y, r2, r1, q, r; x2 = 1; y2 = 0; x1 = 0; y1 = 1; for (r2 = A, r1 = B; r1 != 0; r2 = r1, r1 = r, x2 = x1, y2 = y1, x1 = x, y1 = y) { q = r2 / r1; r = r2 % r1; x = x2 - (q * x1); y = y2 - (q * y1); } *X = x2; *Y = y2; return r2; } . example: . | uva10104 - Euclid Problem | . From Euclid it is known that for any positive integers A and B there exist such integers X and Y that AX + BY = D, where D is the greatest common divisor of A and B. The problem is to find for given A and B corresponding X, Y and D. For each input line the output line should consist of three integers X, Y and D, separated with space. If there are several such X and Y , you should output that pair for which |X| + |Y | is the minimal. If there are several X and Y satisfying the minimal criteria, output the pair for which X ≤ Y . ",
    "url": "/09_number_theory/2_euclidean_algorithms/",
    
    "relUrl": "/09_number_theory/2_euclidean_algorithms/"
  },"45": {
    "doc": "2 divisibility rule",
    "title": "2 divisibility rule",
    "content": "- The divisibility rule for 3 is based on the canonical sum of the digits -&gt; A number is divisible by 3 if and only if the sum of its digits is divisible by 3 N = ak⋅10k + ak−1⋅10k−1 + ⋯ + a1⋅101 + a0.100 - decimal representation of a number 10 ≡ 1 (mod 3) 10n ≡ 1 (mod 3),for any n≥0. (Raising 10 to any power preserves this property) then, N = ak⋅1 + ak−1⋅1 + ⋯ + a1⋅1 thus, N ≡ (sum of digits of N) (mod 3). - Divisivility Rule of 6 (2, 3 both to be divisible), 12 (3, 4 both) - Divisivility Rule of 7 (it suffices to remove its final digit and then subtract twice this digit from whatever remains. For example, we can say 434 is divisible by 7 because 43 − 2(4) = 35) . https://unacademy.com/content/clat/study-material/quantitative-techniques/divisibility-rule/ https://www.cuemath.com/numbers/divisibility-rules/ . source:- Introduction to Number Theory by Mathew Crawford . example: . | 2014 AMC 8 Problems/Problem 8 . Eleven members of the Middle School Math Club each paid the same amount for a guest speaker to talk about problem solving at their math club meeting. They paid their guest speaker $1A2. What is the missing digit A of this 3-digit number? -&gt; it must be divisible by 11 We know that a number is divisible by 11 if the odd digits added together minus the even digits added together (or vice versa) is a multiple of 11. Thus, we have $1+2-A = a multiple of 11. The only multiple that works here is 0, as 11 . 0 = 0. Thus, A = 3 . | 2018 AMC 8 Problems/Problem 7 . The 5-digit number 2 0 1 8 U is divisible by 9. What is the remainder when this number is divided by 8? -&gt; By the divisibility rule for 9, 2 + 0 + 1 + 8 + U ≡ 2 + U ≡ 0 (mod 9) =⇒ U ≡ 7 (mod 9). By the divisibility rule of 2k, since 8 = 23, the answer is 187(last m digit) mod 8 = 3 . | 2016 AMC 8 Problems/Problem 24 . The digits 1, 2, 3, 4, and 5 are each used once to write a five-digit number PQRST. The three-digit number PQR is divisible by 4, the three-digit number QRS is divisible by 5, and the three-digit number RST is divisible by 3. What is P? -&gt; Since QRS is divisible by 5, S must be 5 (it can't be 0 because all digits are unique). PQR must be even, so R is 2 or 4. If R = 2, T would repeat a digit, which is not allowed. So, R = 4. With R = 4, T must be 3. Q can be 1 or 2. 24 (from QR) is divisible by 4, but 14 is not. So, Q = 2. The only remaining digit is P = 1. | 2017 AMC 10A Problems/Problem 20 . Let S(n) equal the sum of the digits of positive integer n. For example, S(1507) = 13. For a particular positive integer n, S(n) = 1274. Which of the following could be the value of S(n + 1)? (A) 1 (B) 3 (C) 12 (D) 1239 (E) 1265 -&gt; Note that n ≡ S(n) (mod 9). This follows from the fact that: ∑(k=0 to n) 10^k * a_k ≡ ∑(k=0 to n) a_k (mod 9). If S(n) = 1274, then: n ≡ 5 (mod 9). Thus: n+1 ≡ S(n+1) ≡ 6 (mod 9). The only answer choice satisfying n+1 ≡ 6 (mod 9) is: (D) 1239. | 375A_Divisible By Seven . # we need (num % 7 == 0) Rearrange the digits in its decimal representation so that the resulting number will be divisible by 7. It doesn't contain any leading zeroes and always contains digits 1, 6, 8, 9 {\"1869\", \"1968\", \"1689\", \"6198\", \"1698\", \"1986\", \"1896\"}%7={0,1,2,3,4,5,6}, find it using next_permutation. #({... Other num mod + (7-other num mod) mod from list }%7=0 + zero at last)%7=0 ex. (5+2+0)%7=0, (4+3+0)%7=0 . | 2050C_Uninteresting Number . Given a number n with length(1e5), perform operation any number of times (choose one of its digits, square it, and replace the original digit with the result) Is it possible to obtain a number that is (divisible by 9) through these operations? -&gt; divisibility test of 9 -&gt; sum of it's digit is divisible by 9 It states that a number is divisible by 9 if and only if the sum of its digits is divisible by 9. Let's see how the sum of the digits will change with the possible transformations. If we square 2, the sum of the digits increases by 2^2−2=2, and if we square 3, the sum of the digits increases by 3^2−3=6 We will count the number of digits 2 in the number and the number of digits 3 in the number. We can choose how many of the available digits 2 and 3 we will transform. Transforming more than 8 twos and more than 8 threes is pointless because remainders modulo 9 their transformation adds to the sum will repeat. Thus, the final solution looks like this: we calculate the sum of the digits in the number, count the number of digits 2 and 3. We will iterate over how many digits 2 we change (possibly 0, but no more than 8), and how many digits 3 we change (possibly 0, but also no more than 8). Let's say we changed x digits 2 and y digits 3, then the sum of the digits in the number increased by x∗2+y∗6. If new sum is divisible by 9, the answer is \"YES\". If such a situation was never reached during the iteration, then the answer is \"NO\". | . ",
    "url": "/09_number_theory/3_modular_arithmetic/2_divisibility_rule/",
    
    "relUrl": "/09_number_theory/3_modular_arithmetic/2_divisibility_rule/"
  },"46": {
    "doc": "1 basic modular operation",
    "title": "1 basic modular operation",
    "content": "https://libraryguides.centennialcollege.ca/c.php?g=717548&amp;p=5121821 https://codeforces.com/blog/entry/72527 https://aryansh-s.github.io/assets/pdf/The_Art_of_Modular_Arithmetic.pdf (upto Linear Congruences) . Basics . you may have noticed that some tasks, typically combinatorial and probability tasks, have this funny habit of asking you to calculate a huge number, then tell you that \"because this number can be huge, please output it modulo 1e9+7 or 998244353\". Two integers a and b may be deemed “equal“ in this system if they both correspond to the same hour on the clock(mod 12). However, to prevent confusion when a != b in standard arithmetic, we say that a and b are congruent and write this as a ≡ b. For example, because 2021, 17, and −19 all correspond to the same hour 5, we can write 2021 ≡ 17 ≡ −19 ≡ 5 First, we write the notion that two integers a and b correspond to the same hour on this general m-hour clock in modular form as -&gt; a ≡ b (mod m), pronounced “a is congruent to b modulo m,“ where the (mod m) modular suffix helps us keep track of the modulus m. This relation as a whole is known as a modular congruence. ---- -&gt; 3 and 7 are basically the same if computing modulo 4, since 3 mod 4 = 3 = 7 mod 4. This concept, where numbers with the same remainder are treated as if they are equal is called congruence. -&gt; If a and b have the same remainder when divided by n, we say that a and b are congruent modulo n, written a ≡ b (mod n), or equivalently, their difference a−b is a multiple of n, written n∣(a−b) -&gt; number a to be congruent to 0 modulo n, means n∣a, or n divides a evenly without a remainder. When a is divided by n, the remainder is 0. ---- Lastly, the hour an integer a corresponds to on a modulus m clock, equivalently the remainder of the division a ÷ m, can be written in modular remainder form as -&gt; a mod m (notice the omission of parentheses around the modular suffix) and is sometimes referred to as the modular residue of a (mod m). -&gt; when dividing a number a with a number n, you would get a quotient q and a remainder r. These numbers would satisfy the identity a = nq + r, with 0 ≤ r &lt; b. then, gcd(a,n) = gcd(q,r) . -&gt; a=b, b=c =&gt; a=c -&gt; a≡b (mod m) &lt;=&gt; m divides (a-b) //formal defination -&gt; a≡b (mod m) =&gt; a%m = b%m -&gt; 7+0 (mod 4) -&gt; 7 means (3,7,11,15...), 0 means (0,4,8,12...) -4 -3 -2 -1 0 1 2 3 4 5 6 7 8 0 1 2 3 0 1 2 3 0 1 2 3 0 -&gt; (-x+m)%m in cpp -x%m = -y (gives also a negative number) so (-x+m)%m is always same - Negative numbers are really powerful and often help simplify the arithmetic part of modular arithmetic. 89 ≡ −1 (mod 90) =⇒ 892021 ≡ (−1)2021 ≡ −1 ≡ 89 (mod 90) . //function call and mod operation is costly //it does not call untill we know x&gt;=0 int safeMod(int x,int m){ int y = x%m; if(y&lt;0)y+=m; return y; } . - % is often called the \"modulo operator\", but in some instances we call it the \"remainder operator\" - mod operator to have lower precedence than addition or subtraction, it's not a constant time operation (costly than other) - The value m after the modulo operator is known as the modulus. - The key identities of modular arithmetic are not only intuitive but easy to formalize through conversion from modular form to parametric form and vice versa . -&gt; in MODULAR arithmetic it is not gurranted that previous arithmatic rule is work or not. First off, some important identities about the modulo operator: # (a mod m) + (b mod m) mod m = (a + b) mod m # (a mod m) − (b mod m) mod m = (a − b) mod m//it has risk-&gt;check negative or not if (-ve) then +m # (a mod m) ⋅ (b mod m) mod m = (a ⋅ b) mod m//it may have overflow-&gt; be careful -&gt; use 1LL or long long int # we can not divide in modular arithmetic in general way -&gt; it works when remainder 1 like... 3 ≡ 33(mod 10)-&gt;1 ≡ 11(mod 10)//when divide by 3, we can not have 3 in 10 -&gt; a ≡ b(mod m) -&gt; we can do a/c≡b/c (mod m) when m and c not have common prime divisors -&gt; means m,c are co-prime // and not allow to divide when a/c or b/c have fraction -&gt;Special Divide (has effect-because we also have to divide m by that) -&gt; a/c≡b/c (mod m/c) =&gt; a/c≡b/c (mod m/gcd(m,c)) 8 ≡ 18(mod 10) =&gt; 4 ≡ 9(mod 5) # Why divide(/) is important in modular arithmetic? # a/b = x =&gt; a = b*x 3/7 = 9(mod 10) (exists/meaningful) because -&gt; 3 = 7*x (mod 10) =&gt; 3 = 63(mod 10) = 3 (mod 10) 3/7=? (mod 10) x can be 3,13,23,33,43,53,63... all is represented by 3 (we can try all) where 63 is valid -&gt; 31/2 = 36 (mod 41) -&gt; a/b = x (mod m) -&gt; 2*36 = 31 (mod 41) -&gt; b*x = a (mod m) # ab mod m = (a mod m)b mod m . //1+2+3+4+5+6+7+8 int mod = 41; int n = 8; int sum = n*(n+1);//we have to also divide by 2 sum%=mod; while(sum%2!=0){//untill we found a representation of sum that is divisible by 2 &gt;&gt;it is not gurranted when this loop stop - can be infinite loop sum+=mod; } sum/=2; cout&lt;&lt;sum%mod&lt;&lt;endl; //better solution is modular inverse . -&gt;modular inverse =&gt;x*x-1 = 1 =&gt; a*b = 1 (mod m)(where b is a modular inverse of a and b is always less than m) -&gt; a/b = x (mod m) =&gt; b*x = a (mod m) -&gt; 7*y = 1 (mod 10) 7*3 = 1 (mod 10) -&gt; 3 is equivalent to 1/7 then a*3 = 3*3 = 9 -&gt; all the time inverse(a) not possible only possible when gcd(a,m)=1//co-prime a and m 1 2 3 4 5 6 7 8 9 (mod 10) only inverse has -&gt; 1-&gt;1,3-&gt;7,7-&gt;3,9-&gt;9 mod value can have -&gt; (1e9+7 or 998244353-&gt;FFT) for that (1 to m-1) everyone is co-prime for that number so always have inverse mod = 81;//odd inverse(2) = ((mod+1)/2)%mod . //modular inverse - naive O(mod) int inverse(int a, int m) { for (int i = 1; i &lt; m; i++) { if (1LL * a * i % m == 1) { return i; } } return -1;//inverse doesn't exist } . # Equation solve -&gt; 3x + 5 = 7 (mod 10) =&gt; 3x = 7-5 = 2 7*3x = 2*7 (7*3 = 1 (mod 10)) x = 14 (mod 10) = 4 (mod 10) a*b = 0 (mod 10 composite) =&gt; maybe (a!=0 and b!=0) like 2*5 = 10 = 0 if mod = prime then either (a = 0, b!=0) or (b = 0, a!=0) -&gt; if mod(composite) = it's a number theory problem = more complex -&gt; if mod(prime) = it's not a number theory problem . - The day of the week corresponding to a certain day is given by its modular residue (mod 7) because there are 7 days in a week. - Even or odd parity is given by the modular residue (mod 2). - The units digit of a number is its modular residue (mod 10). Properties . -&gt; n mod m = n - floor(n/m)*m (This should be always produce an integer between 0 amd m-1 inclusive) -&gt; a mod m = b mod m =&gt; (a-b) mod m = 0 -&gt; x mod m = x if m&gt;x -&gt; x mod m &lt; x/2 when m &lt;= x -&gt; a − b = k*m; k ∈ Z (a and b differ by an integer multiple of m)//parametric form//by modular definitions -&gt; the result is always reduced to its remainder when divided by n. This is what \"modulo arithmetic\" means -&gt; The results \"wrap around\" n, forming a cycle. Operations like addition, multiplication, and subtraction respect this cyclical nature. Resolving the Division Anomaly . | Division is not straightforward and involves finding modular inverses, which exist only when the divisor is coprime to n. | Division does not work as you would expect in congruences (we can’t divide both sides of the congruence) . | . here is a way to make division work if we’re careful. Division in modular arithmetic works under specific conditions: If ad ≡ bd (mod m), where a, b, d, m ∈ Z, d ≠ 0, and m &gt; 1, then: a ≡ b (mod m / gcd(m, d)) Explanation: - Direct division isn’t always valid because d might share factors with m. - Adjusting the modulus by gcd(m, d) ensures the congruence holds. Example: 6x ≡ 12 (mod 18) - Here, d = 6, m = 18, gcd(18, 6) = 6. - Divide both sides by 6 and adjust modulus: x ≡ 2 (mod 3) . Final Thoughts . - fixed mod -&gt; use const (some optimisation in cpp) - make sure after each operation, the result is between 0 and m-1 - keep eyes in overflow (multiplication -&gt; always use long long). - do not work in division in general ways(division -&gt; modular inverse). - bitwise operation do not work with modular arithmetic. - subtraction -&gt; use if-else . (x + y) mod m = (x mod m + y mod m) mod m (a - b) mod m = (a mod m - b mod m + m) mod m (x · y) mod m = (x mod m · y mod m) mod m x^n mod m = (x mod m)^(n mod m-1) . Math Competitions Exercise . example: . | Find a closed form for the remainder of a ÷ m, where a, m ∈ Z+ . Because finding the remainder directly does not seem like an easy task, we first look for the quotient q. Because the quotient is the greatest number of times m goes into a, it is the integer part of a/m . But how do we truncate the fractional part? Apply the floor function! q =⌊a/m⌋ Our remainder becomes a − mq = a − m⌊a/m⌋ &lt;-- a % m . | 2017 AMC 12A Problems/Problem 11 . Claire adds the degree measures of the interior angles of a convex polygon and arrives at a sum of 2017. She then discovers that she forgot to include one angle. What is the degree measure of the forgotten angle? Soln1 -&gt; We know that the sum of the interior angles of the polygon is a multiple of 180, Note that ceil(2017/180) = 12 and 180 * 12 = 2160, so the angle Claire forgot is 2160-2017 = 143 (mod 180). Soln2 -&gt; Let x be the measure of the forgotten angle. The degree sum of the measures of the interior angles of an n-gon is 180(n − 2), or 180(n − 2) − x if we forget x. We can solve for x if we note that 180(n − 2) − x ≡ −x (mod 180). Claire’s sum of 2017 ≡ 37 ≡ −143 (mod 180), Thus, −𝑥 ≡ 37(mod 180) To find To find x, we multiply through by -1 (noting that modular arithmetic preserves equivalence): x ≡ -37, Since -37 mod 180 = 143, we have: x ≡ 143 (mod 180) so x ≡ 143 (mod 180). In fact, since x &lt; 180 due to the convex condition, x = 143◦. | 2000 AMC 12 Problems/Problem 18 In year N, the 300th day of the year is a Tuesday. In year N + 1, the 200th day is also a Tuesday. On what day of the week did the 100th day of the year N − 1 occur? Soln1 -&gt; Wednesday (if current year not leap year), If leap year then Thursday leap year -&gt; approximately every four years, February has 29 days instead of 28 condition of leap year -&gt; (y%4==0) and [(y%100=0) or (y%400==0)] . | 2014 AMC 8 Problems/Problem 13 If n and m are integers and n2 + m2 is even, which of the following is impossible? (A) n and m are even (B) n and m are odd (C) n + m is even (D) n + m is odd (E) none of these are impossible -&gt; Since n^2+m^2 is even, either both n^2 and m^2 are even, or they are both odd. Therefore, n and m are either both even or both odd, since the square of an even number is even and the square of an odd number is odd. | Units digit of the result . When the sum (1 · 2 · 3) + (2 · 3 · 4) + (3 · 4 · 5) + · · · + (2018 · 2019 · 2020) is evaluated, what is the units digit4 of the result? -&gt; The units digit is given by the residue (mod 10). Computing the residues for the first few terms reveals the repeating pattern: 6, 4, 0, 0, 0 (mod 10), with a sum of 6 + 4 + 0 + 0 + 0 ≡ 0 (mod 10). This pattern repeats k times, leaving a remainder of 2018 mod 5 = 3 terms, which are 6, 4, 0 (mod 10), with a sum of 6 + 4 + 0 ≡ 0 (mod 10). Thus, the answer is 0k + 0 ≡ 0 (mod 10). | Sum of all possible values of the units digit of the sum Al, Bob, and Carl each have favorite numbers so that the sum of Al and Bob’s favorite numbers has a units digit of 2, the sum of Bob and Carl’s favorite numbers has a units digit of 4, and the sum of Al and Carl’s favorite numbers has a units digit of 0. If their favorite numbers are all positive integers, what is the sum of all possible values of the units digit of the sum of their three favorite numbers? -&gt; Let their numbers be a, b, c by name. Since the units digit is the residue (mod 10), we are given the following: a + b ≡ 2 (mod 10) b + c ≡ 4 (mod 10) a + c ≡ 0 (mod 10) Adding the congruences gives us 2(a + b + c) ≡ 6 (mod 10) We can divide both sides of the congruence by 2 and the modulus by gcd(2, 10) = 2 : a + b + c ≡ 3 (mod 5) Going back to (mod 10), this means we have a + b + c ≡ 3, 8 (mod 10). Therefore, our answer is 3 + 8 = 11 -&gt; The modulo 5 solution a+b+c ≡ 3 (mod 5) lifts to modulo 10 because: 10 is a multiple of 5, and Adding 5 repeatedly cycles through two equivalence classes in modulo 10: 3(mod10) and 8(mod10). This is a fundamental property of modular arithmetic. | SPOJ_LASTDIG - The last digit You are given two integer numbers: the base a (0 &lt;= a &lt;= 20) and the index b (0 &lt;= b &lt;= 2,147,483,000), a and b both are not 0. You have to find the last digit of a^b. (without doing any mod) . | gfg_Find the maximum possible value of a[i] % a[j] over all pairs of i and j . | 2nd maximum is the answer (other is always smaller than 2nd_mx%1st_max) | . reverse problem cf_484b &lt;/pre&gt; . | toph_Modulo Given an array A of N integers. Then there will be Q queries. In each query You will be given an integer M. For every i where 1≤i≤N you have to change A[i] to A[i] mod M. After executing all queries you have to print the array A in the order of input. - be careful to put newline in i==n . | 495B_Modular Equations . # print the number of solutions of the modular equation (a mod x = b). (0&lt;=a,b&lt;=1e9) # (x&gt;b, a%x &lt;=a)by the rule of modulo *a = b =&gt; infinity (then x can be any integer larger than a) *a &lt; b =&gt; 0 (there is no such x for that) *a &gt; b =&gt; (b &lt; x &lt;= a) a = 21, b = 5 a-b = 16 (except a=1,(b==0)1:0) num of divisors of a-b(16) that are more than b . | . ",
    "url": "/09_number_theory/3_modular_arithmetic/1_basic_modular_operation/",
    
    "relUrl": "/09_number_theory/3_modular_arithmetic/1_basic_modular_operation/"
  },"47": {
    "doc": "3 binaryExpo mulmod aLike",
    "title": "3 binaryExpo mulmod aLike",
    "content": "Many of the important problems modular arithmetic solves involve finding the remainders of notoriously large exponents that cannot be computed by hand. In many cases, you’ll find that it is enough to find the first few exponents of the base to see how the modular residues cycle. You can then induct the cycle to pin down the desired residue. ex. What is the units digit of 22021? -&gt; Our residues cycle as 2, 4, 8, 6(24 mod 10), 2, 4, 8, 6, . Because each cycle has length 4 (four residues are contained inside the cycle) 2021 mod 4 = 1 (first resides, which is 2) - The units digit of a number is the last digit in its decimal representation. | Given two integer x and n, find x^n modulo m | . Naive -&gt;O(N) . //we can just multiply x, n times int power(int x, int n, int mod) { int ans = 1 % mod; for (int i = 1; i &lt;= n; i++) { ans = 1LL * ans * x % mod; } return ans; } . Circular -&gt;O(mod+period length) . - work only mod&lt;=1e7 - If we print out the value of x^0 ... x^n under modulo m, we will see that they are repeating after some point. So we can just find the period of the sequence and then we find the answer. Period is always &lt;=m . int power(int x, int n, int mod) { if (mod == 1)return 0; vector&lt;int&gt; a;//upto 1e7 vector&lt;bool&gt;vis(mod, false); a.push_back(1);//x^0 vis[1] = true; int cur = 1, st = 0; while (true) { cur = 1LL * cur * x % mod; if (vis[cur]) { st = find(a.begin(), a.end(), cur) - a.begin(); break; } vis[cur] = true; a.push_back(cur); } int period = (int)a.size() - st; if (n &lt; st)return a[n]; n -= st; return a[st + n % period]; } . example: . | 2018 AMC 10A Problems/Problem 19 . A number m is randomly selected from the set {11, 13, 15, 17, 19}, and a number n is randomly selected from {1999, 2000, 2001, . , 2018}. What is the probability that mn has a units digit of 1? -&gt; Given: - m ∈ {11, 13, 15, 17, 19} - n ∈ {1999, 2000, ..., 2018} Step 1: Analyze the units digits of m: - 11: Units digit = 1 (always 1 for m^n). - 13: Units digits cycle as 3, 9, 7, 1 (cycle length = 4). - 15: Units digit = 5 (never 1 for m^n). - 17: Units digits cycle as 7, 9, 3, 1 (cycle length = 4). - 19: Units digits cycle as 9, 1 (cycle length = 2). Step 2: Determine probabilities for each m: - m = 11: Always 1 → Probability = 1. - m = 13: n mod 4 = 0. 5 values in n, Probability = 5/20 = 1/4. - m = 15: Never 1 → Probability = 0. - m = 17: n mod 4 = 0. 5 values in n, Probability = 5/20 = 1/4. - m = 19: n mod 2 = 0 (even n). 10 values in n, Probability = 10/20 = 1/2. Step 3: Calculate overall probability: Each m is equally likely (1/5): - Total probability = (1/5)(1 + 1/4 + 0 + 1/4 + 1/2) = (1/5)(4/4 + 1/4 + 0/4 + 1/4 + 2/4) = (1/5)(8/4) = 2/5. Final Answer: The probability that m^n has a units digit of 1 is 2/5. ----- - When you multiply two numbers, the units digit of the result is determined only by the units digits of the numbers being multiplied. - Each time we multiply, only the units digit of the intermediate result matters. The higher digits do not affect the units digit. - By focusing on the repeating patterns in the units digits of powers (like cycles of 3,9,7,1 for 13), we can predict the units digit of mn without performing full multiplication. | . # . Binary Exponentiation . https://cp-algorithms.com/algebra/binary-exp.html . Binary exponentiation (also known as exponentiation by squaring) is a trick which allows to calculate an using only O(logn) multiplications (instead of O(n) multiplications required by the naive approach). -&gt; Although the complexity of both approaches is identical, iterative approach is faster than recursive . Recursive -&gt;O(logn) . - We can use divide and conquer to solve this problem. n = 0 -&gt; x^n = 1 n is even -&gt; x^n/2*x^n/2 -&gt; (x2)n/2 n is odd -&gt; x^floor(n/2)*x^floor(n/2)*x -&gt; x*(x2)n-1/2 . int power(int x, long long n, int mod) { if (n == 0) return 1 % mod;//base case int cur = power(x, n / 2, mod);//to compute (x^(n/2)) % mod if (n % 2 == 0) { return 1LL * cur * cur % mod; } else { return 1LL * cur * cur % mod * x % mod; } } . Iterative v1 -&gt;O(logn) . - any integer n can be written as sum of power of two -&gt; x13 = x23+22+20 = x23*x22*x20 . int power(int x, long long n, int mod) { int ans = 1 % mod, cur = x % mod; for (int i = 0; (1LL &lt;&lt; i) &lt;= n; i++) { if (n &amp; (1LL &lt;&lt; i)) { ans = 1LL * ans * cur % mod; } cur = 1LL * cur * cur % mod; } return ans; } . Iterative v2 -&gt;O(logn)*** . - same as v1 but in different way. Basically we can get the binary representation of n from LSB to MSB by dividing n by 2 each time. If the current bit is 1, then we multiply the answer by x2i . int power(int x, long long n, int mod) { int ans = 1 % mod;//mod can be 1 while (n &gt; 0) { if (n &amp; 1) { ans = 1LL * ans * x % mod; } x = 1LL * x * x % mod; n &gt;&gt;= 1; } return ans; } . example: . | CSES-1095_Exponentiation . Your task is to efficiently calculate values a^b modulo 10^9+7. Note that in this task we assume that 0^0=1. | UVA-1230_MODEX . Given integers x, y and n, compute x^y mod n. In this question, you are tasked to program an efficient way to execute this calculation. | UVA-374_Big Mod Calculate R := B^P mod M for large values of B, P , and M using an efficient algorithm. The input will contain several test cases, but not given the value of t, M is an integer in the range 1 to 46340 inclusive (so it also support circular way to finding exponentiation O(mod+period length), but not support naive method O(n) because P-&gt; 0 to 2147483647 inclusive) . | 913A_Modular Exponentiation . The following problem is well-known: given integers n and m, calculate 2^n mod m You are asked to solve the \"reverse\" problem. Given integers n and m, calculate m mod 2^n (1&lt;=n,m&lt;=1e8) -&gt; python can support large nunber, or java BigInteger -&gt; n &gt;= 31 ? m : m % (1 &lt;&lt; n)) . | https://www.spoj.com/problems/LASTDIG/ | UVA_11029 Leading and Trailing . C function pow(125456, 455) can be represented in double data type format, but you won’t get all the digits of the result. However we can get at least some satisfaction, if we could know few of the leading and trailing digits. This is the requirement of this problem. For each line of input there will be one line of output. It will be of the format LLL . T T T , where LLL represents the first three digits of nk and T T T represents the last three digits of nk. You are assured that nk will contain at least 6 digits. n and k. n will fit in 32 bit integer and k will be less than 10000001 . # for finding first three digit Logarithmic Identity: Formula Used: log10(n^k) = k × log10(n) The idea here is to use the logarithmic identity to transform the problem of finding the first few digits of n^k into a problem of dealing with logarithms. In this case: - log10(base) computes the logarithm of base (which is n in the function). - Multiplying this by exp (which is k in the function) gives the logarithm of n^k, i.e., logValue = exp * log10(base). Extracting the Fractional Part: fractionalPart = logValue - floor(logValue); Logarithms produce a number in the form of an integer part and a fractional part. For example, if log10(1000) = 3.0, the integer part is 3 and the fractional part is 0. To get the fractional part (the part after the decimal point), the floor(logValue) function is used, which removes the integer portion. For instance, if logValue = 5.2356, then fractionalPart = 0.2356. Calculating the First Three Digits: pow(10, fractionalPart) gives us the number 10^fractionalPart, which is a number between 1 and 10. This is a key step for extracting the significant digits. For example, if fractionalPart = 0.2356, then pow(10, fractionalPart) will give something like 1.78 (the first part of the number, representing the significant digits). Multiplying this result by 100 scales it up to get the first three digits. For example, if pow(10, fractionalPart) = 1.78, then 1.78 * 100 = 178. The result is then cast to long long to obtain the integer value of the first three digits. Returning the Result: The function returns the first three digits as a long long integer. Precision Handling (more precision) . Logarithmic Method (calculateFirstThreeDigits): . | Relies heavily on double precision to handle the fractional part and pow function. | Floating-point operations, especially with large numbers, can lead to small inaccuracies due to precision limits. | Example issue: If log10(nk) = 12.999999, floor(logValue) might misinterpret the result, leading to incorrect digits. | . Combined Logarithmic with Modular Arithmetic: . | Adjusts fractional part alignment more explicitly: lg -= floor(lg) - 2; This ensures a more stable computation for the leading digits by shifting the fractional part to focus on significant digits. | Adds a small epsilon (1e-9) during extraction to stabilize floating-point operations. | . | . Mulmod and Binary Exponentiation like Problems . https://cs.stackexchange.com/questions/77016/modular-multiplication . | Why use mulmod ? | . - When multiplying two large numbers where (𝑎⋅𝑏) exceeds the range of long long. - To ensure correctness in modular arithmetic computations in languages or systems with limited integer sizes. | Given three integers x,y and m, find x\\*y modulo m. (1&lt;=x,y&lt;=1e18, mod&lt;=1e18+7) | . a * b % mod is overflowing because of a,b,mod are very large. x * y = x+x+...x (upto y times) . long long mulmod(long long x, long long y, long long mod) {//O(logy) long long ans = 0; while (y &gt; 0) { if (y &amp; 1) { ans = (ans + x) % mod;//do addition, instead of multiplication } x = (x + x) % mod; y &gt;&gt;= 1; } return ans; } . - we can also use 128 bit integer for this purpose . long long mulmod(long long x, long long y, long long mod) { return (long long)((__int128)x * y % mod); } . x mod 2k = x&amp;(2k-1) -&gt; equal to the last k bits of x . | Given two integers x,n, find xn modulo 264 | . unsigned integers are represented modulo 2^k, where k is the number of bits of the data type. unsigned int are represented modulo 2^32 . //benefit of data type ranges #define ull unsigned long long ull power(ull x, ull n) { ull ans = 1; while (n &gt; 0) { if (n &amp; 1) { ans *= x;//ull always do mod by 2^64 } x *= x; n &gt;&gt;= 1; } return ans; } . example: . | codechef_Chef and Riffles . Let f be a permutation of length N, where N is even. The riffle of f is defined to be the permutation g=(f(1),f(3),…,f(N−1),f(2),f(4),…,f(N)) You are given two integers N and K. Output the resultant permutation when you riffle the identity permutation of length N, K times. 1≤T≤100, 1≤N≤3⋅1e5, 1≤K≤1e9, N is even The sum of N across test cases does not exceed 3⋅1e5 . | spoj_ZSUM - Just Add It . For two given integers n and k find (Zn + Z(n-1) - 2Z(n-2)) mod 10000007, where Zn = Sn + Pn and Sn = 1^k + 2^k + 3^k + … + n^k and Pn = 1^1 + 2^2 + 3^3 + … + n^n. (1 &lt; n &lt; 200000000, 0 &lt; k &lt; 1000000 ) . | spoj_LOCKER - Magic of the locker . you are given a number n , and break it into parts such that product of all parts is maximum. | . ",
    "url": "/09_number_theory/3_modular_arithmetic/3_binaryExpo_mulmod_aLike/",
    
    "relUrl": "/09_number_theory/3_modular_arithmetic/3_binaryExpo_mulmod_aLike/"
  },"48": {
    "doc": "3 modular arithmetic",
    "title": "3 modular arithmetic",
    "content": "https://youkn0wwho.academy/topic-list/?category=basics&amp;subCategory=modular_arithmetic . ",
    "url": "/09_number_theory/3_modular_arithmetic/",
    
    "relUrl": "/09_number_theory/3_modular_arithmetic/"
  },"49": {
    "doc": "09 number theory",
    "title": "09 number theory",
    "content": "https://www.hackerearth.com/practice/math/number-theory/basic-number-theory-1/tutorial/ . ",
    "url": "/09_number_theory/",
    
    "relUrl": "/09_number_theory/"
  },"50": {
    "doc": "04 divide and conquer",
    "title": "04 divide and conquer",
    "content": "Divide and Conquer follow three steps, - Divide (break the given problem into subproblems of same type) - Conquer (recursively solve these subproblems) - Combine (appropriatly combine the answers) . example: . | abc293e_Geometric Progression . Given integers A, X, and M, find ∑(i=0-&gt;X−1)Ai, modulo M (1&lt;=A,M&lt;=1e9, 1&lt;=X&lt;=1e12) (m can be any number) a^0 + a^1 + a^2 ... a^n-1 (mod m) = (ax-1/a-1) % mod -&gt; we can't use these formula because m can't always prime .. can be done using extentedgcd - when we have to do something in k times, then most probably use binary exponentiation(through recursion) to solve faster - use divide and conquer technique a0 + a1 + a2 + a3 + a4(a0 + a1 + a2 + a3) -&gt; x is odd prev(same as odd) + a^x -&gt; x is even . | . ",
    "url": "/04_divide_and_conquer/",
    
    "relUrl": "/04_divide_and_conquer/"
  },"51": {
    "doc": "16 geometry",
    "title": "16 geometry",
    "content": "Online Graph Generator -&gt; https://www.desmos.com/calculator . Points . example: . | https://www.codechef.com/CFUS2020/problems/CFS2005 . You are given a grid with dimension n x m and two points with coordinates X(x1,y1) and Y(x2,y2) . Your task is to find the number of ways in which one can go from point A(0,0)to point B(n,m) using the shortest possible path such that the shortest path neither passes through X nor through Y. n!/(r1!*r2!) S(A ∪ B ∪ C) = S(A) + S(B) + S(C) − S(A ∩ B) − S(A ∩ C) − S(B ∩ C) + S(A ∩ B ∩ C) -&gt; ans = S(A ∩ B ∩ C) . | codechef_LTIME24_NWAYS . Devu has two sets of points. Set A contains points having X co-ordinate 0 and Y co-ordinates varying from 1 to N(both inclusive). Set B contains points having X co-ordinate K and Y co-ordinates varying from 1 to N(both inclusive). Both sets contains N number of integral points. He wants to calculate the sum of number of ways to going to the each point of set B from the each point of set A . bruteforce-&gt;ans = ans + fact[y2 + x2 - y1 - x1] * ifact[x2 - x1] * ifact[y2 - y1]; . | . Lines . Circles . | https://codeforces.com/contest/2074/problem/D | . Triangles . Non-Degenerate Triangle . https://codeforces.com/problemset/problem/2053/A . https://codeforces.com/problemset/problem/2009/D . Area . https://www.youtube.com/watch?v=y9zRZYnSf2Y&amp;list=PLpRww_DKmkSYiodL6xsSQyzjhJ8VPtq1K&amp;index=15 https://codeforces.com/problemset/problem/1620/B . Trapezoids . Isosceles Trapezoids . https://codeforces.com/contest/2061/problem/B . https://www.youtube.com/watch?v=AlyWS8bG3kE . Quadrilaterals . ",
    "url": "/16_geometry/",
    
    "relUrl": "/16_geometry/"
  },"52": {
    "doc": "others",
    "title": "others",
    "content": "Useful link (cf rating&lt;=1300) . | The Ultimate Topic List Module_1 by youkn0wwho | Competitive Programming Roadmap (target: [gray, blue]) by TheScrasse | . Group For solving problem… . | 100 Easy Problems (Bootcamp) by Errichto | Assiut University Training - Newcomers | | [ICPC Mansoura | Level 0 training | Public](https://codeforces.com/group/5pUldkahAU/contests) | . | ICPC_Mansoura Level 1 training | . # . ",
    "url": "/assets/others/",
    
    "relUrl": "/assets/others/"
  },"53": {
    "doc": "CP Archive",
    "title": "Competitive Programming Archive",
    "content": "Welcome! Browse through problems, categories, and solutions! . ",
    "url": "/#competitive-programming-archive",
    
    "relUrl": "/#competitive-programming-archive"
  },"54": {
    "doc": "CP Archive",
    "title": "CP Archive",
    "content": " ",
    "url": "/",
    
    "relUrl": "/"
  }
}
